<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>日落大道</title>
    <link href="/2022/01/01/%E6%97%A5%E8%90%BD%E5%A4%A7%E9%81%93/"/>
    <url>/2022/01/01/%E6%97%A5%E8%90%BD%E5%A4%A7%E9%81%93/</url>
    
    <content type="html"><![CDATA[<h2 id="日落大道"><a href="#日落大道" class="headerlink" title="日落大道"></a>日落大道</h2><blockquote><p>我们寻找着在这条路的中间<br>我们迷失着在这条路的两端<br>每当黄昏阳光把所有都渲染<br>你看那金光 多耀眼<br>我们奔跑者在这条路的中间<br>我们哭泣着在这条路的两端<br>每当黄昏阳光把所有都渲染<br>我看到夜的黑暗<br>——梁博《日落大道》</p></blockquote><h3 id="Part0"><a href="#Part0" class="headerlink" title="Part0"></a>Part0</h3><p>从字面意义上来看“日落大道”：一条能看到日落的道路应是一条自东向西的道路，北京市海淀区知春路刚好符合这个特点，它就是我的“日落大道”。</p><p>人很多时候需要一些仪式感，就像此时此刻在中卫通大厦顶层，耳机里播放着吉林老乡梁博演唱的《日落大道》，眼睛里倒映着远处的北京西山和金黄色的落日。这种时候一般都有些神奇的事情发生，就像武侠小说里日月交辉之时，月光直射山洞口方能有秘密显现。反思一下，这种“独享的moment”在工作整整一年的记忆里居然没有一丁点印象。</p><p>在日复一日的工作生活里，我只能在匆忙上厕所的路上歪头看一下茶水间的落地窗，北京常年晴朗的湛蓝天空下，可以望见深绿色的西山。如果是晚上，可以见到知春路上交错斑驳的车灯在一点点蠕动。北京是比较靠东边的，经常性的，埋头伏案工作一段时间之后起身，外面就黑了。</p><p>工作场所有种特别的结界一样，它有两种奇妙的效果：1. 时间总是过得很快，2. 工作总是做不完</p><p>从2020年11月到2022年1月，我在这里工作一年多了，遇到了很多人，想通了很多事情，也对人生有了更多的疑问。</p><p>软件工程和云计算有一个概念叫“云原生”（Cloud Native），它的大概意思是在云上构建程序、全程用云的基础设施和功能实现的互联网服务。</p><p>开始学这门课的时候我非常不理解为什么会有这个说法，我心里的疑问是：<strong>难道不是所有程序都是这么跑的吗</strong>？</p><p>后来我才发现，还真不是</p><p>为什么要强调这个概念，因为有大量的政府、银行和其他行业的大量技术软件设施还是实体的服务器和各地机房。他们的程序构建在这些非常传统的东西之上。在他们的世界里，传统纸质实体数据 =&gt; 数码技术、计算机技术 =&gt; 互联网技术，是两代的技术革新，而云厂商是为了吸引这一类的用户才提的这个概念。</p><p>我还记得《家有儿女》里有一集是小雪要用一万块租借实体服务器搞网站。而到我上大学的时候，大家说起一个项目，说部署，都是指代阿里云腾讯云几十块钱一年的云服务器了。</p><p>我大学学习生活的年代，是“后革命时代”，跳过了计算机技术对原本行业的冲击，直接来到了全民互联网的时代，而且是革命后“云原生”技术已然占领高地的时代了。那些之前很新颖的技术在革新过程中成为了搞开发的“水电煤”，是平常感知不到，但无处不在用的东西。相对应的是，我们这一批没有常年接触计算机技术的人，对于很多之前的概念和理解是缺失的。</p><p>这个案例给我的思考是，我觉得程序员应该都去学学计算机和互联网的历史，或者说计算机这个学科已经发展到需要有历史学来辅助新人理解旧有概念的程度了。</p><p>从事开发工作的，熟悉计算机技术的人尚且如此，于是我想，我们这一代人，这一代从认识世界开始就被互联网包围的一代人，有多大程度上的基础概念和世界观是被网络塑造或影响的？</p><p>之前有人问过我为什么选了计算机专业。于是我开始回顾2018年做决策的自己的想法：</p><p>家里人比较尊重我自己的选专业想法，他们的逻辑比较朴素，只要选择一个“一技之长”的就可以（其实暗含了我不能选文史哲等文科专业的意思）我自己感兴趣的方向有三个：小语种、法律、金融财经相关、计算机。</p><p>选这几个专业的理由比较简单，第一，我是理科生，但是数学物理不好，所以传统工科和基础科学走不通。第二，在初高中阶段受到互联网上很多内容的影响（其中比较重要的是知乎和B站）</p><p>小语种，简单来讲就是学习一门新的语言，以后从事翻译工作。初高中阅读了比较多的近现代外国著作，我想大多数人会对王道乾翻译的《情人》开头（“我更爱你现在备受摧残的面容”）或是范晔翻译的《百年孤独》的开头（“多年以后…那个遥远的下午”）留下极深刻的印象。文学的魅力和翻译的“再演绎”，让我对翻译工作心生向往（还要感谢高中读的这么多王小波）。</p><p>法律，其实是我比较感兴趣的一门文科，初中周末去球场总要路过法院，由于其较高的地势，让我对此地的神圣性充满畏惧。除此之外，GBA游戏《逆转裁判》系列和日剧《Legal High》也让我对法律行业有了更多好感。外加吉林大学法学院属于“五院四系”，没有理由不报</p><p>金融财经，其实直到现在我依然分不清楚金融、经济、会计、审计、财政等跟钱打交道的东西之间有什么异同。但是谁不喜欢跟钱打交道的工作呢？过路财神也是财神。</p><p>最后是计算机，为啥选计算机，因为它是我唯一能接受的工科，不偏重数理（事实上我也确实没有走重 数理基础的算法方向，而是前端开发）</p><p>如果回头来看一圈这几个专业， 很快就发现，这不是13-18年知乎er们主要学习的专业吗？</p><p>这就是互联网对我的影响。在成长的人生观里，塑造了“某种东西”。我在知乎上其实学到了很多，比如看书和阅读的习惯（高中毕业后我就买了个kindle），跑步和健身活动（越来越感觉到身体的重要性），培养幽默感和见识（当年有一个产品叫知乎日报，瞎扯栏目我真的很喜欢），左派的人人平等和女权主义思想（这个真的是14、15年知乎给我的启蒙）。在那个时候，在知乎和B站尚且没有破圈的时代，我在B站上看了不少“二次元”的番剧（入宅作Fate Zero）和日剧（人人字幕上传的Legal High等）</p><p>知乎上很多人谈日剧，我也在B站上看日剧，知乎上有很多人是喜欢二次元的程序员，于是我也在B站看了一些二次元。</p><p>种种因素交织，形成了我的中学时代。那是一个六七线小县城里，班里很多同学不知道什么是知乎什么是b站，我通过这种还没大规模破圈的小众互联网论坛第一次看到了“更大的世界”。</p><p>我想，我最后在这条“日落大道”知春路的互联网企业从事开发工作，兜兜转转之中，受这两个网站信息的影响可能远比我预想的要大很多。</p><p>我看着楼下拥挤的车流，回到工位继续干活了。</p><h3 id="Part1-读书、生活、新知"><a href="#Part1-读书、生活、新知" class="headerlink" title="Part1 读书、生活、新知"></a>Part1 读书、生活、新知</h3><h4 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h4><p>从2015年开始，我每年会统计自己读的书。当时刚刚有手机，我把这些统计信息都放在了锤子便签APP里。至于为什么是锤子便签？那还是归功于知乎的推荐。</p><p>今年的书我换了一种统计方式，用豆瓣“看过”来标记读书，还能留下短评。导出数据存了一个飞书文档<a href="%5B%E5%B9%B4%E5%BA%A6%E8%AF%BB%E4%B9%A6%E7%BB%9F%E8%AE%A12021%5D(https://n7quamwevs.feishu.cn/docs/doccnGs5zkZD92PKDbN2tsCc4kn#)">年度读书统计2021</a>，总计42本，宇宙的终极数字。</p><p>工作的这一年反而比在校时期读的书更多，事实证明，书都是省下来的时间看的。Kindle我不太常打开，除非是mobi格式的书，pdf或epub格式的书用ipad看，微信读书的电子书比较方便，午休和地铁路上常用它看（缺点是涉政著作会有删改）</p><p>我总觉得自己和推理著作比较有缘分，关于推理小说 / 志怪小说 / 侦探小说 / 犯罪题材 的东西总是能在不经意之间比较“戳我”，但我完全不是字面意义上的推理迷。</p><p>按说对推理最原始的记忆应该是小学读的《冒险小虎队》系列，然后再看的作品就不多，东野的《解忧》开启的《白夜行》。至于其他跟推理悬疑相关的著作，无论是动漫还是小说。卷福的英剧《神探夏洛克》日漫《名侦探柯南》还是国内的电影《唐人街探案》紫金陈的三部曲系列和改编的电视剧，都没看过，一部都没有。</p><p>不过高中有好友很喜欢推理相关，参与过国内推理论坛的一些活动，我记得最大的奖品是《S.忒修斯之船》。最后我们的推理历程被期中考试打破了。再然后是从《冰菓》日常推理番剧开始，读了一些和阿加莎克里斯蒂有关的作品，比如《罗杰疑案》、《ABC谋杀案》、《无人生还》还有改编电影《控方证人》、《非自然死亡》</p><p>到了大学时候，也看了一点点《无人生还》三集电视剧和《东方快车》还有小说《嫌疑人X的献身》《冰菓》全套小说，虽然烂尾但俺还是看完了的《轮到你了》 还有韩国电影《杀人回忆》</p><p>严格来说，《福尔摩斯》和其他日本作家的推理著作我是从来没看过，包括江户川乱步 松本清张啥的。俺只看过阿婆的一些作品</p><p>不过无论是比较喜欢的up主私下里的爱好，还是身边的两个“圈子”的朋友奇妙地同时向我安利推理作品，甚至刷视频不经意地滑到，似乎冥冥中告诉我你要多看看这些东西。</p><p>所以，希望明年能保持这个读书量级，然后多钻研一下推理相关作品吧。</p><h4 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h4><p>先说说B站，今年的年终报告里，b站总时长1800小时，365天全勤。我观察周围用b站的人，也几乎是全勤。</p><p>作为一个互联网产品，有这样的用户粘性是很可怕的，你可能不会天天打开支付宝美团滴滴，但是你会天天打开微信QQ和B站。有这样的“成瘾性”，内容质量和评论生态也相对优秀，与之能一较高下的可能只有抖音一家。年初时我还认为西瓜视频有超过B站的机会，但当我看到大量西瓜博主转到B站还能做成超大粉丝量，且评论区互动比西瓜高了三四个量级的时候，我觉得它已经是一个内容壁垒非常高的“倒不了”的视频平台，我对它的判断是，它一定会是中国的youtube。</p><p>同为在我的中学时代帮助我很多的互联网平台，B站在越做越好，欣欣向荣，反观知乎一直在走下坡路，令人感叹。</p><p>现在很多人怀念18年之前的b站，我也一样。我喜欢2016年2017年的它，当时还有大量没有被删掉的日剧，还没有灌水程度极高的生活区，还没有那么多百万粉up主。</p><p>留给我印象极其深刻的up主是瞎看的“三生三世”：瞎看什么、阅后即瞎和嘻咦啊看。在尚未破圈的b站，转生三世仍有百万粉丝，称之为一代传奇绝不为过。我特别喜欢他们的影视解说，那是完全不同于现在流水线讲剧情的内容的。在我看来，它代表着的是一种调侃式、相声式解说的最高形式，是绝对的影视区独一档。</p><p>把视频画面、音频声轨和剧情编排拆开揉碎了再重新演绎，且主旨和谜题可以维持不变，但从微小的地方入手解构（干过计算机的都知道重构有多么容易做成吃力不讨好）“混剪”中携带剧情，还抛出大量原创和非原创的梗。这实在是太酷太有想法了。从那个时候开始，我对影视行业，新闻行业，自媒体行业的从业者抱有极高的敬意。（这也是没有选择这些行业的理由，我觉得我没有那么灵光的鬼才大脑）</p><p>给我带来的另一个影响是，让我相信了声音能传达的力量。</p><p>阅后即瞎的两位解说都是正统科班播音员，声音能文能武，堪比声优的多种变化。如果说整条视频的文案和视频剪辑能占军功章的一半，我想剩下的一半要归功于播音员的精彩演绎。</p><p>同样的，我今年比较喜欢的一位音乐区UP主HOPICO Music，用纯正的“播音腔”来讲他理解的东亚音乐。</p><p>这是一个多感官受强烈刺激的时代，互联网消费级的内容生产是极其简单且廉价的，我相信纯粹的声音带来的强大力量。后来我大学时加入广播站，今年开始办播客。我没有去做更炫酷和眼花缭乱的视频剪辑。文字、音频、视频 三个可以说是不同维度的感观变化里，我更倾向于音频和文字，可能因为它们的技术更简单纯粹，而且传播出的信息和能量是完全不亚于视频的，它们能承载的内容在这个时代里仍然具有超强的竞争力</p><p>这一定是一条很艰难的道路，但也可能是一种old school，一种“不妥协”的范儿。</p><h4 id="新知"><a href="#新知" class="headerlink" title="新知"></a>新知</h4><p>随着年龄的增长，我逐渐发现身体重要，心理健康重要，生命重要，生命的意义重要。每个所在的当下都是礼物，所以它叫做Present。</p><p>Keep这个APP常年在我的手机里，真正用它的时候却不多。最近一段时间我逐渐get到keep的理念了，我总结为：“自己为自己负责”。生活是你自己的，该怎么过都把握在自己手里（似乎？）所有的规划、行动都要自己把握。</p><p>比如健身、读书的习惯，或者是写作的习惯，还是学习做菜都是一样的，这一切都是有内在驱动力才会做下去，而且能做好。当你自己发自内心的想去做这些事，你自然而然地精益求精。</p><p>其实我不会做饭，在今年七月前自己没怎么开过火，之前的住处是我和另一对情侣合租，厨房比较小而且全是他们的厨具，我不好开火做饭。下半年租的房子正好，从头置办了锅碗瓢盆米面粮油。</p><p>可能是从小看的影视剧原因，我一直觉得画面里，一个男人在厨房鼓捣来鼓捣去做饭是非常有荷尔蒙气息的，所以我一直认为一个男人一定要会做饭才行，我也是这么要求自己的。</p><p>尤其是作为一个东北人，会炖菜是刻在DNA里的，调味也是比较简单的，东北家常菜可以说是最简单上手的菜式，我很庆幸自己是一个东北人，随便做做东西就很好吃。</p><p>不过，对做饭的看法是在最近这两个月改变的。我看了一些Gordon Ramsay，看了B站的高寒，还有电视剧《东京大饭店》。坦白说我没有学习到很多很多知识，因为他们主要做的是西餐。而我只是一个做东北乱炖的新手，连胡萝卜丁都做切不均匀。</p><p>让爱好赶上人家吃饭的手艺是纯纯的异想天开，但看了这么多也不是没有收获，起码对做饭的理念有了新的认识。有人说烹饪是化学，是美拉德反应和很多化学变化产生的芳香类物质的魅力。不过在我看来， 烹饪和做前端一样，是有一种“所见即所得”的强烈正反馈的，开动脑筋想多种配合方案的极具趣味的东西。</p><p>还有最重要的一点，做饭是要吃的。看到品尝的人脸上绽开笑容，这就是研究烹饪的意义。同样，做前端就是为了服务用户更轻松愉快地浏览互联网上的信息。在“为人民服务”上，烹饪和开发是完全一致的。</p><h3 id="Part2-技术、工程师、团队、产品、工作室"><a href="#Part2-技术、工程师、团队、产品、工作室" class="headerlink" title="Part2 技术、工程师、团队、产品、工作室"></a>Part2 技术、工程师、团队、产品、工作室</h3><p>我在这里工作有满满一年的时间了，我把这段时间叫做新手出村的一年</p><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><p>公司内部有一个我很喜欢的FaaS产品，我常常用它，也常常听他们团队的人分享。有一段关于技术的说法印象深刻：</p><p>“经历过无数次技术变迁和技术选型之后，我发现最终取胜的，永远都是「简单」的那个技术，这样的技术也是我心中的好技术。”</p><p>其实从软件开发的层次上看，各种技术（无论前后端）的发展变化不可谓不快：云计算从虚拟机到容器再到云原生，十年时间已经迎来送往了多个时代；数据库从关系型到 NoSQL 再到 NewSQL，商业型数据库、开源数据库互相印证一路前行；运维们也从“人肉运维”到 DevOps、AIOps、DevSecOps，引发了行业性的被替代危机。</p><p>看完雪碧老师翻译的《JavaScript20年》之后，我想，如果我们把时间维度拉长到以 10 年、20 年为单位，会发现这里面的很多所谓新兴技术，有的在不知不觉间消亡，有的在沉寂多年以后又再重启。但无论什么样的趋势，最终的结果一定是技术能力的下沉和降低门槛，更深层次的效果一定是“降本增效”，技术的本质应该就是如此。</p><p>简单的技术具备一种特性，它能很快速地惠及更多人，更能够赋予想要创造世界的人强大的能力，他像是魔法师的魔杖一样，充满变化，改造和创造着世界。</p><p>我是一个技术工人，我喜欢技术。</p><h4 id="工程师"><a href="#工程师" class="headerlink" title="工程师"></a>工程师</h4><p><strong>职业是个人所从事的服务于社会并作为主要生活来源的工作。</strong> 它是份工作，通过此工作，你对社会有所贡献，同时能取得自己的生活来源。</p><p><strong>根据中国职业规划师协会的定义，职业=职能X行业</strong>。职能是你能发挥的作用、你能干什么、掌握什么技能去做什么事情；以前端为例，属于计算机互联网行业，我们要写代码、做页面开发。</p><p>工程师就是要实现业务的自动化，进而实现自我的自动化，由浅入深，最终”消灭自己”。DRY（Don’t repeat yourself）对于某些重复发生的事情，只干一次就好，以后也不需要再重复做。工作需要思考短期价值与长期价值，重复性的工作，往往缺少长期价值，我们通常称之为”舒适区”。在飞速发展的业务状态下，重复自我不走出舒适区，不思变，很可能就会被取代。我们需要达到的状态是：今天做完一件事，明天开启新的事，</p><p>工程师的自动化思维，内部逻辑是如何干净而彻底的解决问题，这其中，编码只是一种常态的工具。这种高质量的解决问题的思维，在任何领域都适用。</p><p><strong>本质上，我认为工程师文化也是一种产品文化，把问题以一种自动化的方式解决的思维逻辑——这可能才是我们真正应该推崇的工程师文化。</strong></p><p>从软件工程角度来说，传统意义上的工程强调的是复制性，但软件的编码却是一项不确定性很强的创新性工作，我们总在不断迭代出新的技术。所以软件工程是颇为复杂的东西，它需要在不确定性和复制性这对矛盾中平衡。</p><p>所以优秀的工程师还需要有批判精神。经验当然是有价值的，但过于相信惯例就会抑制创新能力。寻求本源，不迷信惯例和权威。以数据为指导，从根源出发去系统性解决问题。</p><p>回归工程师的本质，讲技术用在有用的地方，在公司就将之转化为对公司的价值，在开源社区就为广大基础设施建设添砖加瓦，为更多人创造价值。</p><h4 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h4><p>我所在公司是一个平均在职七个月的地方，去年我刚来的时候，我是组里最年轻的员工，今年我从学校回来的时候，我已经是在组里呆过的第三老的员工了。</p><p>如何让大家同在一个Context下是一件很难的事情， 也逐渐觉得招聘这件事情真的很重要。但本质问题是人很重要，标准不能降下去。不然后续当“保姆”去辅导的成本要比这个高的多。</p><p>面临一大堆的新人，其实外包同学或者校招社招同学还好（虽然外包同学占据组内一半人力后，事故和回滚数大量增加），比较难带的是实习生，尤其是明显为了应付应急情况而招聘来的实习生。因为这极有可能效果不佳，堆人力不能解决全部的问题。年轻不是做不好事情的挡箭牌，在互联网不缺年轻人，在哪里都不缺年轻人。但是耕种熬的事情是把事情做完，把事情做好。</p><p>之前看一个ld的说法，招聘需要“闻味道”，招聘符合团队味道的同学进来。这个看上去比较虚，但是实际上的确很重要。换句话说就是聊得来，眼里有光之类的感觉，官方的说法就是有想法，有潜力。这样的同学招进来你会发现解决问题的能力很强，适应力很强，进步很快。面试五分钟就能给人定级了，我现在深以为然。</p><p>招聘不能把标准定得太低，否则什么牛鬼蛇神都来了。</p><p>同样的，也不能把标准定得太高，一个最简单的例子是，我调查为什么我们在校招里竞争不过同公司的一些其他部门</p><ul><li><p>“没听说过”</p></li><li><p>“tob业务没啥挑战”</p></li><li><p>感觉不酷</p></li></ul><p>之前找人的时候打的旗号是某知名APP，还能招一些人 现在换成名不见经传的中台，旗号打不出去，风评就差了一截。可能大家会有反驳，校招生不懂事，“务虚”。</p><p><strong>归根结底是外界接触不到我们的产品 外界不懂得我们的价值。</strong>我们离他们太远了。用之前的话术来说，我们是知名娱乐APP，这是一个大团队，是几亿人在用的东西，普及度很高。或者同样是内部中台，如果你说“支付中台”也会吸引很多人来，因为在大家的认知里，这是搞钱的，一听就有安全性和并发的要求，肯定有挑战性，更何况还有金额里无数个0带来的视觉感官刺激。但同样是中台，为什么搞审核的中台就不行？</p><p>试想有一家你没听过的企业找到你，你会同意去吗？</p><ul><li><p>那如果你用的技术里有他们的产出的产品呢？比如Authing快速的登陆 / 权限管理</p></li><li><p>比如社区里对他们的产品好评如潮，你在技术文章或大牛发的twitter里听说过他们的东西呢？比如Netlify托管？</p></li><li><p>如果在社区里常年输出各种方向的技术文章，积累广泛好评呢？比如360的奇舞周刊？</p></li></ul><p>所以归根结底到这，假如我们没依托于母公司，没有依托于各大内部业务方，我们还有多大的“竞争力”和“声誉”？</p><p>这是一个找人和吸引人的差别，是<strong>主动seek和被动聚拢</strong>的差别</p><p>如果团队未来没有在技术侧有更多内容、产品、技术的产出，团队没法招揽来更优秀的人（当然，如果只找人力来填急速发展的业务，那当我没说）</p><h4 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h4><p>一年里经历了三次业务调整，一次小组拆分，一次部门改换，一次中国区非中国区部门拆分。虽然有各种组织架构上的变动，业务还在飞速发展。</p><p>我比较喜欢的公司特质是“深入事实”，或者叫“实事求是”，鼓励大家去真实的场景去做调研。起初我特别惊讶技术岗为什么还要“出差”，直到我看到一批出差后的调研报告，那些深入用户场景去做的调研，那些只有身临其境才会发现的问题。</p><p>一个例子，也是我讲给新公司HR的例子是，在直播审核场景中，工作人员为了看视频里画面上的文字，要用一面小镜子靠在屏幕边上，看镜面反射的字来做决策。</p><p>这是一个极其简单的功能，对于一个前端同学来说，只要一行代码就能做到，但是我们真正的用户却在用一种原始的方法来做到这件事情。我看到这个case后第一反应是羞愧，我一直引以为傲的产品居然缺少了这种功能，迫使用户“倒退回原始”，这就是现代技术的革新带来的生产力提高吗？第二个反应是疑惑，为什么有这样的问题，他们不主动提出来，是他们不愿意麻烦我们，还是提出问题的流程繁琐导致的？</p><p>如何让这个东西更加好用，哪怕是一两个简单的选项都可以让体验更好一些，在这个过程中做出合理选择不是一件简单的事情。做产品的初心，无论你是技术人员还是产品经理，都想把东西做好，这就是成就感的来源。</p><p>另外一个我印象深刻的例子是，音频组的调研报告显示，由于各种切片音量忽大忽小，审核同学每年的音量都要调高10%，而且会对耳朵造成不可逆的损伤。因此，我们推出了音量均衡功能，帮助他们更好地工作，如此也算是产研们的人文关怀。</p><p>技术的力量是中性的，但是产品是有善恶和好坏之分的。技术始终是手段，最终都要落到产品，落到实处去，真正地帮助到人，真正的有实际生产力的提高。身为有技术有想法的工程师，这是你的职责。</p><h4 id="工作室"><a href="#工作室" class="headerlink" title="工作室"></a>工作室</h4><p>我在字节工作一年了（为什么实习生就不发一周年纪念充电宝呢？）这段时间里我从被带到带人，从不懂很多基础设施的小白到给其他实习生当mentor，或是给很多正式员工做presentation。经历了很多，也想通了很多事。</p><p>如今的工作室，或者叫俱乐部，有很多亟待改善的地方，而背后的原因就是焦糖本身的宗旨：能让每一个在其中的同学都有所收获。结果无论是考研还是工作甚至是转行，希望这段经历能成为一段特别的回忆吧，一起吃吃喝喝，一起熬夜写文档，一起享受获奖那一刻的喜悦。互相帮助，内推是完成自己的指标，也是帮学弟学妹找工作找实习积累经验</p><p>刚刚进入大学或者刚刚进入工作室的时候，对技术和业界一知半解是正常的，需要做的事情是慢慢学习慢慢成长。</p><p>到了担任工作室负责人的时候，主要做的是如何组织大家活动，主动帮助其他人参与进学习生活中去/</p><p>到了大四的时候，有了一段时间的工作经验后就会更加知道工作室欠缺的地方差在哪里，这些不足之处不是以前的自己能发现的。有多大能力干多少事情，每个阶段有每个阶段需要做的事情。</p><p>身为工作室负责人，要负担起这个责任。焦糖能持续下去多少年我不知道，但是我知道我能做一些我力所能及的。</p><p>而这些新的感受和感悟，是在工作室获得不到的，只能前往业界前沿干一段时间之后才明白。</p><p>这就是为什么我推荐大家去实习：实践才是检验真理的唯一标准，中学 =&gt;大学 =&gt; 研究生，目前看来是很正常的流程，是最“稳妥”的流程，常规的发展历程。但是，你要如何找到你想要做的事情？如果你没工作过，没实习过，怎么会知道你是不是适合，是不是喜欢？</p><p>离开了校园的土壤，没有人规定一个人的成长路径是什么样的，是通过读书？还是请教他人？是相关培训，还是“偷师”，这些都是让自己成长的机会。成长是自己的事情，不是别人给予的任务，是一种自发性的行为。</p><p>这个道理，应该越早地明白，越早地开始实践最好。所以我急切地想帮助同学们在大学开始的阶段了解并适应这个道理。这是我自己赋予我自己的责任。</p><h3 id="Part3-飞驰人生"><a href="#Part3-飞驰人生" class="headerlink" title="Part3 飞驰人生"></a>Part3 飞驰人生</h3><p>在人生这条日落大道上飞驰，没有背景音乐。</p><p>不知道是不是很多人都有这种感觉：总是会弄混2020年和2021年发生的事情。</p><p>在疫情年代里度过了两年，时间都好像因为“不可抗力”陷入了停滞</p><p>对我来说，一切美好的时光都停滞在了2019年。我真心实意地想骂一句：网络世界我xxx！！！你他妈把多少人的生活！！！都他妈毁了！</p><p>我发现我有一个持续性的低迷 =&gt; 上升的螺旋里。如果有一本史书记录自己大学这几年的经历，或许就叫《史记·亦敬本纪》，会如此记载：</p><p>2018年底自尊心被成绩彻底击碎 =&gt; 19年上半年告白失败 + 全身心投入学生活动彻底摆烂 =&gt; 19年下半年开始抓住工作室，学习新东西 =&gt; 20年上半年因疫情在家待到抑郁 =&gt; 20年下半年找到工作，开始社畜身份转变 =&gt; 21年上半年对职业规划和前路迷茫，感情受挫，自我怀疑 =&gt; 21年下半年找到理想信念和坚持，养成新习惯，健康向上，逐渐发觉自己的能力</p><p>可能生活就是这种无穷无尽的“螺旋”，但总体肯定是朝着稳中向好的方向发展。就像2020是最大的迷茫期的话，2021会带一点“觉醒”的想法，可以说是开始Take Action的时间。</p><p>从2020年失恋后开始追偶像，其实是一种代餐，用来补充恋爱感。但是说实话对成员没有恋爱感，不过不了解具体机制是什么，不过确实能起到替代效果，神奇。原来的女团解散了，追的新团跟自己实习同期出道，我们都获得了很多成长，我开始跳舞、运动、听了很多华语金曲，勾起很多回忆，也是一种很特别的体验。</p><p>上了年纪就会总是想起一些陈旧的往事，就像我总是回忆2017年。很多人生观 世界观的成型在中学时期，所以你会格外记得中学时代的人。可能ta是你为数不多的，在你人生成长期陪伴你的人，在你的记忆里扮演一个相当有地位的角色。她或多或少地会扮演“避风港”的角色，让你很想去找她。</p><p>可能是自己要离职了，最近常看其他同学写的离职文档，大家伙儿还就那个挺有感情的 字里行间感情都比较充沛。（说起来，我总计今年看了4500篇文档，飞书文档真是个好东西，我以后要继续用）还有公司有很多牛逼的技术文章和分享没有看，应该多看看才是。总是很佩服大家写的Blog，都很有深度，哪怕是跟我在同一阶段的实习同学们也写出很漂亮的总结文章，我的Blog就相形见绌了。</p><p>接收了这么多input，如何验证自己的学识，一个很好的方式是输出，output是梳理思路的极好方法。之前跟Leader谈过这个话题，不要只看自己写的东西，干这个行业，有太多文档和代码不是自己写的了。原创 == 产出，但产出 ！== 原创。绝大多数时候你是站在前人的肩膀上做事，这是无可避免的。但是在此之上作出的新工作，也是一种产出。不只是你create的才是你价值的体现，你的梳理，你的整理，只要是你的output都是有价值的。</p><p>个人职业成长的角度，每个人需要有更加明确的规划，但是往往外界的变化比你的规划快得多。“双减”那段时间，有句话挺让人触动的：“时代的一粒沙，落在个人头上就是一座山”。 外部环境变化实在是太快了，可能短期规划为主，长期有一个主要的大方向就够了。</p><p>我们总说“看更大的世界”，可是什么才是更大的世界呢？是更换一家公司？是更换一座城市？是离开生活了几十年的故土？还是将目光转向浩瀚的宇宙星辰？</p><p>世界无穷无尽，和知识一样。进一寸确实有一寸的欢喜。</p><p>开始接受很多现实吧，或者换句话说叫脚踏实地。没有太多人是真正的天才，人的精力是有限的，放在这里，另一个方面相对应的就会比较缺失。到了这个岁数，更重要的事情是对时间规划和有一些比较明确的方向。</p><p>如果人没有更高尚的追求，身陷世俗的囹圄是无趣的。</p><p>我的愿望是，能发挥自己的优势和特长，通过开源软件推动社会生产力的发展，做出真正能让众多人受益的产品。</p><p>在这条道路上，我并非天赋异禀的人，但我希望能用自己的绵薄之力帮助到这个世界上更多的人，路还很长，一切的一切都刚开始。</p><p>希望能在以后的人生路上都充满热爱和干劲，几十年的光景很长，也很短。趁着年轻，做一些对社会和世界有价值的事情。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学期总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年的惊喜之作《Arcane》</title>
    <link href="/2021/11/21/2021%E5%B9%B4%E7%9A%84%E6%83%8A%E5%96%9C%E4%B9%8B%E4%BD%9C%E3%80%8AArcane%E3%80%8B/"/>
    <url>/2021/11/21/2021%E5%B9%B4%E7%9A%84%E6%83%8A%E5%96%9C%E4%B9%8B%E4%BD%9C%E3%80%8AArcane%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>11.20守点看7-9集（tx视频提前了十分钟解禁）然后开始二刷，激动的心情难以平复，才有了本文。 </p><p>为什么说是惊喜之作？因为《Arcane》从动画画面、群像剧的编排、LOL世界观IP三个方面都有相当值得赞许的地方。</p><p>首先聊聊画面。看过几年比赛的观众可能会对这个画风很熟悉，因为本部动画的制作工作室是S8全球总决赛MV 《Rise》登峰造极境的团队 Fortiche。也是世界上风格化动画最强团队之一。他们的特色就是2D原画混合3D人物，营造出“伪3D”的效果。这种有很独特的效果是看惯了国产3D动画或2D日漫绝对没有的观感。 </p><p><img src="https://z3.ax1x.com/2021/11/21/IvFBLV.png" alt="img"> </p><p>而且由于2D原画的超高质量，使得每一帧都有当壁纸的潜力。具体牛逼在哪里可以看b站<a href="https://www.bilibili.com/video/BV1G34y1Z7D5?spm_id_from=333.999.0.0">CG分析师的视频</a>，讲解非常详细</p><p>另外，Fortiche工作室和拳头的合作从很早就开始了，除了S8全球总决赛的《Rise》，还有2014年S4全球总决赛《Warriors》和K/DA的《POP/STARS》MV。除此之外，2013年金克丝上线LOL的MV《get jinxed》和2015年艾克的《Second》MV也是出自Fortiche。这个工作室和祖安皮城系列英雄也是很有缘分（或许也是拳头下的大棋） </p><p><img src="https://z3.ax1x.com/2021/11/21/IvFzef.png" alt="img"> </p><p>从2019年拳头在十周年发布会上发出《Arcane》预告到去年因为疫情而跳票，再到今年年底才全球正式发布，大家的胃口是被完完全全吊足了的。幸运的是，拳头不仅交上了一份满意的答卷，更是为为第二季制作做足了准备（今天刚刚发第二季正在制作中的预告）</p><p>魔兽电影上映后，很多人都在问拳头什么时候出LOL大电影？长期以来拳头在开发IP方面动作的迟缓，看上去很不上心的样子也逐渐在消磨粉丝的热情。《Arcane》集合中美法三国专业团队参与，以国际化的制作模式和顶尖的制作水准耗时6年完成。 </p><p>不过，这部六年磨一剑的作品，真是不负众望。总共分为三幕，每幕三集，每集四十分钟，相当于每周都是一个大电影。我特意充了tx视频VIP，不过真的值了，太值了，九集的剧作里，能见到的只有拳头满满的诚意。 </p><p>我也很想像评论区的大家一样高呼：<strong>是的，我长眼睛就是为了看这个！！！拳头请多来点！！！</strong> </p><hr><p>然后是紧凑的剧情 如果我给《Arcane》剧情总结几个关键词就是：“群像”、“命运”、“成长”。 </p><p>短短九集里，出现了十余个未来将会出现在LOL里的英雄，除此之外还有围绕英雄们的有血有肉的配角。这样一部大型群像剧，不仅要讲好角色的故事，还要讲述“双城”之间的矛盾点和各处矛盾互相联系起来的起承转合。如此紧锣密鼓的剧情编排要求，在二刷完之后，我也为制作组捏了一把汗。 </p><p>所以为什么说剧情的制作牛逼。因为他们真的做到了个体的命运与双城之间矛盾的发展一环扣一环地联系在了一起，事出有因，有因有果。所有人的个人选择都带有着自己理念的支撑，也都造成了对“双城”的影响，并潜移默化地改变了人与城的命运。（从这个角度讲，我觉得《双城之战》这个名字其实蛮贴切）既能着手在大格局，双城的利益矛盾展开，又能体现每一个角色的理念和思想，这就是让人大呼过瘾的缘由。上一次见到这样的剧情，还是国漫一人之下陈朵篇。那种每个人都在做自己认为正确的事，但情况就是反而变差了的宿命感和无力感。</p><p> 而这样一部有着“前传”性质的作品，其缺点也是存在的。就是“上帝视角”和“粉丝向”。引流来的新观众可能不懂皮城与祖安的来源。而只能粗略地了解上城和下城的问题。还有金克丝第三集唐突变疯，认贼作父让很多人摸不着头脑，但是玩过游戏的人已经有了心理预期“她是个疯子”，所以就会觉得很合理。这也是第三集会引起大家广泛讨论的一个原因。</p><hr><p> 最后，我想从一个英雄联盟宇宙的爱好者的角度讲讲为什么我这么喜欢《Arcane》 </p><p>英雄联盟背景故事经历过总体三个阶段，第一阶段是10年到14年的初始时期，大家点开英雄介绍，无非是几百字的经历，最后因为种种原因“来到了战争学院”。合理，但非常浅薄。第二阶段是14年到17年部分地区开始重塑，战争学院转为废设，大地图和宇宙开始形成，每个地区都有了自己的特色。第三阶段在18年到现在，是城邦正式开始“互动”，如诺克萨斯和德玛西亚交战的《第一盾阵》这样优秀的作品</p><p>皮城和祖安的故事从上次世界观大规模重塑后（即第二阶段，2016年）再没有动过。而其他地区，如弗雷尔卓德、德玛西亚等地区的细节却在近几年不断更迭完善。甚至弗雷尔卓德在几年里吃书两次，从三姐妹的传奇再转为北欧风格的神话风格。而皮城和祖安却从未修改。如果你现在看女警的背景故事，会发现女警当前的背景故事依然是平凡家庭的父母突然死亡才走上警察道路（英雄联盟经典父母双亡），显然这段故事和Arcane是完全不同的。凯特琳的家庭不仅和睦，而且还是议员，是实打实的权贵阶层。 </p><p><img src="https://z3.ax1x.com/2021/11/21/Ivkdte.png" alt="img"> </p><p>去年最让宇宙爱好者感到难过的是，甚至连Seraphine这种为了皮肤才有的新英雄也被强制安插在皮城（当然拳头今年又搞了让人直呼“rnm，退钱”的弗耶戈破败大事件，又对联盟世界观的口碑冲击一次。) </p><p>不过，即使是破败大事件也没有皮城和祖安的事。这双城的背景故事长期停留在第二阶段没有更新，留出快有五六年的故事空白，应该也是在铺垫《Arcane》，再从《Arcane》的世界线出发，启动重塑皮城和祖安的世界观。 </p><p>《Arcane》在联盟世界观饱受冲击的阴霾中开播，并取得了热烈的反响。我愿称之为LOL宇宙世界观的一个大转折。 </p><p>其实对于一个游戏来说，世界观 / 文化继续做下去是一件很难的事情，因为它并不带来直接收益。据悉，今年评价颇低的破败大事件也是由营收最高的皮肤团队操刀，专门做剧情的世界观团队并未参与其中。 </p><p>而对于玩家而言，对游戏世界观的感情也是很复杂的， 一方面我知道它作为一个网游，绝不可能有背景故事完结的一天，因此只有分片段的小故事。因为游戏的停服一定早于故事的结局。游戏都没了，你还怎么继续写故事呢？参考运营很多年的游戏，如DNF等，都出现了不同程度的吃书情况，因为一切都要为运营服务。 </p><p>所以为什么说《Arcane》带给我们的是惊喜，<strong>因为拳头有能力讲好一个故事，有信心运营LOL这个IP，更有用时间、用精力打磨的毅力。</strong></p><p>LOL已经有十年了，十年里，有大量玩家已经不打开排位赛，成为了“云，但又不完全云玩家”。他们或是在看LPL，或者转去玩LOL手游，还有关注着英雄联盟世界观的朋友们。而他们都在等待着类似《Arcane》的“前传”影视剧 / 大电影。这是一个非常棒的载体，能让我们看到他们的传奇是如何开始，和他们的命运是如何转折，我们所在的符文大陆到底长什么样子。</p><p> LOL的故事一定可以继续下去，因为它承载的是玩家质朴的热爱</p>]]></content>
    
    
    
    <tags>
      
      <tag>胡说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记账这件小事</title>
    <link href="/2021/10/09/%E8%AE%B0%E8%B4%A6%E8%BF%99%E4%BB%B6%E5%B0%8F%E4%BA%8B/"/>
    <url>/2021/10/09/%E8%AE%B0%E8%B4%A6%E8%BF%99%E4%BB%B6%E5%B0%8F%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="储蓄"><a href="#储蓄" class="headerlink" title="储蓄"></a>储蓄</h2><p>“储蓄”的概念在我脑海里什么时候建立的已不可考。不过我总记得小时候，那个还在用纸币和硬币的时代，我有一个装满硬币的“小金猪”。它是每次跟妈妈买完菜剩的五角一角的归宿。半径更大的一元钱不多，我每拿到都格外珍惜。过年的时候拿出几个最新年份、最干净的金色五毛硬币或是银色一元硬币，在水龙头下洗上一洗，让姑姑包在年夜饭的饺子里。除此之外，不会打开这个储蓄罐。</p><p>高三的时候，正好是移动支付的浪潮冲向小县城的时代。我清楚地记得仅仅是半年的时间，校门口的小吃店老板就把鼓鼓囊囊的零钱小腰包换成了蓝绿色收款二维码。花钞票和扫码支付虽然都是消费，但感受是绝对不同的（这是高三毕业后频繁请同学吃饭发现的，肉疼）</p><p>所以，一是长久养成的节俭和储蓄习惯，二是警惕移动支付带来无节制消费，三是智能手机有记账APP辅助。出于以上朴素的想法，上大学后我决心要养成记账习惯。</p><h2 id="记账"><a href="#记账" class="headerlink" title="记账"></a>记账</h2><p>记账三年了，我一直在用的APP是“鲨鱼记账Pro”，选它的理由是：简洁、有账目分类、没广告。每次在扫码支付之后，我会打开app记这么一笔，数额精确到小数点后两位。现在想来，与其说是记账的习惯，不如说是消费后的强迫症。</p><p>“消费”的动作是每天都执行的，一日三餐和公交是记得最频繁的 ，这个APP每次打开都能看到本月的记账总额。它的作用就是：如果我看到数额比较大，就会暗示自己要节省，不要消费太多，数额较小就可能禁不住诱惑“再买点”。大多数人的大学都要依靠父母，虽然18岁名义上是“成人”，但找他们要生活费是令人羞赧的，消费要尽量克制在预算之内，结余的部分就留给自己喜欢的衣服鞋子或是请客吃饭。</p><p>其实记账看起来简单且机械，但也有很多细节和值得思考的地方。比如有一个很经典的问题：记账是记录每次往饭卡充值的100/50元，还是吃一顿饭记录这次划走的钱？看起来这个问题是“总体的，批量的”与“分散式的，单笔的”之间的对决，不过如果往深去思考，如果将饭卡认为是自己的另一个“账户”，那么单笔消费就是消耗掉了转移到饭卡里的资产；如果将充值饭卡认为是一次“消费”，就是从宏观上对资产的消耗。其实这个思维模型更正确一些，因为充值是单向的，饭卡里的钱不能转回现金。</p><p>除此之外，我还发现记账中各种各样的问题：</p><ul><li>零碎钱记不住或懒得记。比如两块钱的地铁，常常因为着急赶路而不记</li><li>自动扣费无法察觉，Apple Music / 爱奇艺的VIP续费每个月被扣，常常想不起来</li><li>退款怎么算？淘宝退货的退款 / 预定车票退款，算上寄送的快递就有好几笔要记</li><li>负债怎么算？花呗和信用卡的消费计入本月还是下月？</li><li>红包怎么算？小面额高频变动，实在无法记账。</li><li>…</li></ul><p>不过这三年来，身份的转换是非常快的。去年我早早地跑到北京实习，拿到了还算可以的工资。每个月“收入”这一项终于不再是零，而有了急剧膨胀的收入之后，记账这件事情也需重新审视。</p><h2 id="rethink"><a href="#rethink" class="headerlink" title="rethink"></a>rethink</h2><p>最明显的感觉是消费观念的变化。</p><p>读书时的日常开销和在大城市中心区的开销不能一概而论，更何况是北京。剧变的环境，当你的吃喝住行都“不得不”更贵时，消费理念是会被打破的。这里没有五毛钱一根的老冰棍，只有十多块钱的“钟薛高”和盒装冰淇淋，我时常怀念二三十块量大管饱的东北菜，因为北京人均100+才能吃到一个像样的馆子。</p><p>我的记账行为逐渐变得流于形式。以往的储蓄和记账是为了节省家里的开支，在工作后被迫维持极高的消费水平，虽然是目前工资可以维持，甚至还盈余的，但每次看到开支数额，却再也没有强烈的想要节省的，那种发自内心的想法了。</p><p>以前记账是因为朴素的节省情感和没有正式收入的窘迫。现在记账是为了什么呢？或者换个说法：<strong>记录了，但记录的价值在哪里？</strong></p><p>提醒自己节制消费吗？那最好的方法是逃离一线城市，到低消费的城市工作才是正道。</p><p>提醒自己攒钱吗？很喜欢家乡人说的一句话：”挣多少是多啊？“攒钱是为了什么呢？家里尚且稳定，自己除了衣食住行外也并无别的需求。更何况，攒”老婆本“也绝不是靠实习的死工资就能攒下来的。</p><p>所以我换成工作的思维，”记账“本身代表着的只是手动的数据收集。数据有了，但数据的衍生价值却还没被挖掘发现。而以上数据的特征是种类，数额，时间，频率等。</p><p>这样一想，整个问题就豁然开朗了。如果是工作，那么记账这件事情，需要做的是两件：</p><ol><li><strong>自动化工具辅助数据收集，多快好省地进行记账</strong></li><li><strong>使用图表等工具挖掘信息的潜在价值，给予消费、投资策略的指导和优化</strong></li></ol><p>第一点，要做的事情是保证账目的准确性、维度丰富性和效率，比如利用微信、支付宝、银行APP的”源头“能力辅助记账；第二点，要做的事情是从发现趋势、结合生活实际，调整消费投资策略，减少低效益的消费（比如办了健身卡一次不去，买了滑板一次没滑）</p><p>消费是个体面临的一个复杂问题，如果深入剖析，应还有大量心理、投资、博弈等方面的知识需要，作为初出茅庐的生瓜蛋子，实在是把握不住。不过工作带给我的思路却很有价值：收集数据 -&gt; 挖掘数据 -&gt; 调整策略，做出反馈。这应是颠扑不破的方法论了。</p><p>而这一阵反思，也有对工作的帮助：常要扪心自问”你做了事情，但事情的收益在哪？“</p><p>或许是一个在这个信息爆炸，选择极度过剩的时代里，需要三思的问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>胡说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【译】使用RAIL模型衡量性能</title>
    <link href="/2021/08/29/%E3%80%90%E8%AF%91%E3%80%91%E4%BD%BF%E7%94%A8RAIL%E6%A8%A1%E5%9E%8B%E8%A1%A1%E9%87%8F%E6%80%A7%E8%83%BD/"/>
    <url>/2021/08/29/%E3%80%90%E8%AF%91%E3%80%91%E4%BD%BF%E7%94%A8RAIL%E6%A8%A1%E5%9E%8B%E8%A1%A1%E9%87%8F%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://web.dev/rail/">https://web.dev/rail/</a></p><p>RAIL是一种用户中心的性能的模型，它提供了一种衡量性能的结构。RAIL模型把用户体验分解为关键操作（例如点击、滚动、加载）并能帮助开发者对每个操作定义性能指标</p><p>RAIL代表Web App生命周期的四个不同方面：响应、动画、空闲、加载</p><p><a href="https://z3.ax1x.com/2021/08/29/h8PNMn.png"><img src="https://z3.ax1x.com/2021/08/29/h8PNMn.png" alt="h8PNMn.png"></a></p><h2 id="关注用户"><a href="#关注用户" class="headerlink" title="关注用户"></a>关注用户</h2><p>将性能提升的重点放在用户上，下表是用户对不同性能延迟的感受指标：</p><table><thead><tr><th align="left">0 to 16 ms</th><th align="left">用户是非常擅长跟踪动态变化的，而且用户不喜欢不流畅的动画。动画每秒渲染 60 个新帧，用户就会认为很流畅。也就是16ms一帧，排除掉浏览器在屏幕渲染一帧的时间，app还剩大概10ms的时间去生成一帧</th></tr></thead><tbody><tr><td align="left">0 to 100 ms</td><td align="left">在这个时间窗口响应用户操作，用户会感到结果是即时的。如果超出这个时间，用户执行操作和app回应的联系就被打破了</td></tr><tr><td align="left">100 to 1000 ms</td><td align="left">在这个时间窗口中，发生的事情是任务执行过程中自然而然的一部分。对于大多数上网的用户来说，加载页面或改变视图是一个任务。</td></tr><tr><td align="left">1000 ms or more</td><td align="left">超过1s，用户就会丧失当前执行的任务的注意力</td></tr><tr><td align="left">10000 ms or more</td><td align="left">超过10s，，用户会感到沮丧，很可能放弃任务并不再回来</td></tr></tbody></table><p>用户感受性能延迟是不同的，具体取决于网络条件和硬件。例如，功能强大的台式机用快速 Wi-Fi 加载站点通常会在 1 秒内完成，并且用户已经对此习以为常。在 慢速3G 的移动设备上加载站点需要更多时间，所以一般来说移动用户更具耐心，在移动设备上加载 5 秒是比较实际的目标。</p><h2 id="目标和准则"><a href="#目标和准则" class="headerlink" title="目标和准则"></a>目标和准则</h2><p>在 RAIL 的上下文中，术语<strong>目标</strong>和<strong>准则</strong>有以下特定含义：</p><ul><li><p><strong>目标：</strong>与用户体验相关的关键性能指标。例如，点击后100 毫秒内绘制。由于人类的感受是相对不变的，这些目标未来不大可能有变动。</p></li><li><p>准则：</p><p>能帮助实现目标的建议。这些可能受限于当前的硬件和网络连接条件，因此可能会随着时间而改变。</p><h2 id="响应（Response）50ms内处理事件"><a href="#响应（Response）50ms内处理事件" class="headerlink" title="响应（Response）50ms内处理事件"></a>响应（Response）50ms内处理事件</h2></li></ul><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>在 100 毫秒内完成从用户输入到初始化变动发生，让用户感觉交互是即时的。</p><h3 id="准则"><a href="#准则" class="headerlink" title="准则"></a><strong>准则</strong></h3><ul><li><p>为保证100ms内可见响应，需要app在50ms内处理用户输入事件。这个原则适用于大多数输入，比如点击按钮、切换表单控件或开启动画（不适用于触摸拖动或滚动）</p></li><li><p>尽管听起来违反直觉，总是立即响应用户输入并不是一个正确的做法，这100ms的窗口时间可以来做一些更重要的事，但是要注意不要阻塞用户，如果可以的话，可以在后台工作</p></li><li><p>对于需要50ms以上才能完成的动作，需要一直提供反馈</p><h3 id="50-ms-还是-100-ms"><a href="#50-ms-还是-100-ms" class="headerlink" title="50 ms 还是 100 ms?"></a>50 ms 还是 100 ms?</h3></li></ul><p>既然目标是在 100 毫秒内响应输入，为什么我们的预算只有 50 毫秒？这是因为除了处理输入之外，通常还有其他工作要做，并且这些工作占用了可接受响应的一部分时间。如果app在空闲时间内的50 毫秒块中执行工作，这意味着如果输入事件在这些工作块之一期间发生，则它最多可以排队 50 毫秒。考虑到这一点，我们可以假设只有剩余的 50 毫秒可用于实际输入处理是安全的。下图显示了这种效果，该图显示了在空闲任务期间收到的输入如何排队，从而减少了可用的处理时间：</p><p><a href="https://z3.ax1x.com/2021/08/29/h8Pvo8.png"><img src="https://z3.ax1x.com/2021/08/29/h8Pvo8.png" alt="h8Pvo8.png"></a></p><p>空闲任务如何影响输入响应时间预算</p><h2 id="动画（Animation）10ms内生成一帧"><a href="#动画（Animation）10ms内生成一帧" class="headerlink" title="动画（Animation）10ms内生成一帧"></a>动画（Animation）10ms内生成一帧</h2><h3 id="目标："><a href="#目标：" class="headerlink" title="目标："></a><strong>目标：</strong></h3><ul><li><p>在 10 毫秒或更短的时间内生成动画中的每一帧。从技术上讲，每帧的最大预算为 16 毫秒（1000 毫秒/每秒 60 帧≈16 毫秒），但浏览器需要大约 6 毫秒来渲染每帧，因此每帧 10 毫秒的准则。</p></li><li><p>以视觉流畅度为目标。用户会注意到帧率发生变化。</p><h3 id="准则："><a href="#准则：" class="headerlink" title="准则："></a><strong>准则：</strong></h3></li><li><p>在像动画这样的高压点上，关键是在你能做的地方什么都不做，在你不能做的地方绝对最少。只要有可能，就利用 100 毫秒响应预先计算昂贵的工作，以便最大限度地提高达到 60 fps 的机会。</p></li><li><p>有关各种动画优化策略，请参阅<a href="https://developers.google.com/web/fundamentals/performance/rendering">渲染性能</a>。</p></li></ul><p>要认清动画的种类。动画不仅仅是花哨的 UI 效果。这些交互中的每一个都被认为是动画：</p><ul><li><p>视觉动画，例如出入页面、<a href="https://www.webopedia.com/TERM/T/tweening.html">补间动画</a>和加载指示器。</p></li><li><p>滚动。这包括滑动事件，即用户开始滚动，然后放手，页面继续滚动。</p></li><li><p>拖拽。动画通常遵循用户交互，例如拖拽地图或捏合缩放。</p><h2 id="空闲（Idle）最大化空闲时间"><a href="#空闲（Idle）最大化空闲时间" class="headerlink" title="空闲（Idle）最大化空闲时间"></a>空闲（Idle）最大化空闲时间</h2></li></ul><h3 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a><strong>目标</strong></h3><p>最大化空闲时间以增加页面在 50 毫秒内响应用户输入的几率。</p><h3 id="准则-1"><a href="#准则-1" class="headerlink" title="准则"></a><strong>准则</strong></h3><ul><li><p>利用空闲时间完成延期工作。例如，对于页面初加载，要加载尽可能少的数据，然后使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback">空闲时间</a>加载其余的数据。</p></li><li><p>在 50 毫秒或更短的空闲时间内执行工作。如果时间更长，就有干扰应用程序在 50 毫秒内响应用户输入的风险。</p></li><li><p>如果用户在空闲时间与页面交互，则用户交互应始终具有最高优先级并中断空闲时间正在进行的工作。</p><h2 id="加载（Loading）交付内容在5s内可互动"><a href="#加载（Loading）交付内容在5s内可互动" class="headerlink" title="加载（Loading）交付内容在5s内可互动"></a>加载（Loading）交付内容在5s内可互动</h2></li></ul><p>如果页面加载缓慢，用户注意力会转移，或认为任务已失败。加载速度快的网站具有<a href="https://www.thinkwithgoogle.com/intl/en-154/insights-inspiration/research-data/need-mobile-speed-how-mobile-latency-impacts-publisher-revenue/">更长的平均会话时间、更低的跳出率和更高的广告可见度</a>。</p><h3 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a><strong>目标</strong></h3><ul><li>优化与用户的设备和网络能力以快速加载性能。目前，首次加载的一个很好的目标是加载页面并在<a href="https://web.dev/performance-budgets-101/#establish-a-baseline">5 秒或更短的时间内在 3G 连接速度较慢的中端移动设备上</a>进行<a href="https://web.dev/interactive/">交互</a>。</li><li>对于后续加载，在 2 秒内加载页面比较好</li></ul><p><strong>PS: 以上目标可能随时间改变</strong></p><h3 id="准则-2"><a href="#准则-2" class="headerlink" title="准则"></a><strong>准则</strong></h3><ul><li><p>在常见的用户移动设备和网络连接上测试App的负载性能。<a href="https://web.dev/chrome-ux-report/">Chrome 用户体验报告</a>可以帮助了解用户的<a href="https://web.dev/chrome-ux-report-data-studio-dashboard/#using-the-dashboard">连接分布</a>。如果网站的数据不可用，<a href="https://www.gsma.com/mobileeconomy/">GSMA - The mobile ecomomy</a>建议中位线是中端 Android 手机，例如 Moto G4 的慢速 3G 网络（定义为 400 ms RTT 和 400 kbps 传输速度）。此组合在<a href="https://www.webpagetest.org/easy">WebPageTest</a>上<a href="https://www.webpagetest.org/easy">可用</a>。</p></li><li><p>需要记住，尽管大部分有代表性的移动用户设备可能声称它使用的是 2G、3G 或 4G 连接，但实际上，由于数据包丢失和网络差异，<a href="https://web.dev/adaptive-serving-based-on-network-quality/#how-it-works">有效连接速度</a>通常要慢得多。</p></li><li><p><a href="https://web.dev/render-blocking-resources/">消除渲染阻塞资源</a>。</p></li><li><p>不必在 5 秒内加载所有内容才产生完整加载的感觉。考虑<a href="https://web.dev/browser-level-image-lazy-loading/">延迟加载图像</a>、<a href="https://web.dev/reduce-javascript-payloads-with-code-splitting/">代码拆分 JavaScript 包</a>和<a href="https://web.dev/fast/">web.dev 上建议的</a>其他<a href="https://web.dev/fast/">优化</a>。</p><h3 id="影响页面加载性能的因素"><a href="#影响页面加载性能的因素" class="headerlink" title="影响页面加载性能的因素"></a>影响页面加载性能的因素</h3></li><li><p>网络速度和延迟</p></li><li><p>硬件（例如，较慢的 CPU）</p></li><li><p>Cache Eviction</p></li><li><p>L2/L3 缓存的差异</p></li><li><p>JavaScript解析</p><h2 id="衡量RAIL的工具们"><a href="#衡量RAIL的工具们" class="headerlink" title="衡量RAIL的工具们"></a>衡量RAIL的工具们</h2></li></ul><h3 id="有一些工具可以帮助您自动执行-RAIL衡量："><a href="#有一些工具可以帮助您自动执行-RAIL衡量：" class="headerlink" title="有一些工具可以帮助您自动执行 RAIL衡量："></a>有一些工具可以帮助您自动执行 RAIL衡量：</h3><p>Chrome DevTools</p><p><a href="https://developers.google.com/web/tools/chrome-devtools">Chrome DevTools</a>对页面加载或运行时发生的一切进行深入分析。请<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance">参阅开始分析运行时性能</a>来熟悉Performance面板 UI。</p><p>以下是 DevTools 提供的专门功能：</p><ul><li><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#cpu-throttle">限制 CPU</a>以模拟功能较弱的设备。</p></li><li><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#network-throttle">限制网络</a>以模拟较慢的连接。</p></li><li><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#main">查看主线程活动</a>以查看录制时主线程上发生的每个事件。</p></li><li><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#activities">﻿查看表中的主线程活动</a>根据占用时间最多的活动对活动进行排序。</p></li><li><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#fps">分析每秒帧数 (FPS)</a>以衡量您的动画是否真正流畅运行。</p></li><li><p><a href="https://developers.google.com/web/updates/2017/11/devtools-release-notes#perf-monitor">使用</a>Performance Monitor实时<a href="https://developers.google.com/web/updates/2017/11/devtools-release-notes#perf-monitor">监控 CPU 使用率、JS 堆栈大小、DOM 节点、每秒布局等</a></p></li><li><p>使用网络部分<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#network">可视化</a>录制时发生的<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#network">网络请求</a>。</p></li><li><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#screenshots">在录制时捕获屏幕截图</a>以准确回放页面加载时页面的外观，或动画触发等。</p></li><li><p><a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#interactions">查看交互</a>以快速识别用户与其交互后页面上发生的情况。</p></li><li><p>通过在潜在问题侦听器触发时突出显示页面<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference#scrolling-performance-issues">来实时查找滚动性能问题</a>。</p></li><li><p>实时查看绘制事件</p><p>以识别可能损害动画性能的代价高昂的绘制事件。</p><h3 id="Lighthouse"><a href="#Lighthouse" class="headerlink" title="Lighthouse"></a>Lighthouse</h3></li></ul><p><a href="https://developers.google.com/web/tools/lighthouse">Lighthouse</a>可在 Chrome DevTools、<a href="https://web.dev/measure/">web.dev/measure</a>、Chrome 扩展、Node.js 模块和 WebPageTest 中使用。它获取一个 URL，然后模拟一个 3G 连接速度较慢的中端设备，在页面上运行一系列检查，然后给你一份关于负载性能的报告，以及如何改进的建议。</p><p>以下检查需要特别关注：</p><h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><ul><li><p><a href="https://web.dev/lighthouse-max-potential-fid/">Max Potential First Input Delay (FID) </a>根据主线程空闲时间估计您的应用响应用户输入所需的时间。</p></li><li><p><a href="https://web.dev/uses-passive-event-listeners/">没有用被动listener来提高滚动性能</a>。</p></li><li><p><a href="https://web.dev/lighthouse-total-blocking-time/">总阻塞时间</a>。测量页面被阻止响应用户输入（例如鼠标点击、屏幕点击或按下键盘）的总时间。</p></li><li><p><a href="https://developers.google.com/web/tools/lighthouse/audits/consistently-interactive">TTI</a>，衡量用户何时可以始终如一地与所有页面元素进行交互。</p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4></li><li><p><a href="https://web.dev/service-worker/">未注册service workerk控制页面</a>。Service Worker 可以缓存用户设备上的公共资源，从而减少通过网络获取资源所花费的时间。</p></li><li><p><a href="https://web.dev/load-fast-enough-for-pwa/">移动网络上的页面加载速度不够快</a>。</p></li><li><p><a href="https://developers.google.com/web/tools/lighthouse/audits/blocking-resources">消除渲染阻塞资源</a>。</p></li><li><p><a href="https://web.dev/offscreen-images/">推迟屏幕外图像</a>。推迟加载屏幕外图像，直到需要它们。</p></li><li><p><a href="https://web.dev/uses-responsive-images/">适当大小的图像</a>。不要提供明显大于移动视口中呈现的尺寸的图像。</p></li><li><p><a href="https://web.dev/critical-request-chains/">避免链式关键请求</a>。</p></li><li><p><a href="https://web.dev/uses-http2/">不为所有资源使用 HTTP/2</a>。</p></li><li><p><a href="https://web.dev/uses-optimized-images/">高效图片编码</a>。</p></li><li><p><a href="https://web.dev/uses-text-compression/">启用文本压缩</a>。</p></li><li><p><a href="https://web.dev/total-byte-weight/">避免巨大的网络负载</a>。</p></li><li><p><a href="https://web.dev/dom-size/">避免过大的 DOM </a>。通过仅传送呈现页面所需的 DOM 节点来减少网络字节。</p><h3 id="WebPageTest"><a href="#WebPageTest" class="headerlink" title="WebPageTest"></a>WebPageTest</h3></li></ul><p>WebPageTest 是一个 Web 性能工具，它使用真实的浏览器来访问网页并收集计时指标。在<a href="https://webpagetest.org/easy">webpagetest.org/easy</a>上输入一个URL，可以获取页面在慢速3G连接的真实Moto G4 设备上的负载性能的详细报告。它可以将其配置包含 Lighthouse审计报告。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户体验可以看成是一连串交互组成的，RAIL是一个用于了解这个旅程的透镜。它能了解用户是如何感受网站的，以便开发者设定对用户体验影响最大的性能目标。</p><ul><li>以用户为中心。</li><li>在 100 毫秒内响应用户输入。</li><li>动画或滚动时，在 10 毫秒内生成一帧。</li><li>最大化主线程空闲时间。</li><li>在 5000 毫秒内加载交互式内容。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDIA学习笔记</title>
    <link href="/2021/06/09/DDIA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/06/09/DDIA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="DDIA-第一章节"><a href="#DDIA-第一章节" class="headerlink" title="DDIA 第一章节"></a>DDIA 第一章节</h1><ul><li>可靠性：硬件故障、软件故障、人为错误）中仍可正常工作并能达到性能水准（可以说是把鲁棒性和性能结合在一起？）</li><li>可扩展性 合理的方法应对系统数据、流量、复杂性的增长（熵增的过程）</li><li>可维护性 不同生命周期 不同工种可以高效协作 保持现有功能并能增加新的场景</li></ul><h2 id="可靠性（Reliability）"><a href="#可靠性（Reliability）" class="headerlink" title="可靠性（Reliability）"></a>可靠性（Reliability）</h2><h3 id="故障（fault）和失效-failure-的区别"><a href="#故障（fault）和失效-failure-的区别" class="headerlink" title="故障（fault）和失效(failure) 的区别"></a>故障（fault）和失效(failure) 的区别</h3><p><strong>故障</strong>通常定义为系统的一部分状态偏离其标准，而<strong>失效</strong>则是系统作为一个整体停止向用户提供服务。故障的概率不可能降到零，因此最好设计容错机制以防因<strong>故障</strong>而导致<strong>失效</strong></p><h3 id="硬件故障（底层）"><a href="#硬件故障（底层）" class="headerlink" title="硬件故障（底层）"></a>硬件故障（底层）</h3><p>硬盘的<strong>平均无故障时间（MTTF mean time to failure）</strong>约为10到50年。因此从数学期望上讲，在拥有10000个磁盘的存储集群上，平均每天会有1个磁盘出故障。解决硬件故障的方法通常都是增加单个硬件的冗余度</p><h3 id="软件故障（服务、功能设计）"><a href="#软件故障（服务、功能设计）" class="headerlink" title="软件故障（服务、功能设计）"></a>软件故障（服务、功能设计）</h3><p>接受特定的错误输入，响应变慢等等 软件bug存在时间较长，不容易被发现，通过测试、监控自检可以减少软件故障</p><h3 id="人为故障（使用和维护）"><a href="#人为故障（使用和维护）" class="headerlink" title="人为故障（使用和维护）"></a>人为故障（使用和维护）</h3><p>设计并构建了软件系统的工程师是人类，维持系统运行的运维也是人类。即使他们怀有最大的善意，人类也是不可靠的。从最开始的设计到最后的培训可以减少此类故障的发生</p><h2 id="可扩展性（Scalability）"><a href="#可扩展性（Scalability）" class="headerlink" title="可扩展性（Scalability）"></a>可扩展性（Scalability）</h2><p>是用来描述系统应对负载增长能力的术语。</p><p>讨论可扩展性意味着考虑诸如“如果系统以特定方式增长，有什么选项可以应对增长？”和“如何增加计算资源来处理额外的负载？”等问题。</p><p>而“负载参数”是用来描述当前系统负载的，比如每秒请求数 数据库读写比率，缓存命中率等等</p><h3 id="e-g-Twitter发推"><a href="#e-g-Twitter发推" class="headerlink" title="e.g. : Twitter发推"></a>e.g. : Twitter发推</h3><h4 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h4><p>用户打开自己的主页timeline，显示他关注的人的全部推文（系统总请求300k/s）</p><p>如果只是发推（峰值12k次/s）写入，扩展性是没问题的，但主要挑战来自每个用户关注了很多人，也被很多人关注</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ol><li>发推时，将新推文插入全局推文数据库集合，用户查看timeline时，查他关注的所有人，查找他们的推文并按照时间顺序合并推送</li></ol><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> tweets.*, users.*<br><span class="hljs-keyword">FROM</span> tweets<br><span class="hljs-keyword">JOIN</span> users <span class="hljs-keyword">ON</span> tweets.sender_id = users.id<br><span class="hljs-keyword">JOIN</span> follows <span class="hljs-keyword">ON</span> follows.followee_id = users.id<br><span class="hljs-keyword">WHERE</span> follows.follower_id = current_userCopy<br></code></pre></td></tr></table></figure><ol><li>为每一个用户的时间线维持一个缓存（消息队列？）每当一个用户发布推文，查找所有关注他的人，并将推文插入到每个主页时间线缓存里。这样会让读取timeline的开销变小</li></ol><h4 id="结果-amp-后续优化"><a href="#结果-amp-后续优化" class="headerlink" title="结果 &amp; 后续优化"></a>结果 &amp; 后续优化</h4><p>发推频率是比查询timeline少了两个数量级的，所以在写入的时候多做一些工作，在读取时做一些少的工作会好一些，因此方法2更优。</p><p>不过如果一个用户有3000万人关注，就要写入3000万次，所以还要加入用户粉丝数的分布（或发推频率）进行更复杂的加权来进行优化负载。推特最终选择了两种方法的结合，大多数用户的推文会被写入缓存，读取timeline时查网红的推文库进行时间线合并</p><h3 id="性能指标（e-g-：响应时间）"><a href="#性能指标（e-g-：响应时间）" class="headerlink" title="性能指标（e.g.：响应时间）"></a>性能指标（e.g.：响应时间）</h3><ol><li>算术平均值</li><li>百分位点（中位数）<ul><li>中位数（p50）一半用户时间比这个长 一半比这个短</li><li>高百分位点（p99、p95） 关注异常值 ， 也叫尾部延迟</li></ul></li></ol><p>并行n个请求里是存在木桶短板效应的，也是高百分位点指标关注的点</p><h3 id="应对负载"><a href="#应对负载" class="headerlink" title="应对负载"></a>应对负载</h3><p>如何保持负载增加时，保持良好的性能？</p><ol><li>纵向 / 垂直扩展：转向更强大的机器（开源）</li><li>横向 / 水平 扩展：分散到小机器上（节流）</li></ol><p>跨多台机器的无状态服务很简单，但是带状态的数据系统从单节点变为分布式会多出很多复杂度</p><p>没有万金油的可扩展架构，应用的问题可能是响应时间、读取量、写入量、存储的数据量、访问模式等等问题，每秒处理10w个大小为1kb的请求和每秒处理3个2gb的请求完全不一样</p><h2 id="可维护性（Maintainability）"><a href="#可维护性（Maintainability）" class="headerlink" title="可维护性（Maintainability）"></a>可维护性（Maintainability）</h2><p>软件工程告诉我们，维护成本是软件成本占大头的，而高可维护性只能在设计之初考虑好。</p><h3 id="可操作性"><a href="#可操作性" class="headerlink" title="可操作性"></a>可操作性</h3><p>方便运维团队平稳运行，合理的自动化机制</p><ul><li>运行状况监控</li><li>追踪问题 可溯源 可复现</li><li>扩展、配置、补丁、迁移自动化工具</li><li>规范化的工作流程</li><li>容灾 压测 兜底</li></ul><h3 id="简单性"><a href="#简单性" class="headerlink" title="简单性"></a>简单性</h3><p>尽可能减少复杂度和理解成本（总体上看还是要靠共识 或者 约定）</p><p>复杂度：模块之间的耦合、依赖关系、不合规的命名、解决问题的Hack扽等</p><h3 id="可演化性"><a href="#可演化性" class="headerlink" title="可演化性"></a>可演化性</h3><p>方便更改（留出足够的抽象和可扩展能力做适配）</p><p>比如测试驱动开发 重构 敏捷等概念</p><p>人生苦短啊</p><h1 id="DDIA-第二章节-数据模型与查询语言"><a href="#DDIA-第二章节-数据模型与查询语言" class="headerlink" title="DDIA 第二章节 数据模型与查询语言"></a>DDIA 第二章节 数据模型与查询语言</h1><p>数据模型也是一种技术选型，对上层软件功能有着重要的影响。</p><h2 id="关系模型与文档模型"><a href="#关系模型与文档模型" class="headerlink" title="关系模型与文档模型"></a>关系模型与文档模型</h2><p>SQL：数据被处理成关系（SQL中的表），每一个关系是元组（SQL中的行）的无序集合。关系数据库大量用于商务数据处理，典型的数据处理和批处理。</p><p>NoSQL的驱动力有：</p><ul><li>更好的可扩展性 非常大大的数据集 很高的吞吐量</li><li>灵活的 动态的数据模型和特殊的查询</li><li>开源 &amp; 免费浪潮</li></ul><p>由于大多数程序是面向对象的，所以数据存储在关系表中会和SQL数据模型之间有一层转换层，模型的不连贯是SQL广受批评的原因</p><h3 id="e-g-Linkin简历"><a href="#e-g-Linkin简历" class="headerlink" title="e.g. : Linkin简历"></a>e.g. : Linkin简历</h3><p><code>first_name</code>和<code>last_name</code>这种信息每个用户只出现一次，适合放在User表的列里，但是对于工作，大多数人的职业生涯不止一份，所以一到一对多的关系，常见的做法通常是再分出一个表来存储。</p><p>但是如果用json来做，将职业信息放进数组里就会灵活很多，有着更强的<strong>局部性</strong>（不用反复查库）从数据结构的角度来看，json是比较适合这种一对多的树结构</p><p>而对于多对一的场景，如国家/地区，一般采取的是用一个ID而不是纯字符串来表示，也是数据库“规范化”的思想。</p><blockquote><p>如果重复存储了可以存储在一个地方的值，那么就不是规范化的</p></blockquote><p>如果数据库不支持连接，那么在这种场景下会多查一次来模拟出连接（不过类似于国家/地区这种不变数据，要么在缓存里要么在内存中，开销一般不大）</p><p>如果有一个新的功能，“学校”或者“公司”不只是一个字符串，而是一个实体，那么它也有自己的“简历”，那么一对多的关系就会变成多对多的关系。而在多对多的关系上，文档数据库就会疲软（上世纪70年代的层次模型数据库也遇到了相同的难题，而解决这个问题的两个答案分别是关系模型和网络模型）</p><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>实现并商用的CODASYL模型：</p><p>层次模型的树结构里每条记录只有一个父节点，网络模型中可以有多个父节点，这样多对一和多对多的关系建模比较灵活。网络模型中记录之间的链接不是外键，而是类似于指针，访问记录的唯一方法是沿着根记录的链路路径（也叫访问路径）类似遍历链表。</p><p>在多对多的关系中，不同路径可以达到相同的路径，查询是通过遍历记录列和跟随访问路径表在数据库中移动游标执行的，如果记录有多个父节点，则应用程序要跟进所有的关系，非常不灵活</p><h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>相比之下，关系型数据库的所有数据都清晰可见，关系表和行的集合，不会有嵌套结构，不会有复杂的访问路径。查询优化器自动决定查询的那个部分以哪个顺序执行以及使用哪些索引，这些选择实际上是”访问路径“，但因为是自动生成的，不需要使用者考虑这些。</p><p>关系型数据库的查询优化器是很复杂的，但是只需要构建一次查询优化器，随后使用该数据库的所有程序都可以从中受益。为特定查询添加索引的成本也比重构查询优化器低一些</p><h3 id="文档模型"><a href="#文档模型" class="headerlink" title="文档模型"></a>文档模型</h3><p>文档模型中，一对多和多对多关系里，相关项目都被一个唯一标识符引用，在关系型数据库里叫外键，在文档模型中交文档引用。</p><h3 id="关系和文档相比"><a href="#关系和文档相比" class="headerlink" title="关系和文档相比"></a>关系和文档相比</h3><p><del>那我感觉还是我们文档牛皮</del>文档数据库因为局部性和灵活性，对某些应用程序更接近于程序使用的数据结构，关系型数据库为连接提供了良好的支持，处理多对一和多对多的关系占据优势</p><h2 id="数据查询语言"><a href="#数据查询语言" class="headerlink" title="数据查询语言"></a>数据查询语言</h2><p>SQL采取了声明式写法，比命令式隐藏了更多底层细节，适合并行执行，提供有限的功能性，为数据库提供了更多自动优化的空间。</p><p>Cypher是属性图的声明式查询语言，为Neo4j图形数据库发明，和CODASYL类似的，查询语句可能存在多个查询路径，但是不需要指定细节，查询优化程序会自动选择预测效率最高的策略</p><h3 id="三元组存储和SPARQL"><a href="#三元组存储和SPARQL" class="headerlink" title="三元组存储和SPARQL"></a>三元组存储和SPARQL</h3><p>三元组存储模式大体和属性图模式相同，三元组存储中，所有信息以三部分形式存储（主语宾语谓语）三元组的主语相当于一个顶点，宾语是下面两者之一：</p><ul><li>另一个顶点，谓语是图中的一条边，主语是其尾部顶点，宾语是其头部顶点</li><li>原始类型的值（如字符串或数字），谓语和宾语相当于主语上的key和value</li></ul><h3 id="语义网络"><a href="#语义网络" class="headerlink" title="语义网络"></a>语义网络</h3><p>网站将信息发布为文字和图片给人类阅读，那么将信息反过来当作所有机器可读的数据，资源描述框架（RDF）目的是将不同网红赞以一致的格式发布数据的机制，将不同网站的数据自动合并成一个数据网络（最终失败惹）</p><h3 id="图形和网络相比"><a href="#图形和网络相比" class="headerlink" title="图形和网络相比"></a>图形和网络相比</h3><p>CODASYL网络模型和目前的图模型很相似，但也有很大程度的不同</p><ol><li>CODASYL里，数据库存在模式，指定那种记录类型可以嵌套在其他记录类型中，图形数据库不存在类似限制</li><li>CODASYL里，只能通过访问路径来达到特定记录，图形数据库可以用唯一ID来直接引用任何顶点，也可以用索引查找</li><li>CODASYL里，记录的后续是一个有序集合，所以要手动维护排序，图形数据库里顶点和边不是有序的，只有在查询时排序</li><li>CODASYL里，所有查询是命令式的，图形数据库可以用用Cypher/SPARQL查询，也支持命令式代码</li></ol><h3 id="Datalog"><a href="#Datalog" class="headerlink" title="Datalog"></a>Datalog</h3><p>Datalog很古老，主要在上世纪80年代研究，但它为以后的查询语言提供了基础</p><p>Datalog的数据模型也类似三元组形式，将三元组写成**谓语(主语，宾语)**的形式</p><p>Datalog通过反复执行一小步和递归调用自己的方式来做查询，是用于简单一次性，不适合复杂数据的情况</p><h1 id="DDIA-第三章节-存储和检索"><a href="#DDIA-第三章节-存储和检索" class="headerlink" title="DDIA 第三章节 存储和检索"></a>DDIA 第三章节 存储和检索</h1><p>数据库在最基础的层次上要做两件事情：存取</p><p>数据模型和查询语言规定了程序员录入和查询数据库的格式，那么站在数据库的角度，我们要思考如何存储和重新查找</p><p>从程序员的角度看，大多数时候我们不用关心数据库内部存储和检索的机理，但是当我们需要做存储选型，为了协调工作负载，也需要大致了解存储引擎在底层做什么。</p><p>主要分两类：日志结构的存储引擎和面向页面的存储引擎</p><h2 id="驱动数据库的数据结构"><a href="#驱动数据库的数据结构" class="headerlink" title="驱动数据库的数据结构"></a>驱动数据库的数据结构</h2><p>两个bash函数就可以写出一个简单的数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-function"><span class="hljs-title">db_set</span></span>() &#123;<br><span class="hljs-built_in">echo</span><span class="hljs-string">&quot;<span class="hljs-variable">$1</span>,<span class="hljs-variable">$2</span>&quot;</span> &gt;&gt; database<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">db_get</span></span>() &#123;<br>grep <span class="hljs-string">&quot;^<span class="hljs-variable">$1</span>,&quot;</span> database | sed -e <span class="hljs-string">&quot;s/^<span class="hljs-variable">$1</span>,//&quot;</span> | tail -n 1<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>按照key value的形式存取 每次调用<code>db_set</code>都会在文件末尾追加一条，在更新键时旧版本值不会被覆盖，在查找最新值的时候都是键最后出现的位置（tail -n 1的含义）</p><p><code>db_set</code>在一些简单场景会有比较好的性能，文件尾部追加写入是很高效，和这种做法类似的是，数据库内部使用<strong>日志（Log）</strong>来作为<strong>仅追加</strong>数据文件</p><p>但是相对应的，一旦数据比较多<code>db_get</code>的性能就会很糟糕，每次查找它都要从头查到尾寻找键，如果数据量翻一番，查找时间也要翻一倍</p><p>为了提升查找效率，我们有了新的数据结构：<strong>索引</strong>，索引保存一些额外的元数据作为路标，帮助查找想要的数据。索引是附加的数据结构，不会影响数据本身，只影响查询的性能。维护额外的结构会产生开销，写入时索引会拖慢速度。</p><p>存储系统的重要权衡：索引，每建立一个索引就会拖慢写入速度，需要程序员或DBA对应用的查询模式选择合适的索引</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>key value的索引是常见的索引形式，hash map实现散列表映射。将键映射到内存数据文件中的字节偏移量，指明了对应值的位置。写入文件同时要更新散列映射。查找时通过查找映射中的偏移量再读内存里该位置的值</p><p>Riak默认的存储引擎Bitcask就是这样做的，将所有键保存在可用内存中，值保存在磁盘或者cache中 这样非常适合每个键的值经常更新的场景。</p><p>如何避免追加写入一个文件最后用完磁盘空间？一个方法是将日志分为特定大小的段，当日志增长到特定尺寸就关闭当前段文件，开始写入一个新的段文件，然后对这些段进行压缩，只保留每个键的最近更新。多个段合并后，旧的段文件可以删除。</p><p>每个段有自己的内存散列表，找一个键的值可以先查最近的段，再找第二近的段，以此类推</p><h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h3><ol><li>文件格式</li></ol><p>CSV不一定最适合，二进制更快一些，需要重新编码</p><ol><li>删除记录</li></ol><p>删除一个键和相关值必须要附加一个特殊的删除记录，在合并时删除键之前的所有值</p><ol><li>崩溃恢复</li></ol><p>数据库重启则内存散列映射将会丢失，可以通过保存快照来进行加速恢复</p><ol><li>并发控制</li></ol><p>写操作是以严格顺序附加到日志的，实现方案基本为只有一个写入器线程，读取器线程可以有很多个，存在脏读</p><p>采取追加日志而不是更新文件用新值覆盖旧值是有原因的</p><ul><li>追加和分段合并是顺序写入操作，比随机写入快</li><li>段文件是附加或不可变的可以方便并发和崩溃恢复</li><li>合并旧段可以避免数据文件分散问题</li></ul><p>哈希表存储的局限性：</p><ol><li>散列表必须放进内存</li><li>范围查询效率低</li></ol><h2 id="SSTables-和-LSM树"><a href="#SSTables-和-LSM树" class="headerlink" title="SSTables 和 LSM树"></a>SSTables 和 LSM树</h2><h3 id="SSTables"><a href="#SSTables" class="headerlink" title="SSTables"></a>SSTables</h3><p>如果对键值对进行按键的序列写入，叫做SSTable（Sorted String Table）且规定每个键在每个合并的段文件里只出现一次</p><p>和散列索引日志段相比，似乎破坏了顺序写入的能力，但是合并段可以保证合并段的不重复和保证最新，且不需要保留索引，按照排序特性来查找。节省磁盘空间和IO带宽</p><p>在磁盘上维护有序结构是有可能的（B树） 但在内存里比较简单，红黑树和AVL树都可以按任何顺序插入键并按顺序读取。</p><p>新的引擎这样工作：</p><ol><li>写入时添加到内存里的平衡树结构，如红黑树（内存表）</li><li>内存表大于某个阈值。将其作为SSTable写进磁盘，写入磁盘时，写入可以开一个新的内存表</li><li>遇到读取请求，首先在内存表里查找key，然后在最近的磁盘段里，再在更旧的磁盘段里找</li><li>后台运行和压缩覆盖/删除旧值</li></ol><p>问题：</p><p>数据库崩溃则最近一次写入（内存）未保存在磁盘而丢失，所以可以在磁盘冗余一份日志，便于恢复</p><h3 id="用SSTables-制作-LSM树"><a href="#用SSTables-制作-LSM树" class="headerlink" title="用SSTables 制作 LSM树"></a>用SSTables 制作 LSM树</h3><p>LevelDB RocksDB使用的关键值存储数据库的算法在日志结构合并树（或LSM树）的基础上的日志结构文件系统，基于这种合并和压缩排序文件原理的存储引擎叫做LSM存储引擎</p><p>性能上的优化主要SSTables在压缩合并上的顺序和时间，方案有大小分层压实等等，LSM树的理念：<strong>保存一系列在后台合并的SSTables</strong>是简单有效的，按顺序存储可以保证高效执行范围查询，磁盘写入是连续的，所以也支持很高的吞吐量</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>使用最广泛的索引结构是B树，几乎存在于所有关系型数据库和一些NoSQL中</p><p>B树同样保持按键值排序，允许搞笑键值查找和范围查询，但是很多地方也和SSTables有不同</p><p>B树将数据库分解为固定大小的块和页面（更接近底层硬件）每个页面使用地址标识写入是符合直觉的，但是更新要分空间能否容纳新键，不能还要更新父页面来解释新分区（为了B树平衡）</p><p>B树底层是用新数据覆盖旧数据，而不是附加到文件，因此在硬件上SSD反复擦除写入，磁盘也要等待磁头移动。为了保证写入时放崩溃。还要冗余一个预写日志，方便崩溃后恢复</p><h3 id="B树和LSM树相比"><a href="#B树和LSM树相比" class="headerlink" title="B树和LSM树相比"></a>B树和LSM树相比</h3><p>经验表明，LSM树的写入速度更快，B树读取速度更快</p><h2 id="其他索引结构"><a href="#其他索引结构" class="headerlink" title="其他索引结构"></a>其他索引结构</h2><p>关键值索引里，每个key都是主键，二级索引的出现可以帮助执行级联操作</p><h3 id="将值存储在索引中"><a href="#将值存储在索引中" class="headerlink" title="将值存储在索引中"></a>将值存储在索引中</h3><p>行被存储的地方是堆文件（没有特定顺序）新值不大于旧值就可以直接覆盖，大于则需要重新开一个空间并更新指向新堆位置的记录</p><p>聚集索引（clustered index）在索引中存储所有行数据</p><p>非聚集索引（nonclustered index）仅在索引中存储对数据的引用</p><p>二者之间的折衷叫做包含列的索引（index with included columns）或覆盖索引（covering index）其存储表的一部分在索引里，这允许单独使用索引来做查询</p><p>和任何类型的冗余一样，聚集索引和覆盖索引可以加快读取速度，但需要额外的存储空间和存储开销和事务保证</p><h3 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h3><p>key - value是一对一关系，如果同时查询一个表里的多个列是不够的</p><p>常见的多列索引叫做连接索引（concatenated index）将一列的值追加到另一列后面（将多个字段合并为一个键）</p><p>多维索引是查询多列的更一般方法，比如查询地图上特定范围的商店，需要经度纬度的信息进行二维查询，B树或LSM树索引对这种查询的支持并不好</p><h3 id="内存存储"><a href="#内存存储" class="headerlink" title="内存存储"></a>内存存储</h3><p>RAM的成本降低让一些小数据集保存在内存中是可行的，可以分布在多个机器上，导致内存数据库的发展</p><p>内存数据库重启时从磁盘重新加载，但读写仍在内存中进行，磁盘作为耐久性附加日志，使用日志结构，也让内存数据库具有持久性方法</p><p>内存数据库的性能优势不在于需要从磁盘读写，而是省去了内存数据结构编码为磁盘数据结构的开销。</p><p>“反缓存”方法将内存不足的情况下将最少使用的内存转移到磁盘，并在再次访问中重新加载到内存和OS虚存概念类似，不过有更小的粒度，不是整个内存页，如果硬件NVM（非易失性存储器）技术更广泛使用，没准儿会有新的存储引擎设计捏</p><h2 id="事务处理-OR-在线分析"><a href="#事务处理-OR-在线分析" class="headerlink" title="事务处理 OR 在线分析"></a>事务处理 OR 在线分析</h2><p>早期事务处理主要在商业交易，一组逻辑单元的读写，事务处理意味着低延迟读取写入，不是批量处理</p><p>现在的数据库基本访问模式依旧类似处理业务事务，但通常查找少量记录，并伴随较多更新，这样的应用是交互式的，这种模式叫做在线事务处理（OLTP）</p><p>但是当数据库用于数据分析，又有新的访问模式，不需要原始数据，而是将处理后的信息返回，这样的模式叫做在线分析处理（OLAP）</p><table><thead><tr><th align="center"><strong>属性</strong></th><th align="left"><strong>事务处理 OLTP</strong></th><th align="center"><strong>分析系统 OLAP</strong></th></tr></thead><tbody><tr><td align="center">主要读取模式</td><td align="left">查询少量记录，按键读取</td><td align="center">在大批量记录上聚合</td></tr><tr><td align="center">主要写入模式</td><td align="left">随机访问，写入要求低延时</td><td align="center">批量导入（ETL），事件流</td></tr><tr><td align="center">主要用户</td><td align="left">终端用户，通过Web应用</td><td align="center">内部数据分析师，决策支持</td></tr><tr><td align="center">处理的数据</td><td align="left">数据的最新状态（当前时间点）</td><td align="center">随时间推移的历史事件</td></tr><tr><td align="center">数据集尺寸</td><td align="left">GB ~ TB</td><td align="center">TB ~ PB</td></tr></tbody></table><p>随着两种模式的日趋分歧，OLTP系统不再作为分析，转去在单独的数据库分析，这类数据库叫做数据仓库</p><h3 id="数据仓库"><a href="#数据仓库" class="headerlink" title="数据仓库"></a>数据仓库</h3><p>OLTP系统对业务运作比较重要，要求低延迟高可用，执行分析操作会开销巨大，扫描大部分数据集会损害同时执行的事务性能</p><p>数据仓库作为独立的数据库，可以分析而不影响OLTP操作，数据仓库一般是所有只读数据副本，转换成适合分析的模式，清理并加载到数据库里。<strong>抽取-转换-加载</strong></p><p>虽然看起来OLTP和数据仓库都是关系型的（大部分）SQL也基本是支持分析查询的，但是查询模式的不同还是带来了分化</p><h3 id="星型模式和雪花型模式"><a href="#星型模式和雪花型模式" class="headerlink" title="星型模式和雪花型模式"></a>星型模式和雪花型模式</h3><p>表关系可视化时，事实表（几百列）在中间，被纬度表（可以很宽）包围</p><p>如果将尺寸分解，每一行都可以作为外键引用会更加规范化。</p><h3 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h3><p>事实表中包含数PB的数据，高效存储和检索就会有问题。数据仓库里并不需要SELECT *，而是读取三四个列，因此列存储会比较有效率</p><p>为了降低磁盘IO 列压缩也是一个像样的技术</p><p>当需要大规模顺序扫描时，索引显得不是那么重要，紧凑的编码数据却更重要了</p><h2 id="OLTP存储引擎学派"><a href="#OLTP存储引擎学派" class="headerlink" title="OLTP存储引擎学派"></a>OLTP存储引擎学派</h2><h3 id="日志结构学派"><a href="#日志结构学派" class="headerlink" title="日志结构学派"></a>日志结构学派</h3><p>只允许附加到文件和删除过时的文件，不更新已写入的文件。Bitcask SSTables LSM树 HBase都属于这个类别</p><h3 id="就地更新学派"><a href="#就地更新学派" class="headerlink" title="就地更新学派"></a>就地更新学派</h3><p>将磁盘视为一组可以反复读写的固定大小页面，B树贯彻了这种哲学，也用在大多数关系数据库和NoSQL中</p><h1 id="DDIA-第四章节-编码与演化"><a href="#DDIA-第四章节-编码与演化" class="headerlink" title="DDIA 第四章节 编码与演化"></a>DDIA 第四章节 编码与演化</h1><p>应用程序将会随着时间的变化而变化，而功能的修改也意味着存储的数据可能有更改</p><p>数据格式或模式发生变化时，代码或许也要更改。而新旧版本的代码，新旧数据格式可能要在同一个系统中共处，如果想要让系统顺利运行，就要保持双向兼容性：</p><ul><li>向后兼容（Backward Compatibility）新代码可以读取旧数据</li><li>向前兼容（Forward Compatibility）旧代码可以读取新数据</li></ul><h2 id="编码数据的格式"><a href="#编码数据的格式" class="headerlink" title="编码数据的格式"></a>编码数据的格式</h2><p>程序中一般有两种数据格式：</p><ol><li>内存中，数据保存在对象 结构体 列表 数组 哈希表 树等结构中，支持CPU高效访问，对操作进行了优化</li><li>如果要将数据写入文件或通过网络发送要进行编码（如JSON）</li></ol><p>进行这两种之间的翻译，将内存中表示专为字节序列的转换叫做编码（encoding） 序列化（serialization）或编组（marshalling） 反过来叫做解码 解析 反序列化 反编组</p><p>现有的许多编程语言都自建内存对象编码为字节序列的支持，比如Java的<code>java.io.Serializable</code>等等，但是也有一定问题：</p><ul><li>编码与语言绑定，其他语言难以读取</li><li>解码过程通常需要实例化任意类的能力，会有安全问题</li><li>前后向兼容能力较差，效率较低</li></ul><h2 id="JSON-XML和二进制变体"><a href="#JSON-XML和二进制变体" class="headerlink" title="JSON XML和二进制变体"></a>JSON XML和二进制变体</h2><p>JSON XML是可以被许多编程语言编写和读取的标准化编码，XML通常被诟病为冗长复杂，JSON由于Web浏览器内置支持而受到欢迎，CSV也与语言无关，但功能较弱</p><p>JSON XML CSV都是文本格式，具有人类可读性，但是除了语法问题还有很多小问题：</p><ol><li>数字编码有歧义，XML和CSV不区分数字和字符串，JSON区分但不区分整数和浮点数</li><li>处理大量数据时，使用浮点数语言进行分析时，基于IEEE 754双精度浮点数会有数字不准确的问题</li><li>JSON XML对Unicode支持较好，但不支持二进制数据</li></ol><p>作为数据交换格式，JSON XML和CSV比较受欢迎，但是不同组织达成一致的难度很大</p><h3 id="二进制编码"><a href="#二进制编码" class="headerlink" title="二进制编码"></a>二进制编码</h3><p>简单的小规模数据JSON XML存储成本和交换成本不大，解析压力较小，但是一旦达到TB级别，与二进制相比还是差很多，这导致大量二进制编码版本JSON和XML的出现 JSON有（BSON UBJSON MessagePack Smile等等）他们各自在自己的领域被采用，但没有被广泛使用</p><h2 id="Thrift-与-Protocol-Buffers"><a href="#Thrift-与-Protocol-Buffers" class="headerlink" title="Thrift 与 Protocol Buffers"></a>Thrift 与 Protocol Buffers</h2><p>Thrift和Protocol Buffers基于相同原理的二进制编码库且开源，Thrift以接口定义语言（IDL）来描述模式，以模式定义生成各种编程语言实现模式的类</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> </span>&#123;<br><span class="hljs-number">1</span>: <span class="hljs-keyword">required</span> <span class="hljs-built_in">string</span> userName,<br><span class="hljs-number">2</span>: <span class="hljs-keyword">optional</span> <span class="hljs-built_in">i64</span> favoriteNumber,<br><span class="hljs-number">3</span>: <span class="hljs-keyword">optional</span> list&lt;<span class="hljs-keyword">string</span>&gt; interest<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>每个字段被标记为必须和可选，但是对如何编码没有影响，如果没有设置该字段会检查出错</p><h3 id="字段标签和模式演变"><a href="#字段标签和模式演变" class="headerlink" title="字段标签和模式演变"></a>字段标签和模式演变</h3><p>模式是不可避免的随着改变，那么Thrift和Protocol Buffers如何处理模式更改，保证向后兼容呢？</p><p>从示例来看，每个字段是由标签号码123标识，并用数据类型约束，没有设置字段值就会从编码记录里省略。添加新的字段值需要标一个新的号码，旧代码读取新数据中包含新的字段，不识别直接省略，保证向前兼容</p><p>向后兼容里，只要每个字段的号码标签不变，那么新代码可以读取旧数据，仍然有相同含义。只是不能将新字段设置为必须，或者必须有默认值</p><p>删除一个字段只能删除可选，而且不能再用相同号码</p><h3 id="数据类型和模式演变"><a href="#数据类型和模式演变" class="headerlink" title="数据类型和模式演变"></a>数据类型和模式演变</h3><p>如何改变字段的数据类型？i32 =&gt; i64可以保证向后兼容，但是向前兼容里可能有问题</p><p>Protocol buf有一个细节是没有列表或数组数据类型，而是有个字段可以从单值变为多值。</p><p>Thrift有专用的列表数据类型进行参数化</p><h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><p>Avro是另一种二进制编码格式，适用于Hadoop</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">record Person &#123;<br><span class="hljs-built_in">string</span> userName;<br>union &#123; <span class="hljs-literal">null</span>, long &#125; favoriteNumber = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">array<span class="hljs-keyword">&lt;<span class="hljs-built_in">string</span>&gt;</span></span> <span class="hljs-built_in">int</span>erests;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>Acro区分作者模式和读者模式，模式解析通过字段名匹配字段，如果出现了作者模式里但读者模式里没有则忽略，反之则转而用读者模式里的声明默认值填充。</p><p>为了保持兼容性只能添加或删除有默认值的字段，没有optional和required标记</p><p>Avro的优点在于动态生成，模式发生变化时也可以生成新的Avro，由于字段是通过名字来标识的，所以新的模式还可以兼容旧的读者模式。Thrift和Protocol Buf需要手动分配字段标记。</p><h3 id="代码生成的动态类型语言"><a href="#代码生成的动态类型语言" class="headerlink" title="代码生成的动态类型语言"></a>代码生成的动态类型语言</h3><p>Thrift和Protobuf依赖于代码生成，定义模式之后可以选择编程语言实现此模式的代码，在一些静态类型语言里很有用，Java C++ C#等，可以进行类型检查和自动完成。动态类型编程语言里没有编译时类型检查。所以代码生成往往没啥意义。</p><h2 id="模式的优点"><a href="#模式的优点" class="headerlink" title="模式的优点"></a>模式的优点</h2><p>Protobuf Thrift Acro都适用模式（Schema）来描述二进制格式。由于Protobuf Thrift Acro实现简单，已经广泛支持到很多编程语言。基于二进制的编码有很多优秀的特性</p><ul><li>更加紧凑</li><li>作为文档单独维护</li><li>保证兼容性</li><li>静态类型编程语言可以进行类型检查</li></ul><p>Schema可以提供较好的灵活性和规范性</p><h2 id="数据流的类型"><a href="#数据流的类型" class="headerlink" title="数据流的类型"></a>数据流的类型</h2><p>数据在流程中流动的常见方式：</p><ul><li>数据库</li><li>服务调用（REST / RPC）</li><li>异步消息传递</li></ul><h3 id="数据库中的数据流"><a href="#数据库中的数据流" class="headerlink" title="数据库中的数据流"></a>数据库中的数据流</h3><p>数据库中，对写入数据编码，对读入数据解码，数据库的内容可以理解为向未来的自己发送消息</p><p>一般来说几个不同进程访问数据库是存在的，有些进程是新代码，有些是旧代码，所以数据库要保持向前兼容。</p><p>在一个大数据集上执行数据库重写是一个昂贵的事情，大多数关系库支持简单的模式更改，比如添加一个默认值为空的新列。</p><h3 id="服务中的数据流：REST-RPC"><a href="#服务中的数据流：REST-RPC" class="headerlink" title="服务中的数据流：REST / RPC"></a>服务中的数据流：REST / RPC</h3><p>Client Server体系下，如果要用JSON来作为数据传输格式，C、S两端要对API细节达成一致。Server端也可以去访问另一个服务的数据，这种方式叫做微服务架构。微服务架构的设计目标是让服务独立部署和演化使应用程序容易更改和维护</p><p>REST是一种基于HTTP的设计哲学，强调简单的数据格式，用URL标识资源，用HTTP来做缓存控制 身份验证和内容写上，符合REST设计原则的API叫做RESTful</p><p>SOAP是用于制作网络API请求的基于XML的协议，客户端可以使用本地类和方法调用远程服务，在静态类型语言里很有用，但是Web服务描述语言（WSDL）的设计是人类不可读的，所以要依赖IDE和代码生成工具。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC模型试图向远程网络服务发出请求，调用不同编程语言里约定好的函数/方法。RPC看起来比较方便，但是网络请求和本地函数调用有本质不同：</p><ul><li>本地调用可预测，成功失败可控制，网络请求是不可预知的：</li><li>请求和响应丢失</li><li>远程计算机不可用没有结果</li><li>响应较慢而超时</li></ul><p>都是可能的，但本机只能进行预测或重试请求，完全不知道发生了什么</p><ul><li>如果重试失败的请求伴随着不幂等（如POST请求）可能执行多次，所以要在协议里引入除重机制</li><li>网络请求可能要比本地函数调用慢很多，延迟也不可预测</li><li>RPC框架要规定好编码和数据类型</li></ul><h3 id="RPC的当前方向"><a href="#RPC的当前方向" class="headerlink" title="RPC的当前方向"></a>RPC的当前方向</h3><p>Thrift和Avro带有RPC支持，gRPC是用Protobuf的RPC实现，Finagle使用Thrift，Rest.li使用JSON over HTTP</p><p>新一代RPC框架会对远程请求进行更多处理，比如Finagle和Rest.li使用futures(promise)来封装可能失败的异步操作，也可以简化多个并行请求返回的结果，gRPC支持流，一个调用可以是一系列的请求和响应</p><p>二进制编码的自定义RPC协议可以实现比JSON over REST更好的性能，但是RESTful API便于调试，有大量工具和完整的生态系统，REST很适合公共API的主要风格，RPC的重点在于同一组织的服务之间的请求，在同一数据中心内</p><h3 id="数据编码和RPC演化"><a href="#数据编码和RPC演化" class="headerlink" title="数据编码和RPC演化"></a>数据编码和RPC演化</h3><p>在可演化性上，RPC方案的兼容性从编码方式中继承</p><ul><li>Thrift gRPC 和Avro RPC可以根据编码格式的兼容性规则进行演变</li><li>SOAP中 请求和响应用XML模式指定</li><li>RESTful API使用JSON用于响应，添加新字段可以作为兼容性改变</li></ul><p>API版本化如何工作，目前还没有一致意见，对RESTful API，常用的方法是在URL或HTTP Accept头里使用版本号</p><h3 id="消息传递中的数据流"><a href="#消息传递中的数据流" class="headerlink" title="消息传递中的数据流"></a>消息传递中的数据流</h3><p>RPC和数据库之间的异步消息传递系统和RPC类似，消息以低延迟传送到另一个进程，与数据库类似，不通过网络连接发送消息，而是消息代理（消息队列或面向消息的中间件）来临时存储消息</p><p>与直接RPC相比，使用消息代理有很多优点：</p><ul><li>消费者不可用或过载，可以充当缓冲区，提高系统可用性</li><li>它可以自动将消息发送到已崩溃的进程，防止消息丢失</li><li>避免生产者知道消费者的IP地址和端口号（在虚拟机或云存储比较有用）</li><li>可以一条消息发送给多个消费者</li><li>消费者和生产者逻辑分离</li></ul><p>和RPC相比，消息传递通信通常是单向的，发送者一般不期望收到消息回复，通常也在一个通道上完成</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>RabbitMQ ActiveMQ HornetQ NATS和Kafka这样的开源实现比较流行</p><p>消息代理的使用方式如下：</p><p>一个进程将消息发送到指定的队列或主题，代理确保消息传递给一个或多个消费者或者订阅者的队列或主题，在一个主题上有多个生产者和消费者</p><p>消息代理通常不会执行任何数据模型，消息只是包含一些元数据的字节序列</p><h1 id="DDIA-第五章节-复制"><a href="#DDIA-第五章节-复制" class="headerlink" title="DDIA 第五章节 复制"></a>DDIA 第五章节 复制</h1><h2 id="分布式数据"><a href="#分布式数据" class="headerlink" title="分布式数据"></a>分布式数据</h2><p>将数据库分布在多台机器上，需要考虑</p><ul><li>可扩展性</li><li>容错性/可用性</li><li>延迟</li></ul><p>如果只需要扩展至更高载荷，可以考虑垂直扩展，采用更强的机器。这样的方法问题在于成本增长的速度是快于线性增长的，双倍处理器，双倍内存，双倍磁盘空间的成本远远超过原来的两倍。</p><p>相比之下，水平扩展会更加普及，每台机器/虚拟机是一个节点，每个节点使用各自处理器 内存 磁盘，节点之间通过软件层面协调</p><h3 id="复制与分区"><a href="#复制与分区" class="headerlink" title="复制与分区"></a>复制与分区</h3><p>分布在多个节点上有两种常见方式：</p><ol><li>复制</li></ol><p>在几个不同节点上保存数据的相同副本，复制提供了冗余</p><ol><li>分区</li></ol><p>将一个大型数据库拆分成比较小的子集，将不同分区指派给不同切片（Node）</p><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>多台机器上保存相同数据副本会有很多原因：</p><ol><li>数据与用户在物理上接近（减少延迟） CDN思路</li><li>保证可用性，冗余后即使一个打挂了另一个还能继续服务</li><li>支持更多请求，提高读取吞吐量</li></ol><p>CDN比较简单，因为其中的数据不会随时间频繁改变，复制也就比较简单，复制的困难在于复制的变更，当前流行的解法有三种：</p><ul><li>单领导者(Single leader)</li><li>多领导者(Multi leader)</li><li>无领导者(leaderless)</li></ul><h2 id="领导者与追随者"><a href="#领导者与追随者" class="headerlink" title="领导者与追随者"></a>领导者与追随者</h2><p>第一个问题：如何保证数据已经全部落库？</p><p>最常见的解决方案被称为<strong>基于领导者的复制（leader-based replication）</strong>（也称<strong>主动/被动（active/passive）</strong>或<strong>主/从（master/slave）</strong>复制）它的机制如下：</p><ol><li>一个节点被指定为<strong>领导者（leader）</strong>，也称为<strong>主库（master|primary）</strong>。当客户端要向数据库写入时，它必须将请求发送给<strong>领导者</strong>，领导者会将新数据写入其本地存储。</li><li>其他副本被称为<strong>追随者（followers）</strong>，亦称为<strong>只读副本（read replicas）</strong>，<strong>从库（slaves）</strong>，<strong>备库（ sencondaries）</strong>，<strong>热备（hot-standby）</strong>。每当领导者将新数据写入本地存储时，它也会将数据变更发送给所有的追随者，称之为<strong>复制日志（replication log）</strong>记录或<strong>变更流（change stream）</strong>。每个跟随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照领导者处理的相同顺序应用所有写入。</li><li>当客户想要从数据库中读取数据时，它可以向领导者或追随者查询。 但只有领导者才能接受写操作（从客户端的角度来看从库都是只读的）</li></ol><p>这种复制模式是大多数关系型数据库的内置功能。在消息队列这种分布式消息代理中也会使用它</p><h3 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h3><p>单线程同步复制里，可以保证从库有与主库一致的最新数据副本。如果主库突然失效，数据仍然能在从库上上找到，缺点是从库如果崩溃或网络故障，主库就无法进行写入操作，要等待同步副本后才能可用</p><p>这样很不合理，所以有种配置对一个追随者开启同步复制，对其他节点开启异步复制，如果同步从库缓慢，则从异步从库里抽出一个同步，这样的方法叫做半同步：保证至少两个节点上具有最新的数据副本</p><p>通常基于领导者的复制都配制成完全异步。缺点在于主库失效，未复制给从库的所有写入都会丢失，那么C端即使请求成功，写入不能保证持久（弱持久性）。优点在于即使从库落后，主库依然可以处理写入，不会被阻塞</p><h3 id="设置新从库"><a href="#设置新从库" class="headerlink" title="设置新从库"></a>设置新从库</h3><p>简单从一个节点复制到新节点是不够的，数据总在不断变化，而锁定数据库来保证一致也违背了可用性，所以通常做法为：</p><ol><li>获取主库的一致性快照</li><li>按快照复制到新的从库节点</li><li>从库连接到主库，拉取快照后的一系列数据变更（需要快照与主库复制日志的位置精确关系）</li><li>从库处理完积压的数据变更，正式成为从库</li></ol><h3 id="处理节点宕机"><a href="#处理节点宕机" class="headerlink" title="处理节点宕机"></a>处理节点宕机</h3><p>如何基于主库复制实现高可用性？</p><h4 id="从库失效：追赶恢复"><a href="#从库失效：追赶恢复" class="headerlink" title="从库失效：追赶恢复"></a>从库失效：追赶恢复</h4><p>如果从库因为网络断开与主库的联系，可以快速恢复，通过日志定位到发生故障前到最后事务，并处理积压的数据变更</p><h4 id="主库失效：故障切换"><a href="#主库失效：故障切换" class="headerlink" title="主库失效：故障切换"></a>主库失效：故障切换</h4><p>主库失效，需要一个从库提升为新主库，需要重新配置来让C端将写操作发送到新主库。</p><ol><li>确认主库失效，所以大多数系统只是简单使用<strong>超时（Timeout）</strong>：节点频繁地相互来回传递消息，并且如果一个节点在一段时间内（例如30秒）没有响应，就认为它挂了</li><li>选择一个新的主库可以通过选举完成，或者可以由之前选定的控制器节点来指定新的主库。主库的最佳人选通常是拥有旧主库最新数据副本的从库（最小化数据损失）</li><li>重新配置系统以启用新的主库。客户端现在需要将它们的写请求发送给新主库。如果老领导恢复可用，可能仍然认为自己是主库，需要确保它成为一个从库</li></ol><p>故障切换会出现很多大麻烦：</p><ul><li>异步复制的一个场景：新主库没有收到旧主库宕机前最后的写入操作。老主库重新加入集群，如何写入这段时间的冲突写入？最常见的解决方案是简单丢弃，这很可能打破客户对于数据持久性的期望。</li><li>如果数据库需要和其他外部存储相协调，那么丢弃写入内容是极其危险的操作。</li></ul><blockquote><p>eg: 在GitHub 的一场事故中，一个过时的MySQL从库被提升为主库。数据库使用自增ID作为主键，因为新主库的计数器落后于老主库的计数器，所以新主库重新分配了一些已经被老主库分配掉的ID作为主键。这些主键也在Redis中使用，主键重用使得MySQL和Redis中数据产生不一致，最后导致一些私有数据泄漏到错误的用户手中。</p></blockquote><ul><li>两个节点都以为自己是主库的情况。这种情况称为**脑裂(split brain)**，非常危险：如果两个主库都可以接受写操作，却没有冲突解决机制，那么数据就可能丢失或损坏。一些系统采取了安全防范措施：当检测到两个主库节点同时存在时会关闭其中一个节点。但设计粗糙的机制可能最后会导致两个节点都被关闭。</li><li>主库被宣告死亡之前的正确超时应该怎么配置？在主库失效的情况下，超时时间越长，意味着恢复时间也越长。但是如果超时设置太短，又可能会出现不必要的故障切换。</li></ul><h3 id="复制日志"><a href="#复制日志" class="headerlink" title="复制日志"></a>复制日志</h3><h4 id="基于语句的复制"><a href="#基于语句的复制" class="headerlink" title="基于语句的复制"></a>基于语句的复制</h4><p>主库记录下每一个请求语句，将每一次<code>INSERT</code>,<code>UPDATE</code>,<code>DELETE</code>都转发到每一个从库。让从库解析并执行该语句，仿佛是从客户端收到的一样</p><p>虽然听上去很合理，但有很多问题会搞砸这种复制方式：</p><ul><li>任何调用<strong>非确定性函数（nondeterministic）</strong>的语句，可能会在每个副本上生成不同的值。例如，使用<code>NOW()</code>获取当前日期时间，或使用<code>RAND()</code>获取一个随机数。</li><li>如果语句使用了<strong>自增列（auto increment）</strong>，或者依赖于数据库中的现有数据（例如，<code>UPDATE ... WHERE &lt;某些条件&gt;</code>），则必须在每个副本上按照完全相同的顺序执行它们，否则可能会产生不同的效果。当有多个并发执行的事务时，这可能成为一个限制。</li><li>有副作用的语句（例如，触发器，存储过程，用户定义的函数）可能会在每个副本上产生不同的副作用，除非副作用是绝对确定的。</li></ul><h4 id="传输预写式日志（WAL）"><a href="#传输预写式日志（WAL）" class="headerlink" title="传输预写式日志（WAL）"></a>传输预写式日志（WAL）</h4><p>通常写操作是追加到日志里，日志通常是包含了所有数据库写入的仅追加字节序列，可以使用完全相同的日志在另一个节点上构建副本，除了将日志写进磁盘，主库还可以通过网络将其发送给从库。从库使用这个日志时，会建立一个和主库一样数据结构的副本</p><p>缺点是日志记录的数据非常底层：WAL包含哪些磁盘块中的哪些字节发生了更改。这使复制与存储引擎紧密耦合。如果数据库将其存储格式从一个版本更改为另一个版本，通常不可能在主库和从库上运行不同版本的数据库软件。</p><h4 id="逻辑日志复制（基于行）"><a href="#逻辑日志复制（基于行）" class="headerlink" title="逻辑日志复制（基于行）"></a>逻辑日志复制（基于行）</h4><p>如果复制和存储引擎使用不同的日志格式，可以使复制日志从存储引擎内部分离出来。这种复制日志被称为逻辑日志。 逻辑日志与存储引擎内部分离，可以更容易地保持向后兼容，从而使领导者和跟随者能够运行不同版本的数据库软件甚至不同的存储引擎。</p><blockquote><p>关系数据库的逻辑日志通常是以行的粒度描述对数据库表的写入的记录序列：</p><blockquote><ul><li>对于插入的行，日志包含所有列的新值。</li></ul></blockquote><ul><li>对于删除的行，日志包含足够的信息来唯一标识已删除的行。通常是主键，但是如果表上没有主键，则需要记录所有列的旧值。</li><li>对于更新的行，日志包含足够的信息来唯一标识更新的行，以及所有列的新值（或至少所有已更改的列的新值）。</li></ul></blockquote><h4 id="基于触发器的复制"><a href="#基于触发器的复制" class="headerlink" title="基于触发器的复制"></a>基于触发器的复制</h4><p>如果您只想复制数据的一个子集，或者想从一种数据库复制到另一种数据库，或者如果您需要冲突解决逻辑，可能要把复制从底层提高到应用程序层</p><p>触发器允许在写入事务时自动执行的自定义应用程序代码。触发器有机会将更改记录到一个单独的表中，使用外部程序读取这个表，再加上任何业务逻辑处理，会后将数据变更复制到另一个系统去</p><h3 id="复制延迟问题"><a href="#复制延迟问题" class="headerlink" title="复制延迟问题"></a>复制延迟问题</h3><p>在读多写少的场景，理想情况是创建很多从库，将读请求分散到所有从库上去，减少主库的负载。如果异步写库，那么有些访问了旧数据，有些拿到了新数据，这种不一致是一个暂时的状态，但是最终从库必然保持和主库一致（叫做最终一致性）</p><p>写入滞后引起的不一致叫做复制延迟问题，针对不同场景问题有不同解法</p><h4 id="读己之写"><a href="#读己之写" class="headerlink" title="读己之写"></a>读己之写</h4><p>第一个问题是 用户写入后从旧副本里读取了数据，我们需要<strong>读写一致性（read-after-write consistency）</strong>，也称为<strong>读己之写一致性（read-your-writes consistency）</strong></p><p>如何在基于领导者的复制系统中实现读后一致性？有各种可能的技术，这里说一些：</p><ul><li>读用户<strong>可能已经修改过</strong>的内容时，都从主库读；</li></ul><blockquote><p>e.g. 社交网络上的用户个人资料信息通常只能由用户本人编辑，因此一个简单的规则是：从主库读取用户自己的信息，在从库读取其他用户的信息。</p></blockquote><ul><li>可以跟踪上次更新的时间，在上次更新后的一分钟内，从主库读。还可以监控从库的复制延迟，防止任向任何滞后超过一分钟到底从库发出查询。</li><li>客户端可以记住最近一次写入的时间戳，系统需要确保从库为该用户提供任何查询时，该时间戳前的变更都已经传播到了本从库中。如果当前从库不够新，则可以从另一个从库读，或者等待从库追赶上来。</li><li>如果您的副本分布在多地会增加复杂性。任何需要由领导者提供服务的请求都必须路由到包含主库的数据中心。（网关层来做？）</li></ul><h4 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h4><p>用户可能会遇到<strong>时光倒流（moving backward in time）</strong>：如果用户从不同从库进行多次读取，首先查询了一个新副本，然后查询了一个旧副本，那么之前看到的新数据就消失了，为了避免这种异常，要单调读取。</p><p><strong>单调读（Monotonic reads）</strong>是这种异常不会发生的保证。这是一个比<strong>强一致性（strong consistency）</strong>更弱，但比<strong>最终一致性（eventually consistency）</strong>更强的保证。单调读取意味着如果顺序进行多次读取，不会读到旧数据，只会读到新数据。</p><p>简单实现方式是保证在同一个副本读取</p><h4 id="一致前缀读"><a href="#一致前缀读" class="headerlink" title="一致前缀读"></a>一致前缀读</h4><p>刚才是因为延迟发生了时间倒流的情况，还有一种情况是因果倒转 本是A -&gt; B顺序的数据成了 B -&gt; A</p><p>这是分布式数据库的一个特殊问题。不同分区的出现，导致全局写入顺序是不存在的，总有一些部分是旧状态，有些是新状态。</p><p><strong>一致前缀读（consistent prefix reads）</strong>这个保证说：如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现。</p><p>简单解决方法是确保因果无关写入相同分区，还有专门的因果依赖关系算法来解决这个问题</p><h2 id="多主复制"><a href="#多主复制" class="headerlink" title="多主复制"></a>多主复制</h2><p>基于领导者的复制有一个主要的缺点：只有一个主库，而所有的写入都必须通过它。如果出于任何原因无法连接到主库， 就无法向数据库写入。</p><p>如果允许多个节点接受写入，处理写入的每个节点都必须将该数据更改转发给所有其他节点，叫做<strong>多领导者配置</strong>（也称多主、多活复制），每个领导者同时扮演其他领导者的追随者</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li>适用于多个数据中心的情况。它能提供更好的性能，更低的延迟，更良好的容灾机制和可用性。但缺点也很明显，就是两个数据中心写入相同数据的冲突解决问题。多主复制常常还有自增主键、触发器、完整性约束等麻烦，比较危险</li><li>应用程序在断网之后仍然需要继续工作</li></ol><blockquote><p>e.g. 考虑手机上的日历应用。无论设备目前是否有互联网连接，你需要能随时查看你的会议（发出读取请求），输入新的会议（发出写入请求）。如果在离线状态下进行任何更改，则设备下次上线时，需要与服务器和其他设备同步。</p></blockquote><p>在这种情况下每个设备都是一个“数据中心”，是一个本地数据库，而它们之间的网络连接是极度不可靠的。</p><ol><li>协同编辑，我们通常不会将协作式编辑视为数据库复制问题，但与前面提到的离线编辑用例有许多相似之处。</li></ol><h3 id="处理写入冲突"><a href="#处理写入冲突" class="headerlink" title="处理写入冲突"></a>处理写入冲突</h3><p>多领导者复制的最大问题是可能发生写冲突，这意味着需要解决冲突。</p><h4 id="避免冲突"><a href="#避免冲突" class="headerlink" title="避免冲突"></a>避免冲突</h4><p>应用程序可以确保特定记录的所有写入都通过同一个领导者，那么冲突就不会发生。保证用户交互的始终是同一个数据中心，并使用该数据中心的领导者进行读写。可以cover大部分场景，但是如果需要写另外的主库，还是会出现冲突问题。</p><h4 id="收敛至一致的状态"><a href="#收敛至一致的状态" class="headerlink" title="收敛至一致的状态"></a>收敛至一致的状态</h4><p>数据库必须以一种<strong>收敛（convergent）</strong>的方式解决冲突，所有副本必须在所有变更复制完成时收敛至一个相同的最终值。</p><p>实现冲突合并解决有多种途径：</p><ul><li>给每个写入一个唯一的ID（例如，一个时间戳，一个长的随机数，一个UUID或者一个键和值的哈希），挑选最高ID的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术被称为<strong>最后写入胜利（LWW, last write wins）</strong>。虽然这种方法很流行，但是很容易造成数据丢失</li><li>为每个副本分配一个唯一的ID，ID编号更高的写入具有更高的优先级。这种方法也会数据丢失</li><li>以某种方式将这些值合并在一起 - 例如，按字母顺序排序，然后连接它们</li><li>在保留所有信息的显式数据结构中记录冲突，并编写解决冲突的应用程序代码</li></ul><h4 id="自定义冲突解决逻辑"><a href="#自定义冲突解决逻辑" class="headerlink" title="自定义冲突解决逻辑"></a>自定义冲突解决逻辑</h4><p>大多数多主复制工具允许使用应用程序代码编写冲突解决逻辑。在写入或读取时执行：</p><ul><li>写时执行，只要数据库系统检测到复制更改日志中存在冲突，就会调用冲突处理程序</li></ul><blockquote><p>e.g. Bucardo允许您为此编写一段Perl代码。这个处理程序通常不能提示用户——它在后台进程中运行，并且必须快速执行。</p></blockquote><ul><li>读时执行，当检测到冲突时，所有冲突写入被存储。下一次读取数据时，会将这些多个版本的数据返回给应用程序。应用程序可能会提示用户或自动解决冲突，并将结果写回数据库</li></ul><p>冲突解决通常适用于单个行或文档层面，而不是整个事务。因此，如果有一个事务会原子性地进行几次不同的写入，则对于冲突解决而言，每个写入仍需分开单独考虑。</p><h3 id="多主复制拓扑"><a href="#多主复制拓扑" class="headerlink" title="多主复制拓扑"></a>多主复制拓扑</h3><p>复制拓扑描述写入从一个节点传播到另一个节点的通信路径。</p><p>最普遍的拓扑是全部到全部，其中每个领导者将其写入每个其他领导。但是，也会使用更多受限制的拓扑。</p><p>默认情况下，MySQL仅支持<strong>环形拓扑</strong>，其中每个节点接收来自一个节点的写入，并将这些写入（加上自己的任何写入）转发给另一个节点。另一种流行的拓扑结构具有星形的形状。指定的根节点将写入转发给所有其他节点。星型拓扑可以推广到树。</p><p>在圆形和星形拓扑中，为了防止无限复制循环，每个节点被赋予一个唯一的标识符</p><p>循环和星型拓扑的问题是，如果只有一个节点发生故障，则可能会中断其他节点之间的复制消息流，导致它们无法通信，直到节点修复。</p><p>全能拓扑也可能有问题。特别是，一些网络链接可能比其他网络链接更快（例如，由于网络拥塞），结果是一些复制消息可能“超过”其他复制消息。这样又成了一个因果关系问题，要正确排序这些事件，要用到一种称为<strong>版本向量（version vectors）</strong>的技术</p><h2 id="无主复制"><a href="#无主复制" class="headerlink" title="无主复制"></a>无主复制</h2><p>一些数据存储系统放弃主库概念，允许任何副本直接接受客户端写入。在无领导者的实现中，客户端直接将写入发送到几个副本里，或者一个<strong>协调者（coordinator）</strong>节点代表客户端进行写入（但不执行特定写入顺序）</p><p>123节点里3出现了故障，只有12成功写入，那么读取到3会发现旧值当成了正确响应，为了解决这个问题，读请求也会并行发送到123三个节点，响应中包含数据的最新值和旧值，通过版本号确定哪一个是正确的</p><h3 id="读修复和反熵"><a href="#读修复和反熵" class="headerlink" title="读修复和反熵"></a>读修复和反熵</h3><p>在节点重新联机之后，如何赶上它错过的写入？</p><p>在Dynamo风格的数据存储中经常使用两种机制：</p><h4 id="读修复（Read-repair）"><a href="#读修复（Read-repair）" class="headerlink" title="读修复（Read repair）"></a>读修复（Read repair）</h4><p>当客户端并行读取多个节点时，它可以检测到任何陈旧的响应。像上文说的一样，这种方法适用于频繁阅读的值。</p><h3 id="反熵过程（Anti-entropy-process）"><a href="#反熵过程（Anti-entropy-process）" class="headerlink" title="反熵过程（Anti-entropy process）"></a>反熵过程（Anti-entropy process）</h3><p>一些数据存储具有后台进程不断查找副本之间的数据差异，并将任何缺少的数据从一个副本复制到另一个副本。与基于领导者的复制中的复制日志不同，此反熵过程不会以任何特定的顺序复制写入，并且在复制数据之前可能会有显著的延迟。</p><h3 id="读写的法定人数"><a href="#读写的法定人数" class="headerlink" title="读写的法定人数"></a>读写的法定人数</h3><p>每个成功的写操作意味着在三个副本中至少有两个出现，这意味着至多有一个副本可能是陈旧的。 更一般地说，如果有n个副本，每个写入必须由w节点确认才能被认为是成功的，并且我们必须至少为每个读取查询r个节点。 （在我们的例子中，$$n = 3，w = 2，r = 2$$）。只要$$w + r&gt; n$$，我们期望在读取时获得最新的值，因为r个读取中至少有一个节点是最新的。遵循这些r值，w值的读写称为<strong>法定人数（quorum）</strong>的读和写。r和w是有效读写所需的最低票数。</p><p>仲裁条件$$w + r&gt; n$$允许系统容忍不可用的节点，如下所示：</p><ul><li>如果$$w &lt;n$$，如果节点不可用，我们仍然可以处理写入。</li><li>如果$$r &lt;n$$，如果节点不可用，我们仍然可以处理读取。</li><li>对于$$n = 3，w = 2，r = 2$$，我们可以容忍一个不可用的节点。</li><li>对于$$n = 5，w = 3，r = 3$$，我们可以容忍两个不可用的节点。</li></ul><p>通常，读取和写入操作始终并行发送到所有n个副本。 参数w和r决定我们等待多少个节点，即在我们认为读或写成功之前，有多少个节点需要报告成功。</p><p>如果少于所需的w或r节点可用，则写入或读取将返回错误。</p><h4 id="监控陈旧度"><a href="#监控陈旧度" class="headerlink" title="监控陈旧度"></a>监控陈旧度</h4><p>从运维的角度来看，监控数据库是否返回最新的结果是很重要的。即使应用可以容忍陈旧的读取，也需要了解复制的健康状况。如果显著落后，有提示和复现途径</p><p>在无领导者复制的系统中，没有固定的写入顺序，这使得监控变得更加困难。而且，如果数据库只使用读修复（没有反熵过程），那么对于一个值可能会有多大的限制是没有限制的 - 如果一个值很少被读取，那么由一个陈旧副本返回的值可能是旧值。</p><h3 id="松散法定人数与带提示的接力"><a href="#松散法定人数与带提示的接力" class="headerlink" title="松散法定人数与带提示的接力"></a>松散法定人数与带提示的接力</h3><p>合理配置的法定人数可以使数据库无需故障切换即可容忍个别节点的故障。也可以容忍个别节点变慢，因为请求不必等待所有n个节点响应——当w或r节点响应时它们可以返回。</p><p>对于需要高可用、低延时、且能够容忍偶尔读到陈旧值的应用场景来说，这些特性使无主复制的数据库很有吸引力。</p><p>在一个大型的群集中（节点数量明显多于n个），网络中断期间客户端可能连接到某些数据库节点，而不是为了为特定值组成法定人数的节点们。在这种情况下，需要权衡一下：</p><ul><li>将错误返回给我们无法达到w或r节点的法定数量的所有请求是否更好？</li><li>或者我们是否应该接受写入，然后将它们写入一些可达的节点，但不在n值通常存在的n个节点之间？</li></ul><p>后者被认为是一个<strong>松散的法定人数（sloppy quorum）</strong>：写和读仍然需要w和r成功的响应，但是那些可能包括不在指定的n个“主”节点中的值。比方说，如果你把自己锁在房子外面，你可能会敲开邻居的门，问你是否可以暂时停留在沙发上。</p><p>一旦网络中断得到解决，代表另一个节点临时接受的一个节点的任何写入都被发送到适当的“本地”节点。这就是所谓的<strong>带提示的接力（hinted handoff）</strong>。 （一旦你再次找到你的房子的钥匙，你的邻居礼貌地要求你离开沙发回家。）</p><h3 id="检测并发写入"><a href="#检测并发写入" class="headerlink" title="检测并发写入"></a>检测并发写入</h3><p>Dynamo风格的数据库允许多个客户端同时写入相同的Key，这意味着即使使用严格的法定人数也会发生冲突。这种情况与多领导者复制相似，但在Dynamo样式的数据库中，在<strong>读修复</strong>或<strong>带提示的接力</strong>期间也可能会产生冲突。</p><p>问题在于，由于可变的网络延迟和部分故障，事件可能在不同的节点以不同的顺序到达。两个客户机A和B同时写入三节点数据存储区中的键X：</p><ul><li>节点 1 接收来自 A 的写入，但由于暂时中断，从不接收来自 B 的写入。</li><li>节点 2 首先接收来自 A 的写入，然后接收来自 B 的写入。</li><li>节点 3 首先接收来自 B 的写入，然后从 A 写入。</li></ul><p>如果每个节点只要接收到来自客户端的写入请求就简单地覆盖了某个键的值，那么节点就会永久地不一致，不符合最终一致性</p><h3 id="最后写入胜利（丢弃并发写入）"><a href="#最后写入胜利（丢弃并发写入）" class="headerlink" title="最后写入胜利（丢弃并发写入）"></a>最后写入胜利（丢弃并发写入）</h3><p>实现最终融合的一种方法是声明每个副本只需要存储最<strong>“最近”</strong>的值，并允许<strong>“更旧”</strong>的值被覆盖和抛弃。然后，只要我们有一种明确的方式来确定哪个写是“最近的”，并且每个写入最终都被复制到每个副本，那么复制最终会收敛到相同的值。</p><p>因为网络延迟和并发的不确定性，没有自然的写入排序，我们也可以强制任意排序。例如，可以为每个写入附加一个时间戳，挑选最<strong>“最近”</strong>的最大时间戳，并丢弃具有较早时间戳的任何写入。这种冲突解决算法被称为<strong>最后写入胜利（LWW, last write wins）</strong>，是Cassandra唯一支持的冲突解决方法，也是Riak中的一个可选特征。</p><p>LWW实现了最终收敛的目标，但以<strong>持久性</strong>为代价：如果同一个Key有多个并发写入，即使它们都被报告为客户端成功（因为它们被写入 w 个副本），但只有一个写入将存活，而其他写入将被静默丢弃。此外，LWW甚至可能会删除不是并发的写入。</p><p>与LWW一起使用数据库的唯一安全方法是确保一个键只写入一次，然后视为不可变，从而避免对同一个密钥进行并发更新。例如，Cassandra推荐使用的方法是使用UUID作为键，从而为每个写操作提供一个唯一的键。</p><h3 id="“此前发生”的关系和并发"><a href="#“此前发生”的关系和并发" class="headerlink" title="“此前发生”的关系和并发"></a>“此前发生”的关系和并发</h3><p>如何判断两个操作是否是并发的？</p><p>如果操作B了解操作A，或者依赖于A，或者以某种方式构建于操作A之上，则操作A在另一个操作B之前发生。事实上，我们可以简单地说，如果两个操作都不在另一个之前发生，那么两个操作是并发的（即，<strong>两个操作都不知道另一个</strong>）</p><p>只要有两个操作A和B，就有三种可能性：A在B之前发生，或者B在A之前发生，或者A和B并发。</p><blockquote><p>由于分布式系统里的时钟问题，<strong>并发</strong>不等同于<strong>同时</strong></p></blockquote><h4 id="合并同时写入的值"><a href="#合并同时写入的值" class="headerlink" title="合并同时写入的值"></a>合并同时写入的值</h4><p>合并兄弟值，本质上是与多领导者复制中的冲突解决相同的问题。一个简单的方法是根据版本号或时间戳（最后写入胜利）选择一个值，但这意味着丢失数据。所以，需要在程序代码里做一些处理。</p><h4 id="版本向量"><a href="#版本向量" class="headerlink" title="版本向量"></a>版本向量</h4><p>使用单个版本号来捕获操作之间的依赖关系，但是当多个副本并发接受写入时，这是不够的。相反，除了对每个键使用版本号之外，还需要在<strong>每个副本</strong>中使用版本号。每个副本在处理写入时增加自己的版本号，并且跟踪从其他副本中看到的版本号。这个信息指出了要覆盖哪些值，以及保留哪些值作为兄弟。</p><p>所有副本的版本号集合称为<strong>版本向量（version vector）</strong>。这个想法的一些变体正在使用，但最有趣的可能是在Riak 2.0 中使用的<strong>分散版本矢量（dotted version vector）</strong></p><p>当读取值时，版本向量会从数据库副本发送到客户端，并且随后写入值时需要将其发送回数据库。 （Riak将版本向量编码为一个字符串，它称为<strong>因果上下文（causal context）</strong>）。版本向量允许数据库区分覆盖写入和并发写入。</p><p>另外，就像在单个副本的例子中，应用程序可能需要合并兄弟。版本向量结构确保从一个副本读取并随后写回到另一个副本是安全的。这样做可能会创建兄弟，但只要兄弟姐妹合并正确，就不会丢失数据。</p><h1 id="DDIA-第六章-分区"><a href="#DDIA-第六章-分区" class="headerlink" title="DDIA 第六章 分区"></a>DDIA 第六章 分区</h1><p>在不同节点上部署相同副本叫做复制，对于比较大的数据集，要进行分片/分区。分区通常与复制结合使用，使得每个分区的副本存储在多个节点上。</p><p>分区目标是将数据和查询负载均匀分布在各个节点上。如果每个节点公平分享数据和负载，那么理论上10个节点应该能够处理10倍的数据量和10倍的单个节点的读写吞吐量。</p><p>如果分区是不公平的，一些分区比其他分区有更多的数据或查询，我们称之为<strong>偏斜（skew）</strong>，因为偏斜导致的高负载分区叫做<strong>热点</strong>（hot spot）</p><h2 id="键值数据的分区"><a href="#键值数据的分区" class="headerlink" title="键值数据的分区"></a>键值数据的分区</h2><p>避免热点最简单的方法是将记录随机分配给节点以达到平均。但是它有一个缺点：读取一个特定的值时，不知道它在哪个节点上，所以需要并行查询所有节点</p><h3 id="按照键的范围来做分区"><a href="#按照键的范围来做分区" class="headerlink" title="按照键的范围来做分区"></a>按照键的范围来做分区</h3><p>一种分区方法是按照连续键的范围（比如A-Z）不一定均匀分布，会导致热点</p><h3 id="按照键的散列分区"><a href="#按照键的散列分区" class="headerlink" title="按照键的散列分区"></a>按照键的散列分区</h3><p>为了避免偏斜和热点，多数分布式数据库采用散列函数确定键的分区（前提是有个好的散列函数）</p><p>使用散列分区的缺点在弱范围查询能力</p><h2 id="负载倾斜和消除热点"><a href="#负载倾斜和消除热点" class="headerlink" title="负载倾斜和消除热点"></a>负载倾斜和消除热点</h2><p>哈希分区可以帮助减少热点，蛋依然会有极端情况下，大量读写操作请求到同一分区的情况</p><blockquote><p>e.g. 在社交媒体网站上，一个拥有数百万追随者的名人用户在做某事时可能会导致大量写入同一个键（键可能是名人的用户ID，或者人们正在评论的动作的ID）</p></blockquote><p>大多数数据系统无法自动补偿这种高度偏斜的负载，所以要在软件层面减少。一个简单的方法是在主键的开始或结尾添加一个随机数。只要一个两位数的十进制随机数就可以将主键分散为100种不同的主键,从而存储在不同的分区中。</p><h2 id="分片与次级索引"><a href="#分片与次级索引" class="headerlink" title="分片与次级索引"></a>分片与次级索引</h2><p>如果只通过主键访问记录，可以通过该键确定分区，如果涉及次级索引会更加复杂。有两种用次级索引进行数据库分区的方法：<strong>基于文档的分区</strong>和<strong>基于关键词的分区</strong></p><h3 id="按文档的二级索引"><a href="#按文档的二级索引" class="headerlink" title="按文档的二级索引"></a>按文档的二级索引</h3><p>按文档ID来做分区，其中的字段来作为二级索引，当有新的数据，数据库分区会自动添加到索引条目的ID文档里。</p><p>这种方法里每个分区完全独立，维护自己的二级索引（本地索引）要查询特定字段的数据，要将查询发送到所有分区，合并返回的结果，这个方法叫<strong>分散/聚集（scatter/gather）</strong>，可能会使二级索引上的读取查询相当昂贵。而且也可能放大尾部延迟</p><h3 id="根据关键词-Term-的二级索引"><a href="#根据关键词-Term-的二级索引" class="headerlink" title="根据关键词(Term)的二级索引"></a>根据关键词(Term)的二级索引</h3><p>构建一个覆盖所有分区的全局索引，可以通过<strong>关键词</strong>本身或者它的散列进行索引分区。根据它本身分区对于范围扫描非常有用。</p><p>理想情况下，索引总是最新的，但是实践里全局二级索引的更新通常是异步的</p><h2 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h2><p>将数据和请求（统称负载）从一个节点移动到另一个节点的过程叫做<strong>再平衡（reblancing）</strong>平衡后通常能保证：</p><ul><li>平衡后 负载平衡的共享</li><li>再平衡期间可以接受读写</li><li>移动必要数据减少网络和IO负载</li></ul><h3 id="平衡策略"><a href="#平衡策略" class="headerlink" title="平衡策略"></a>平衡策略</h3><h4 id="反面教材：-hash-mod-N"><a href="#反面教材：-hash-mod-N" class="headerlink" title="反面教材： hash mod N"></a>反面教材： hash mod N</h4><p>如果单纯进行哈希散列分布，那么最初10个节点，键存储在6上，11个节点就要移动到3，到了12个节点就要移动到0，重新平衡的成本较高</p><h4 id="固定数量分区"><a href="#固定数量分区" class="headerlink" title="固定数量分区"></a>固定数量分区</h4><p>一个相当简单的解决方案：创建比节点更多的分区，并为每个节点分配多个分区。如果一个节点被添加到集群中，新节点可以从当前每个节点中<strong>窃取</strong>一些分区，直到分区再次公平分配。</p><p>这样甚至可以解决硬件不匹配问题，但是太大的固定数量分区也有管理开销，太小的分区跟不上数据集增长会继续有扩展性问题</p><h3 id="动态分区"><a href="#动态分区" class="headerlink" title="动态分区"></a>动态分区</h3><p>按键的范围进行分区的数据库（如HBase和RethinkDB）会动态创建分区。当分区增长到超过配置的大小时（在HBase上，默认值是10GB），会被分成两个分区，每个分区约占一半的数据。与之相反，如果大量数据被删除并且分区缩小到某个阈值以下，则可以将其与相邻分区合并。此过程与B树顶层发生的过程类似。</p><p>数据集开始时很小，所有写入操作都必须由单个节点处理，而其他节点则处于空闲状态。为了解决这个问题，HBase和MongoDB允许在一个空的数据库上配置一组初始分区（这被称为<strong>预分割（pre-splitting）</strong>）</p><h4 id="按节点比例分区"><a href="#按节点比例分区" class="headerlink" title="按节点比例分区"></a>按节点比例分区</h4><p>通过动态分区，分区的数量与数据集的大小成正比，固定数量的分区，每个分区的大小和数据集的大小成正比，这两种情况下分区的数量和节点的数量无关</p><p>Cassandra和Ketama使用的第三种方法是使分区数与节点数成正比。也就是每个节点具有固定数量的分区，在这种情况下，每个分区的大小与数据集大小成比例地增长，而节点数量保持不变，但是当增加节点数时，分区将再次变小。</p><p>当一个新节点加入集群时，它随机选择固定数量的现有分区进行拆分，然后占有这些拆分分区中每个分区的一半，同时将每个分区的另一半留在原地。</p><h2 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h2><p>现在我们已经将数据集分割到多个机器上运行的多个节点上。但是仍然存在一个问题：当Client想要发出请求时，如何知道要连接哪个节点？需要连接哪个IP地址和端口号？</p><p>这个问题可以概括为**服务发现(service discovery)**，它不仅限于数据库。任何可通过网络访问的软件都有这个问题，特别是如果它的目标是高可用性（在多台机器上运行冗余配置）</p><p>概括来说，这个问题有几种不同的方案:</p><ol><li>允许Client联系任何节点（例如，通过<strong>循环策略的负载均衡（Round-Robin Load Balancer）</strong>）。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求;否则，它将请求转发到适当的节点，接收回复并传递给客户端。</li><li>首先将所有来自客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求；它仅负责分区的负载均衡。</li><li>要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，而不需要任何中介。</li></ol><p>以上所有情况中的关键问题是：如何了解分区-节点之间的分配关系变化？</p><p>许多分布式数据系统都依赖于一个独立的协调服务进行集群管理或配置管理，如ZooKeeper来跟踪集群元数据，Cassandra和Riak采取不同的方法：他们在节点之间使用<strong>流言协议（gossip protocol）</strong>来传播群集状态的变化。</p><h1 id="DDIA-第七章节-事务"><a href="#DDIA-第七章节-事务" class="headerlink" title="DDIA 第七章节 事务"></a>DDIA 第七章节 事务</h1><p>在数据系统功能中，出错是很常见的，包括硬件软件网络的故障和并发导致的竞争等情况</p><p>为了实现可靠性，必须要考虑所有可能出错的情况，并通过大量测试保证方案可用</p><p><strong>事务（transaction）</strong>一直是简化这些问题的首选机制。事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式。整个事务要么成功（<strong>提交（commit）</strong>）要么失败（<strong>中止（abort）</strong>，<strong>回滚（rollback）</strong>）</p><p>但是事务本身并不是自然的，而是为了简化应用编程模型创建的，所以也并不适用于全部清空。</p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>事务所提供的安全保证，通常由众所周知的首字母缩略词ACID来描述，ACID代表<strong>原子性（Atomicity）</strong>，<strong>一致性（Consistency）</strong>，<strong>隔离性（Isolation）</strong>和<strong>持久性（Durability）</strong>。</p><p>实际上不同数据库的ACID实现并不一样，比如围绕着隔离性的含义有许多含糊不清，在细节上有更多未统一。（不符合ACID标准的系统有时被称为BASE，它代表<strong>基本可用性（Basically Available）</strong>，<strong>软状态（Soft State）</strong>和<strong>最终一致性（Eventual consistency）</strong>）</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>一般来说，原子是指不能分解成更小的东西。</p><p>ACID的原子性描述了，如果进行多次写入，但在过程中出现故障的情况。则该事务将被中止，并且数据库必须丢弃或撤消该事务中迄今为止所做的任何写入。</p><p>ACID原子性的定义特征是：<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。</strong>或许<strong>可中止性（abortability）</strong>是更好的术语</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一致性是个很宽泛的概念，在ACID上下文中，<strong>一致性</strong>是指数据库在应用程序的特定概念中处于“良好状态”。</p><p>ACID一致性的概念是，<strong>对数据的一组特定陈述必须始终成立</strong>。即<strong>不变量（invariants）</strong>一致性的这种概念取决于应用程序对不变量的观念，应用程序负责正确定义它的事务，并保持一致性。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>ACID意义上的隔离性意味着，<strong>同时执行的事务是相互隔离的</strong>，传统的数据库教科书将隔离性形式化为<strong>可序列化（Serializability）</strong>，这意味着每个事务可以假装它是唯一在整个数据库上运行的事务。以此确保事务提交时看上去是按照顺序运行（尽管实际上可能是并发的）。</p><p>实践中因为性能问题，可序列化隔离较少，在Oracle中有一个名为“可序列化”的隔离级别，但实际上它实现了一种叫做<strong>快照隔离</strong>，这是一种比可序列化更弱的保证</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p><strong>持久性</strong>是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。为了提供持久性保证，数据库必须等到这些写入或复制完成后，才能报告事务成功提交。</p><h2 id="单对象和多对象操作"><a href="#单对象和多对象操作" class="headerlink" title="单对象和多对象操作"></a>单对象和多对象操作</h2><h3 id="单对象写入"><a href="#单对象写入" class="headerlink" title="单对象写入"></a>单对象写入</h3><p>当单个对象发生改变时，原子性和隔离也是适用的。向数据库写入一个 20 KB的 JSON文档：</p><ul><li>如果在发送10 KB之后网络连接中断，数据库是否存储了不可解析的10KB JSON？</li><li>如果在数据库正在覆盖磁盘上的前一个值的过程中断电，是否最终将新旧值拼接在一起？</li><li>如果另一个客户端在写入过程中读取该文档，是否会看到部分更新的值？</li></ul><p>这些问题非常让人头大，所以存储引擎一个几乎普遍的目标是：对单节点上的单个对象（例如键值对）上提供原子性和隔离性。原子性可以通过使用日志来实现崩溃恢复，并且可以使用每个对象上的锁来实现隔离</p><p>一些更复杂的原子操作，比如自增，需要CAS（Compare and set 比较和设置），当值没有被其他人修改过才允许执行写操作。</p><p>这些单对象操作很有用，因为它们可以防止在多个客户端尝试同时写入同一个对象时丢失更新。但它们不是通常意义上的事务。CAS以及其他单一对象操作被称为“轻量级事务”，甚至出于营销目的被称为“ACID”，但是这个术语是误导性的。事务通常被理解为，<strong>将多个对象上的多个操作合并为一个执行单元的机制</strong></p><h3 id="多对象事务的需求"><a href="#多对象事务的需求" class="headerlink" title="多对象事务的需求"></a>多对象事务的需求</h3><p>许多分布式数据存储已经放弃了多对象事务，因为多对象事务很难跨分区实现，而且不符合需要高可用性或高性能的场景</p><p>有很多场景需要协调写入多个不同对象：</p><ul><li>关系型数据库中的外键</li><li>文档型数据库更新多个文档</li><li>具有二级索引的数据库里更新索引</li></ul><p>这些应用仍然可以在没有事务的情况下实现。然而，<strong>没有原子性，错误处理就要复杂得多，缺乏隔离性，就会导致并发问题</strong>。</p><h3 id="错误处理和终止"><a href="#错误处理和终止" class="headerlink" title="错误处理和终止"></a>错误处理和终止</h3><p>ACID数据库基于这样的哲学：如果数据库有违反其原子性，隔离性或持久性的危险，则宁愿完全放弃事务（宁为玉碎，不为瓦全）</p><p>但是一些数据库保持乐观的态度，采取“尽力而为”的想法（比如无主复制的数据存储）处理错误的一个常见的方法就是重试</p><p>尽管重试一个中止的事务是一个简单而有效的错误处理机制，但它并不完美：</p><ul><li>如果事务实际上成功了，但是客户端认为提交失败了，那么重试事务会导致事务被执行两次（类似浏览器刷新和POST请求）解决这个还要一个额外的应用级除重机制。</li><li>如果因为负载过大造成错误，重试事务将使问题变得更糟。为了避免这种死循环，可以限制重试次数，使用指数退避算法。</li><li>仅在临时性错误后才值得重试。在发生永久性错误后重试是毫无意义的。</li><li>如果客户端进程在重试中失效，任何试图写入数据库的数据都将丢失。</li></ul><h2 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h2><p>两个事务不触及相同数据就可以安全并行，如果涉及修改相同数据，就会有并发竞争问题。</p><p>并发BUG难以通过测试找到，也比较难推理复现，出于这个原因，数据库提供<strong>事务隔离（transaction isolation）</strong>来隐藏应用程序开发者的并发问题。</p><p><strong>可序列化（serializable）</strong>的隔离等级意味着数据库保证事务的效果与连续运行（即一次一个，没有任何并发）是一样的。但是因为性能损失，许多数据库不支持，所以通常用更弱的隔离级别来防止一部分并发问题。</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>最基本的事务隔离级别是<strong>读已提交（Read Committed）</strong>，它提供了两个保证：</p><ol><li>从数据库读时，只能看到已提交的数据（没有<strong>脏读（dirty reads）</strong>）。</li><li>写入数据库时，只会覆盖已经写入的数据（没有<strong>脏写（dirty writes）</strong>）。</li></ol><h4 id="没有脏读"><a href="#没有脏读" class="headerlink" title="没有脏读"></a>没有脏读</h4><p>读取到了事务未提交的数据叫做脏读，原因有：</p><ol><li>前后数据可能不一致，用户会困惑，应用程序也可能做出错误操作</li><li>如果事务需要回滚，就读取了本不存在的数据</li></ol><h4 id="没有脏写"><a href="#没有脏写" class="headerlink" title="没有脏写"></a>没有脏写</h4><p>当两个事务同时更新相同对象，而先写入的值尚未进行事务提交，后面的写入覆盖一个尚未提交的值叫做脏写。防止脏写通常是延迟第二次写入，直到第一次写入事务提交或中止为止。</p><p>通过防止脏写会避免一些并发问题</p><h4 id="实现读已提交"><a href="#实现读已提交" class="headerlink" title="实现读已提交"></a>实现读已提交</h4><p>读已提交是一个比较流行的隔离级别，也是大多数数据库的默认设置。最常见的情况是，数据库通过使用<strong>行锁（row-level lock）</strong>来防止脏写</p><p>防止脏读的方法一种是使用相同的锁，但是要求读锁的办法在实践中效果并不好。会损失只读事务的响应时间，并且不利于可操作性，所以大多数数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值</p><h3 id="快照隔离和可重复读"><a href="#快照隔离和可重复读" class="headerlink" title="快照隔离和可重复读"></a>快照隔离和可重复读</h3><p>如果在事务执行中读取数据，会是旧数据，其实只要等待一段时间再读就会是新数据。有些情况不能容忍这种暂时性的不一致：</p><ol><li>备份</li></ol><p>备份可能需要数个小时，但数据库依然接受写入，所以备份可能会是一部分旧的一部分新的</p><ol><li>分析查询和完整性检查</li></ol><p>要扫描大部分的数据库（分析查询）或是执行定期完整性检查，如果这些查询在不同时间点观察数据库的不同部分，则可能会返回毫无意义的结果。</p><p><strong>快照隔离（snapshot isolation）</strong>是这个问题最常见的解决方案。想法是，每个事务都从数据库的<strong>一致快照（consistent snapshot）</strong>中读取，也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据。</p><p>快照隔离对长时间运行的只读查询（如备份和分析）非常有用</p><h4 id="实现快照隔离"><a href="#实现快照隔离" class="headerlink" title="实现快照隔离"></a>实现快照隔离</h4><p>与读取提交的隔离类似，快照隔离的实现通常使用写锁来防止脏写，读取不需要任何锁定。</p><p>快照隔离的一个关键原则是：<strong>读不阻塞写，写不阻塞读</strong>。这允许数据库在处理一致性快照上的长时间查询时，可以正常地同时处理写入操作。且两者间没有任何锁定争用。为了实现快照隔离，需要保留一个对象的多个版本，这项技术叫做<strong>多版本并发控制（MVCC, multi-version concurrentcy control）</strong>。</p><h2 id="防止丢失更新"><a href="#防止丢失更新" class="headerlink" title="防止丢失更新"></a>防止丢失更新</h2><p><strong>读已提交</strong>和<strong>快照隔离</strong>级别，主要保证了<strong>只读事务在并发写入时</strong>可以看到什么。两个事务并发写还有其他冲突的发生，比如<strong>丢失更新（lost update）</strong>问题</p><p>如果有两个事务都在做读取-修改-写入，那么前一个的修改可能会更新，这在诸如计数器 协同编辑的场景会比较突出</p><h3 id="原子写"><a href="#原子写" class="headerlink" title="原子写"></a>原子写</h3><p>许多数据库提供了原子更新操作，从而消除了在应用程序代码中执行读取-修改-写入序列的需要。原子操作通常通过在读取对象时，获取其上的排它锁来实现。以便更新完成之前没有其他事务可以读取它。这种技术有时被称为<strong>游标稳定性（cursor stability）</strong>，另一个选择是简单地强制所有的原子操作在单一线程上执行。</p><h3 id="显式锁定"><a href="#显式锁定" class="headerlink" title="显式锁定"></a>显式锁定</h3><p>防止丢失更新的另一个选择是让应用程序显式地锁定将要更新的对象，然后应用程序可以执行读取-修改-写入序列，如果有其他事务要读取同一个对象则强制等待，直到第一个<strong>读取-修改-写入序列</strong>完成。</p><h3 id="自动检测丢失的更新"><a href="#自动检测丢失的更新" class="headerlink" title="自动检测丢失的更新"></a>自动检测丢失的更新</h3><p>原子操作和锁是通过强制<strong>读取-修改-写入序列</strong>按顺序发生，来防止丢失更新。另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其<strong>读取-修改-写入序列</strong>。</p><p>数据库可以结合快照隔离高效地执行此检查。它不需要在程序里引入锁代码就可以达成，更不容易出错</p><h3 id="比较并设置（CAS）"><a href="#比较并设置（CAS）" class="headerlink" title="比较并设置（CAS）"></a>比较并设置（CAS）</h3><p>只有当前值从上次读取时一直未改变，才允许更新发生。</p><h3 id="冲突解决和复制"><a href="#冲突解决和复制" class="headerlink" title="冲突解决和复制"></a>冲突解决和复制</h3><p>锁和CAS操作假定有一个最新的数据副本。但是多主或无主复制的数据库通常允许多个写入并发执行，保证不了有一份统一的最新副本，所以基于锁或CAS操作的技术不适用于这种情况。</p><p>这种复制数据库中的一种常见方法是允许并发写入创建多个冲突版本的值（也称为兄弟），并使用应用代码或特殊数据结构在事实发生之后解决和合并这些版本。</p><h3 id="写入偏差和幻读"><a href="#写入偏差和幻读" class="headerlink" title="写入偏差和幻读"></a>写入偏差和幻读</h3><p><strong>写偏差</strong>。它既不是<strong>脏写</strong>，也不是<strong>丢失更新</strong>，因为是两个事务同时更新两个不同的对象，但是数据库使用快照隔离，两个事务都进行到下一阶段，却有逻辑上的不正常（比如A B同时定会议室）</p><p>写偏差是一个比较难的问题，单对象的原子操作不起作用，一些自动检测丢失和快照检测实现也没用</p><p>为了确保不会遇到冲突，可能又要可序列化的隔离级别。</p><h3 id="导致写入偏差的幻读"><a href="#导致写入偏差的幻读" class="headerlink" title="导致写入偏差的幻读"></a>导致写入偏差的幻读</h3><p>所有写偏差都遵循类似模式：</p><ol><li>SELECT查找合适的行，检查是否符合要求</li><li>按照查询结果来决定代码是否继续</li><li>写入，提交事务</li></ol><p>但是写偏差的问题在于，一个事务中的写入是会改变另一个事务的搜索查询的结果的，这种情况称为<strong>幻读</strong>，快照隔离避免了只读查询中幻读，但是读写事务里就会出现写偏差</p><h3 id="物化冲突"><a href="#物化冲突" class="headerlink" title="物化冲突"></a>物化冲突</h3><p>如果采用锁机制来避免幻读：</p><p>在会议室预订的场景中，可以想象创建一个关于时间槽和房间的表。锁定表中与所需房间和时间段对应的行，这个表不是用来存储预定相关信息，而是事实上的一组锁，用来防止同一会议室同一时间范围的预定</p><p>物化冲突应被视为最后的手段。在大多数情况下。<strong>可序列化（Serializable）</strong>的隔离级别是更可取的。</p><h2 id="可序列化"><a href="#可序列化" class="headerlink" title="可序列化"></a>可序列化</h2><p><strong>读已提交</strong>和<strong>快照隔离</strong>级别会阻止某些竞争条件，但不会阻止另一些。如果遇到写偏差和幻读就会很棘手（从20世纪70年代起就是这样）如果要解决这个问题，大多数回答是使用<strong>可序列化（serializable）</strong>的隔离级别</p><p><strong>可序列化（Serializability）</strong>隔离通常被认为是最强的隔离级别。它保证即使事务可以并行执行，最终的结果也是一样的，就好像它们是挨个连续执行一样。因此数据库保证防止<strong>所有</strong>可能的竞争条件。</p><p>目前大多数提供可序列化的数据库都使用了三种技术：</p><ol><li>字面意义上地串行顺序执行事务</li><li><strong>两相锁定（2PL, two-phase locking）</strong>（当前唯一实践）</li><li>乐观并发控制技术，例如<strong>可序列化的快照隔离（serializable snapshot isolation）</strong></li></ol><h3 id="真串行执行"><a href="#真串行执行" class="headerlink" title="真串行执行"></a>真串行执行</h3><p>最简单方法就是完全不要并发：在单个线程上按顺序一次只执行一个事务。这似乎是一个明显的主意，但数据库设计人员只是在2007年左右才决定，因为在那个时候，RAM的成本降低了，许多场景现在都可以将完整的活跃数据集保存在内存中。而且大多数OLTP事务通常很短，而且只进行少量的读写操作，但是长时间运行的分析查询是只读的，可以串行执行在快照隔离上</p><h4 id="在存储过程中封装事务"><a href="#在存储过程中封装事务" class="headerlink" title="在存储过程中封装事务"></a>在存储过程中封装事务</h4><p>几乎所有的OLTP应用程序都避免在事务中等待交互式的用户输入，以此来保持事务的简短。交互式的事务方式中，应用程序和数据库之间的网络通信耗费了大量的时间，吞吐量会非常差。出于这个原因，具有单线程串行事务处理的系统不允许交互式的多语句事务。应用程序必须提前将整个事务代码作为存储过程提交给数据库。</p><h4 id="存储过程的优点和缺点"><a href="#存储过程的优点和缺点" class="headerlink" title="存储过程的优点和缺点"></a>存储过程的优点和缺点</h4><ul><li>每个数据库厂商都有自己的存储过程语言，陈旧且简陋，没有完善的生态</li><li>在数据库中运行的管理困难，调试困难，版本控制和部署起来也更为尴尬，更难测试</li><li>数据库通常比应用服务器对性能敏感的多，数据库中一个写得不好的存储过程会造成更大麻烦</li></ul><p>存储过程与内存存储使得在单个线程上执行所有事务变得可行。由于不需要等待I/O，且避免了并发控制机制的开销，它们可以在单个线程上实现相当好的吞吐量。</p><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4><p>顺序执行使并发控制很简单，但是对于写入吞吐量较高的应用，单线程事务处理器可能成为一个严重的瓶颈。</p><p>为了扩展到多个CPU核心和多个节点，可以对数据进行分区，，对于需要访问多个分区的事务，数据库必须在所有分区间协调事务。存储过程需要跨越所有分区锁定执行，以确保整个系统的可串行性。</p><h3 id="两阶段锁定（2PL）"><a href="#两阶段锁定（2PL）" class="headerlink" title="两阶段锁定（2PL）"></a>两阶段锁定（2PL）</h3><p>大约30年来，在数据库中只有一种广泛使用的序列化算法：<strong>两阶段锁定（2PL，two-phase locking）</strong></p><p>两阶段锁定类似锁，但要求更强：只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要<strong>独占访问（exclusive access）</strong>权限：</p><ul><li>如果事务A读取了一个对象，并且事务B想要写入该对象，那么B必须等到A提交或中止才能继续。 （这确保B不能在A底下意外地改变对象。）</li><li>如果事务A写入了一个对象，并且事务B想要读取该对象，则B必须等到A提交或中止才能继续。</li></ul><p>在2PL中，写入不仅会阻塞其他写入，也会阻塞读，反之亦然。相对的，快照隔离里读不阻塞写，写也不阻塞读。因为2PL提供了可序列化的性质，它可以防止早先讨论的所有竞争条件，包括丢失更新和写入偏差。</p><h4 id="实现两阶段锁"><a href="#实现两阶段锁" class="headerlink" title="实现两阶段锁"></a>实现两阶段锁</h4><p>读与写的阻塞是通过为数据库中每个对象添加锁来实现的。锁可以处于<strong>共享模式（shared mode）</strong>或<strong>独占模式（exclusive mode）</strong>锁使用如下：</p><ul><li>若事务要读取对象，则须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务已经在对象上持有排它锁，则这些事务必须等待。</li><li>若事务要写入一个对象，它必须首先以独占模式获取该锁。没有其他事务可以同时持有锁，所以如果对象上存在任何锁，该事务必须等待。</li><li>如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得排他锁相同。</li><li>事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是“两阶段”这个名字的来源：第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁。</li></ul><p>由于锁的使用过多，因此可能会发生死锁情况</p><h4 id="两阶段锁的性能"><a href="#两阶段锁的性能" class="headerlink" title="两阶段锁的性能"></a>两阶段锁的性能</h4><p>两阶段锁定的巨大缺点，是其性能问题。两阶段锁定下的事务吞吐量与查询响应时间要比弱隔离级别下要差得多。一部分是由于获取和释放所有这些锁的开销，但更重要的是由于并发性的降低</p><p>运行2PL的数据库可能具有相当不稳定的延迟，如果在工作负载中存在争用，那么可能高百分位点处的响应会非常的慢，只需要一个缓慢的事务就能把系统的其他部分拖慢甚至迫使系统停机</p><p>如果出现频繁死锁导致终止，也意味着极大的浪费</p><h4 id="谓词锁"><a href="#谓词锁" class="headerlink" title="谓词锁"></a>谓词锁</h4><p>幻读是一个事务改变另一个事务的搜索查询的结果。具有可序列化隔离级别的数据库必须防止幻读。用锁来解决幻读的问题，从概念上讲，我们需要一个<strong>谓词锁（predicate lock）</strong>类似于共享/排它锁，但不属于特定的对象，它属于所有符合某些搜索条件的对象，如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">SELECT</span> * FROM bookings<br><span class="hljs-attribute">WHERE</span> room_id = <span class="hljs-number">123</span> AND<br><span class="hljs-attribute">end_time</span> &gt; &#x27;<span class="hljs-number">2018</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>&#x27; AND<br><span class="hljs-attribute">start_time</span> &lt; &#x27;<span class="hljs-number">2018</span>-<span class="hljs-number">01</span>-<span class="hljs-number">01</span> <span class="hljs-number">13</span>:<span class="hljs-number">00</span>&#x27;;Copy<br></code></pre></td></tr></table></figure><ul><li>如果事务A想要读取匹配某些条件的对象，就像在这个<code>SELECT</code>查询中那样，它必须获取查询条件上的<strong>共享谓词锁（shared-mode predicate lock）</strong>。如果另一个事务B持有任何满足这一查询条件对象的排它锁，那么A必须等到B释放它的锁之后才允许进行查询。</li><li>如果事务A想要插入，更新或删除任何对象，则必须首先检查旧值或新值是否与任何现有的谓词锁匹配。如果事务B持有匹配的谓词锁，那么A必须等到B已经提交或中止后才能继续。</li></ul><p>如果两阶段锁定包含谓词锁，则数据库将阻止所有形式的写入偏差和其他竞争条件，因此其隔离实现了可串行化。</p><h4 id="索引范围锁"><a href="#索引范围锁" class="headerlink" title="索引范围锁"></a>索引范围锁</h4><p>不幸的是谓词锁性能不佳：<strong>如果活跃事务持有很多锁，检查匹配的锁会非常耗时。</strong>因此，大多数使用2PL的数据库实际上实现了索引范围锁（也称为<strong>间隙锁（next-key locking）</strong>），一个简化的近似版谓词锁</p><p>在房间预订数据库中，如果在<code>room_id</code>列上有一个索引，或者在<code>start_time</code>和<code>end_time</code>上有索引：</p><ul><li><code>room_id</code>上有索引：数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索123号房间用于预订。</li><li>使用基于时间的索引来查找现有预订，可以将共享锁附加到该索引中的一系列值，指示事务已经将12:00~13:00时间段标记为用于预定。</li></ul><p>如果另一个事务想要插入，更新或删除同一个房间和/或重叠时间段的预订，则它将不得不更新索引的相同部分。在这样做的过程中，它会遇到共享锁，它将被迫等到锁被释放。</p><p>索引范围锁并不像谓词锁那样精确，但是由于它们的开销较低，所以是一个很好的折衷。</p><h3 id="序列化快照隔离（SSI）"><a href="#序列化快照隔离（SSI）" class="headerlink" title="序列化快照隔离（SSI）"></a>序列化快照隔离（SSI）</h3><p>一方面，我们实现了性能不好（2PL）或者扩展性不好（串行执行）的可序列化隔离级别。另一方面，我们有性能良好的弱隔离级别，但容易出现各种竞争条件，序列化的隔离级别和高性能是不可兼得的吗？</p><p>一个称为<strong>可序列化快照隔离（SSI, serializable snapshot isolation）</strong>的算法是非常有前途的。它提供了完整的可序列化隔离级别，但与快照隔离相比只有只有很小的性能损失。</p><h4 id="悲观与乐观的并发控制"><a href="#悲观与乐观的并发控制" class="headerlink" title="悲观与乐观的并发控制"></a>悲观与乐观的并发控制</h4><p>两阶段锁是一种所谓的<strong>悲观并发控制机制（pessimistic）</strong>：如果有事情可能出错，最好等到情况安全后再做任何事情。这就像互斥，用于保护多线程编程中的数据结构。串行执行可以称为悲观到了极致：在事务持续期间，每个事务对整个数据库具有排它锁，作为对悲观的补偿，我们让每笔事务执行得非常快，所以只需要短时间持有“锁”。</p><p>相比之下，<strong>序列化快照隔离</strong>是一种<strong>乐观（optimistic）</strong>的并发控制技术。乐观意味着，如果存在潜在的危险也不阻止事务，而是继续执行事务，希望一切都会好起来。当一个事务想要提交时，数据库检查是否有什么不好的事情发生（即隔离是否被违反）；如果是的话，事务将被中止，并且必须重试。只有可序列化的事务才被允许提交。</p><p>乐观并发控制是一个古老的想法，如果存在很多事务试图访问相同的对象，则表现不佳，会导致很大一部分事务被终止，但是如果系统还有足够容量，乐观的并发控制技术往往比悲观的要好。</p><p>SSI基于快照隔离，事务中的所有读取都是来自数据库的一致性快照，SSI添加了一种算法来检测写入之间的序列化冲突，并确定要中止哪些事务。</p><h4 id="基于过时前提的决策"><a href="#基于过时前提的决策" class="headerlink" title="基于过时前提的决策"></a>基于过时前提的决策</h4><p>写偏差的出现：事务基于一个<strong>前提（premise）</strong>采取行动，之后当事务要提交时，原始数据可能已经改变——前提可能不再成立。</p><p>当应用程序进行查询时，数据库需要假设任何对该结果集的变更都可能会使该事务中的写入变得无效。也就是事务中的查询与写入可能存在因果依赖。为了提供可序列化的隔离级别，如果事务在过时的前提下执行操作，数据库必须能检测到这种情况，并中止事务。</p><p>数据库如何知道查询结果是否可能已经改变？有两种情况需要考虑：</p><ul><li>检测对旧MVCC对象版本的读取（读之前存在未提交的写入）</li><li>检测影响先前读取的写入（读之后发生写入）</li></ul><h4 id="检测旧MVCC读取"><a href="#检测旧MVCC读取" class="headerlink" title="检测旧MVCC读取"></a>检测旧MVCC读取</h4><p>快照隔离通常是通过多版本并发控制实现的，一个事务从MVCC数据库中的一致快照读时，它将忽略取快照时尚未提交的任何其他事务所做的写入。为了防止读取一致性快照时被忽略的写入已经生效，数据库需要跟踪一个事务由于MVCC可见性规则而忽略另一个事务的写入。当事务想要提交时，数据库检查是否有任何被忽略的写入现在已经被提交。如果是这样，事务必须中止。</p><h4 id="检测影响之前的读取的写入"><a href="#检测影响之前的读取的写入" class="headerlink" title="检测影响之前的读取的写入"></a>检测影响之前的读取的写入</h4><p>第二种情况要考虑的是另一个事务在读取数据之后修改数据，索引范围锁允许数据库锁定与某个搜索查询匹配的所有行的访问权，这个信息只需要保留一段时间：在一个事务完成（提交或中止）之后，所有的并发事务完成之后，数据库就可以忘记它读取的数据了。</p><p>当事务写入数据库时，它必须在索引中查找最近曾读取受影响数据的其他事务。这个过程类似于在受影响的键范围上获取写锁，但锁并不会阻塞事务到其他事务完成，而是像一个引线一样只是简单通知其他事务：你们读过的数据可能不是最新的。</p><h4 id="可序列化的快照隔离的性能"><a href="#可序列化的快照隔离的性能" class="headerlink" title="可序列化的快照隔离的性能"></a>可序列化的快照隔离的性能</h4><p>果数据库详细地跟踪每个事务的活动（细粒度），那么可以准确地确定哪些事务需要中止，但是粒度较细，记录开销会比较大，较粗粒度的跟踪有更好的速度，但可能让更多必要的事务终止。</p><p>与两阶段锁定相比，可序列化快照隔离的最大优点是一个事务不需要阻塞等待另一个事务所持有的锁。就像在快照隔离下一样，写不会阻塞读，反之亦然。这种设计原则使得查询延迟更可预测，变量更少。特别是，只读查询可以运行在一致的快照上，而不需要任何锁定，这对于读取繁重的工作负载非常有吸引力。</p><p>与串行执行相比，可序列化快照隔离并不局限于单个CPU核的吞吐量，事务也可以在保证可序列化隔离等级的同时读写多个分区中的数据。</p><p>中止率显著影响SSI的整体表现。例如，长时间读取和写入数据的事务很可能会发生冲突并中止，因此SSI要求同时读写的事务尽量短（只读长事务可能没问题）。对于慢事务，SSI可能比两阶段锁定或串行执行更不敏感。</p><h1 id="DDIA-第八章节-分布式系统的麻烦"><a href="#DDIA-第八章节-分布式系统的麻烦" class="headerlink" title="DDIA 第八章节 分布式系统的麻烦"></a>DDIA 第八章节 分布式系统的麻烦</h1><p>使用分布式系统与在一台计算机上编写软件有着根本的区别，之前的章节里讨论的各种各样的问题和解决方法依旧不能cover分布式系统的情况。</p><p>在单机情况下，硬件软件出现问题，那么结果要么是继续保持功能完好，要么完全失效。但是运行在多台计算机上的分布式软件，系统模型不再是单机理想化模型，<strong>部分失效（partial failure）</strong>和部分失效的<strong>不确定性（nonderterministic）</strong>会让分布式系统难以工作</p><h2 id="云计算与超级计算机"><a href="#云计算与超级计算机" class="headerlink" title="云计算与超级计算机"></a>云计算与超级计算机</h2><p>如何构建大型计算系统：</p><ul><li>规模的一端是高性能计算（HPC）领域。具有数千个CPU的超级计算机通常用于计算密集型科学计算任务，如天气预报或分子动力学。</li><li>另一个极端是<strong>云计算（cloud computing）</strong>，通常与多租户数据中心，连接IP网络的商品计算机（通常是以太网），弹性/按需资源分配以及计量计费等相关联。</li><li>传统企业数据中心位于这两个极端之间。</li></ul><p>超级计算机更像是一个单节点计算机，通过让部分失败升级成完全失败来进行处理。但是实现互联网服务的系统上，通常有更高的可用性和低延迟要求。</p><p>如果要使分布式系统工作，就必须接受部分故障的可能性，在软件中建立容错机制。我们需要从不可靠的组件构建一个可靠的系统。 在分布式系统中，怀疑，悲观和偏执狂是值得的。</p><h2 id="不可靠的网络"><a href="#不可靠的网络" class="headerlink" title="不可靠的网络"></a>不可靠的网络</h2><p>我关注的分布式系统是无共享的系统，即通过网络连接的一堆机器。网络是这些机器可以通信的唯一途径</p><p>以太网中的大多数内部网络都是<strong>异步分组网络（asynchronous packet networks）</strong>，很多事情可能会出错，包括丢包、阻塞、节点宕机、响应丢失等等。处理这些问题的通常方法是超时，在一段时间之后放弃等待，并且认为响应不会到达。</p><h3 id="检测故障"><a href="#检测故障" class="headerlink" title="检测故障"></a>检测故障</h3><p>许多系统需要自动检测故障节点。如：</p><ul><li>负载平衡器需要停止向已宕机的节点转发请求（<strong>移出轮询列表（out of rotation）</strong>）。</li><li>在单主复制功能的分布式数据库中，如果主库失效，则需要将从库之一升级为新主库</li></ul><p>但是如何判断一个节点是否能够工作也是比较难确定的，所以关于远程节点关闭的快速反馈很有用，但是我们更需要应用程序本身的积极响应。如果出了问题，要假设没有收到任何回应，重试几次，等待超时过期没有响应才能宣布节点已死亡</p><h3 id="超时和无穷的延迟"><a href="#超时和无穷的延迟" class="headerlink" title="超时和无穷的延迟"></a>超时和无穷的延迟</h3><p>如果超时是检测故障的唯一可靠方法，那么超时应该等待多久？没有答案。</p><p>长时间超时意味着长时间等待，直到一个节点被宣告死亡（在这段时间内，用户必须等待，或者看到错误信息）。如果过早宣布节点死亡，将任务交由下一个节点接管，那么很可能执行两次。而如果系统处于高负荷状态，节点没有死亡而是因为过载导致响应缓慢，转移到其他节点的过程会造成<strong>级联失效（cascading failure）</strong></p><p>很难规定一个最大延迟，因为异步网络具有无限的延迟，或者只是一个瞬间高峰就可以打挂系统</p><h3 id="网络拥塞与排队"><a href="#网络拥塞与排队" class="headerlink" title="网络拥塞与排队"></a>网络拥塞与排队</h3><p>在公共云和多租户数据中心中，资源被许多客户共享：网络链接和交换机，甚至每个机器的网卡和CPU（在虚拟机上运行时）。由于无法控制或了解其他客户对共享资源的使用情况，如果附近的某个人正在使用大量资源，则网络延迟可能会发生剧烈抖动。更好的做法是系统不是使用配置的常量超时时间，而是连续测量响应时间及其变化（抖动），并根据观察到的响应时间分布自动调整超时时间。</p><h3 id="同步网络-vs-异步网络"><a href="#同步网络-vs-异步网络" class="headerlink" title="同步网络 vs 异步网络"></a>同步网络 vs 异步网络</h3><p>电话网络中的电路与TCP连接有很大不同：电路是固定数量的预留带宽，在电路建立时没有其他人可以使用。数据中心网络和互联网的以太网和IP用的是是<strong>分组交换协议</strong>，没有电路的概念，因为要针对<strong>突发流量（bursty traffic）</strong>进行优化。</p><p>已经有一些尝试去建立支持电路交换和分组交换的混合网络，比如ATM InfiniBand有一些相似之处：它在链路层实现了端到端的流量控制，从而减少了在网络中排队，但是可能因链路拥塞而受到延迟。通过仔细使用<strong>服务质量（quality of service,）</strong>（QoS，数据包的优先级和调度）和<strong>准入控制（admission control）</strong>（限速发送器），可以仿真分组网络上的电路交换，或提供统计上的<strong>有限延迟</strong>。</p><p>但是，目前在多租户数据中心和公共云或通过互联网进行通信时，此类服务质量尚未启用。必须假设网络拥塞，排队和无限的延迟总是会发生。</p><h2 id="不可靠的时钟"><a href="#不可靠的时钟" class="headerlink" title="不可靠的时钟"></a>不可靠的时钟</h2><p>在分布式系统中，因为通信不是即时的，确定时间是一个麻烦的问题。每台机器都有自己的时钟，这些设备不是完全准确的，所以每台机器都有自己的时间概念，可能比其他机器稍快或更慢。可以在一定程度上同步时钟：最常用的机制是<strong>网络时间协议（NTP）</strong>，它允许根据一组服务器报告的时间来调整计算机时钟，服务器则从更精确的时间源（如GPS接收机）获取时间。</p><h3 id="单调钟和时钟"><a href="#单调钟和时钟" class="headerlink" title="单调钟和时钟"></a>单调钟和时钟</h3><p>时钟根据某个日历（也称为<strong>挂钟时间（wall-clock time）</strong>）返回当前日期和时间。 时钟通常与NTP同步</p><p>单调钟适用于测量持续时间（时间间隔），例如超时或服务的响应时间</p><p>单调钟不需要同步，但是时钟需要根据NTP服务器或其他外部时间源来设置才能有用。</p><h3 id="依赖同步时钟"><a href="#依赖同步时钟" class="headerlink" title="依赖同步时钟"></a>依赖同步时钟</h3><p>时钟的问题在于，虽然它们看起来简单易用，但却具有缺陷：一天可能不会有精确的86,400秒，<strong>时钟</strong>可能会前后跳跃，一个节点上的时间可能与另一个节点上的时间完全不同。</p><p>有一部分问题是，不正确的时钟很容易被视而不见而导致系统无法工作，如果使用需要同步时钟的软件，必须仔细监控所有机器之间的时钟偏移才可以保证系统可用</p><h4 id="有序事件的时间戳"><a href="#有序事件的时间戳" class="headerlink" title="有序事件的时间戳"></a>有序事件的时间戳</h4><p>如果两个客户端写入分布式数据库，谁先到达？ 哪一个更近？在多领导复制的数据库里，这个问题尤其明显，这种冲突解决策略被称为<strong>最后写入为准（LWW）</strong>，但是LWW是有问题的，它防止不了写丢失，也无法区分高频写入和并发写入，也可能违背写入先后</p><p>如果采取本地时钟来确定“最近”的值可能是不准确的</p><h4 id="时钟读数存在置信区间"><a href="#时钟读数存在置信区间" class="headerlink" title="时钟读数存在置信区间"></a>时钟读数存在置信区间</h4><p>您可能能够以微秒或甚至纳秒的分辨率读取机器的时钟，这样细致的测量结果不意味着这个值对于这样的精度实际上是准确的。</p><p>使用公共互联网上的NTP服务器，最好的准确度可能达到几十毫秒，而且当网络拥塞时，误差可能会超过100毫秒，但是大多数系统不公开这种不确定性。</p><p>因此，将时钟读数更像是一段时间范围：例如，一个系统可能以95％的置信度认为当前时间处于本分钟内的第10.3秒和10.5秒之间，</p><h4 id="全局快照的同步时钟"><a href="#全局快照的同步时钟" class="headerlink" title="全局快照的同步时钟"></a>全局快照的同步时钟</h4><p>在“<a href="https://vonng.gitbooks.io/ddia-cn/content/ch7.html#%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB%E5%92%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%8F%96?fileGuid=ZBBx1k4wAo8odWOR">快照隔离和可重复读取</a>”中，我们讨论了快照隔离，这是数据库中非常有用的功能，需要支持小型快速读写事务和大型长时间运行的只读事务，用于备份或分析）。它允许只读事务看到特定时间点的处于一致状态的数据库，且不会锁定和干扰读写事务。</p><h2 id="暂停进程"><a href="#暂停进程" class="headerlink" title="暂停进程"></a>暂停进程</h2><p>如果采用单领导复制分布式数据库，只有领导被允许接受写入。一个节点如何知道它仍然是领导者（它并没有被别人宣告为死亡），并且它可以安全地接受写入？</p><p>一种选择是领导者从其他节点获得一个<strong>租约（lease）</strong>，类似一个带超时的锁，任一时刻只有一个节点可以持有租约，在此期间自己是领导者，直到租约到期。因此处理循环要check租约。</p><p>但是处理中如果依赖于同步时钟，到期时间和本地时间不同步则会有问题出现</p><p>如果当前节点被<strong>抢占（preempt）</strong>正在运行的线程，并在稍后的时间恢复运行，租约如果已经过期，那么就处理了一个危险事务，而线程甚至不会注意到这一点。因为这个问题其实是：如何在单个机器上使多线程代码线程安全。</p><p>当在一台机器上编写多线程代码时，我们有相当好的工具来实现线程安全：互斥量，信号量，原子计数器，无锁数据结构，阻塞队列等等。但是这些工具并不能直接转化为分布式系统操作，因为分布式系统没有共享内存，只有通过不可靠网络发送的消息。</p><p>分布式系统中的节点，随时可能宣布死亡，可能在程序运行当中，但是其他节点还在继续运转。</p><h3 id="响应时间保证"><a href="#响应时间保证" class="headerlink" title="响应时间保证"></a>响应时间保证</h3><p>在一些实时系统中，软件必须有一个特定的<strong>截止时间（deadline）</strong>，如果截止时间不满足，可能会导致整个系统的故障。</p><p>而提供实时保证的系统要做很多额外的工作，对于大多数服务器端数据处理系统来说，实时保证是不经济或不合适的。比如垃圾收集本是一个“暂停”时进行的，会阻塞很多事情，但是变成“滚动升级”就会好很多</p><h2 id="知识、真相与谎言"><a href="#知识、真相与谎言" class="headerlink" title="知识、真相与谎言"></a>知识、真相与谎言</h2><p>网络中的一个节点无法确切地知道任何事情——它只能根据它通过网络接收到（或没有接收到）的消息进行猜测。</p><h3 id="真理由多数所定义"><a href="#真理由多数所定义" class="headerlink" title="真理由多数所定义"></a>真理由多数所定义</h3><p>一个经历了一个长时间<strong>停止世界垃圾收集暂停（stop-the-world GC Pause）</strong>的节点。节点的所有线程被GC抢占并暂停一分钟，在此期间没有请求被处理和响应，其他节点宣布它已经死亡，而死亡节点在一分钟后活了过来，从它自己的角度来看，几乎没有经过任何时间。</p><p>节点不一定能相信自己对于情况的判断。分布式系统不能完全依赖单个节点，因为它随时可能失效。许多分布式算法都依赖于法定人数，即在节点之间进行投票：决策需要来自多个节点的最小投票数，以减少对于某个特定节点的依赖。</p><p>最常见的法定人数是超过一半的绝对多数。多数法定人数允许系统继续工作，如果单个节点发生故障（三个节点可以容忍单节点故障；五个节点可以容忍双节点故障）。系统仍然是安全的</p><h3 id="领导者与锁定"><a href="#领导者与锁定" class="headerlink" title="领导者与锁定"></a>领导者与锁定</h3><p>通常情况下，一些东西在一个系统中只能有一个。例如：</p><ul><li>数据库分区的领导者只能有一个节点，以避免<strong>脑裂（split brain）</strong></li><li>特定资源的锁或对象只允许一个事务/客户端持有，以防同时写入和损坏。</li><li>一个特定的用户名只能被一个用户所注册，因为用户名必须唯一标识一个用户。</li></ul><p>一个节点可能以前是领导者，但是如果其他节点在此期间宣布它死亡或者被降级，另一个领导者当选，而自己还在执行领导者的全能，如果其他节点相信，系统就会奇怪起来</p><h4 id="防护令牌"><a href="#防护令牌" class="headerlink" title="防护令牌"></a>防护令牌</h4><p>当使用锁或租约来保护对某些资源的访问时，需要确保一个被误认为自己是“天选者”（分区的负责人，锁的持有者，成功获取用户名的用户的请求处理程序，且没有经过多数法定同意）的节点不能中断系统的其它部分。实现这一目标的一个相当简单的技术就是<strong>防护（fencing）</strong></p><p>假设每次锁定服务器授予锁或租约时，它还会返回一个<strong>防护令牌（fencing token）</strong>，这个数字在每次授予锁定时都会增加，然后，我们可以要求客户端每次向存储服务发送写入请求时，都必须包含当前的屏蔽令牌。</p><p>这种机制要求资源本身在检查令牌方面发挥积极作用，通过拒绝使用旧的令牌，而不是已经被处理的令牌来进行写操作（也就是服务端检查）</p><h3 id="拜占庭故障"><a href="#拜占庭故障" class="headerlink" title="拜占庭故障"></a>拜占庭故障</h3><p>如果存在节点可能“撒谎”（发送任意错误或损坏的响应）的风险，则分布式系统的问题变得更困难了。<strong>拜占庭故障（Byzantine fault）</strong>，<strong>在不信任的环境中达成共识的问题被称为拜占庭将军问题</strong></p><p>当一个系统在部分节点发生故障、不遵守协议、甚至恶意攻击、扰乱网络时仍然能继续正确工作，称之为<strong>拜占庭容错（Byzantine fault-tolerant）</strong>的，。大多数拜占庭式容错算法要求超过三分之二的节点能够正常工作（即，如果有四个节点，最多只能有一个故障）</p><h3 id="系统模型与现实"><a href="#系统模型与现实" class="headerlink" title="系统模型与现实"></a>系统模型与现实</h3><p>已经有很多算法被设计以解决分布式系统问题，三种系统模型是常用的：</p><ul><li><strong>同步模型（synchronous model）</strong>假设网络延迟，进程暂停和和时钟误差都是有界限的。这只意味着你知道网络延迟，暂停和时钟漂移将永远不会超过某个固定的上限。同步模型并不是大多数实际系统的现实模型</li><li><strong>部分同步模型（partial synchronous）</strong>一个系统在大多数情况下像一个同步系统一样运行，但有时候会超出网络延迟，进程暂停和时钟漂移的界限。这是很多系统的现实模型：大多数情况下，网络和进程表现良好，否则我们永远无法完成任何事情，但在任何时刻都有可能偶然被破坏。</li><li><strong>异步模型</strong>在这个模型中，一个算法不允许对时机做任何假设——事实上它甚至没有时钟（所以它不能使用超时）。一些算法被设计为可用于异步模型，但非常受限。</li></ul><p>进一步来说，除了时间问题，我们还要考虑<strong>节点失效</strong>。三种最常见的节点系统模型是：</p><ul><li><strong>崩溃-停止故障</strong></li></ul><p>算法可能会假设一个节点只能以一种方式失效，即通过崩溃。这意味着节点可能在任意时刻突然停止响应，此后该节点永远消失——它永远不会回来。</p><ul><li><strong>崩溃-恢复故障</strong></li></ul><p>节点可能会在任何时候崩溃，但也许会在未知的时间之后再次开始响应。在<strong>崩溃-恢复（crash-recovery）</strong>模型中，假设节点具有稳定的存储（即，非易失性磁盘存储）且会在崩溃中保留，而内存中的状态会丢失。</p><ul><li><strong>拜占庭（任意）故障</strong></li></ul><p>节点可以做（绝对意义上的）任何事情，包括试图戏弄和欺骗其他节点</p><h4 id="算法的正确性"><a href="#算法的正确性" class="headerlink" title="算法的正确性"></a>算法的正确性</h4><p>如果我们正在为一个锁生成屏蔽令牌，我们可能要求算法具有以下属性：</p><ul><li><strong>唯一性</strong></li></ul><p>没有两个屏蔽令牌请求返回相同的值。</p><ul><li><strong>单调序列</strong></li></ul><p>如果请求$$x$$返回了令牌$$t_x$$，并且请求$$y$$返回了令牌$$t_y$$，并且$$x$$在$$y$$开始之前已经完成，那么$$t_x &lt;t_y$$。</p><ul><li><strong>可用性</strong></li></ul><p>请求防护令牌并且不会崩溃的节点，最终会收到响应。</p><h4 id="安全性和活性"><a href="#安全性和活性" class="headerlink" title="安全性和活性"></a>安全性和活性</h4><p><strong>安全性（safety）</strong>和<strong>活性（liveness）</strong>。在刚刚给出的例子中，<strong>唯一性（uniqueness）</strong>和<strong>单调序列（monotonic sequence）</strong>是安全属性，但<strong>可用性</strong>是<strong>活性（liveness）</strong>属性。</p><p>这两种性质有什么区别？一个是，活性属性通常在定义中通常包括“<strong>最终</strong>”一词（类似最终一致性）</p><p>安全性通常被非正式地定义为，<strong>没有坏事发生</strong>，而活性通常就类似：<strong>最终好事发生</strong></p><ul><li>如果安全属性被违反，我们可以指向一个特定的时间点（例如，如果违反了唯一性属性，我们可以确定重复的防护令牌返回的特定操作） 。违反安全属性后，违规行为不能撤销——损失已经发生。</li><li>活性属性反过来：在某个时间点（例如，一个节点可能发送了一个请求，但还没有收到响应），它可能不成立，但总是希望在未来（即通过接受答复）。</li></ul><p>对于分布式算法，在系统模型的所有可能情况下，要求始终保持安全属性是常见的。也就是说，即使所有节点崩溃，或者整个网络出现故障，算法仍然必须确保它不会返回错误的结果（即保证安全性得到满足）</p><p>但是，对于活性属性，只有在大多数节点没有崩溃的情况下，只有当网络最终从中断中恢复时，我们才可以说请求需要接收响应。部分同步模型的定义要求系统最终返回到同步状态，然后进行修复。</p><h4 id="将系统模型映射到现实世界"><a href="#将系统模型映射到现实世界" class="headerlink" title="将系统模型映射到现实世界"></a>将系统模型映射到现实世界</h4><p>在故障恢复模型中的算法通常假设稳定存储器中的数据经历了崩溃。但是，如果磁盘上的数据被破坏，或者由于硬件错误或错误配置导致数据被清除，会发生什么情况？如果服务器存在固件错误并且在重新启动时无法识别其硬盘驱动器，即使驱动器已正确连接到服务器，也会发生什么情况？</p><p>算法的理论描述可以简单宣称一些事在假设上是不会发生的——在非拜占庭式系统中。但实际上我们还是需要对可能发生和不可能发生的故障做出假设，真实世界的实现，仍然会包括处理“假设上不可能”情况的代码，即使代码可能就是<code>printf(&quot;you sucks&quot;)</code>和<code>exit(666)</code>，实际上也就是留给运维来擦屁股。（这可以说是计算机科学和软件工程间的一个差异）。</p><p>这并不是说理论上抽象的系统模型是毫无价值的， 证明算法正确并不意味着它在真实系统上的实现必然总是正确。但这迈出了很好的第一步，因为理论分析可以发现算法中的问题，这种问题可能会在现实系统中长期潜伏，直到你的假设（例如，时间）因为不寻常的情况被打破。理论分析与经验测试同样重要。</p><h1 id="DDIA-第九章节-一致性与共识"><a href="#DDIA-第九章节-一致性与共识" class="headerlink" title="DDIA 第九章节 一致性与共识"></a>DDIA 第九章节 一致性与共识</h1><p>分布式系统中的许多事情可能会出错。我们需要找到容错的方法让系统里某些内部组件出现故障但服务也能正常运行。</p><p>构建容错系统里，我们大量的使用了抽象，让应用依赖这些抽象的实现。比如使用事务，应用可以假装没有崩溃（原子性），没有其他人同时访问数据库（隔离），存储设备是完全可靠的（持久性）</p><p>分布式系统最重要的抽象之一就是<strong>共识（consensus）</strong>：<strong>就是让所有的节点对某件事达成一致</strong>。</p><h2 id="一致性保证"><a href="#一致性保证" class="headerlink" title="一致性保证"></a>一致性保证</h2><p>大多数复制的数据库至少提供了<strong>最终一致性</strong>，一个非常弱的保证，它的更好的名字是<strong>收敛（convergence）</strong>，因为我们预计所有的复本最终会收敛到相同的值。但是最终一致性是一种很弱的一致性保证</p><h2 id="线性一致性"><a href="#线性一致性" class="headerlink" title="线性一致性"></a>线性一致性</h2><p><strong>最终一致</strong>的数据库，如果在同一时刻问两个不同副本相同的问题，可能会得到两个不同的答案。</p><p>如果数据库可以提供只有一个副本的假象，那么事情就简单太多了。那么每个客户端都会有相同的数据视图，且不必担心复制滞后了。</p><p>这就是<strong>线性一致性（linearizability）</strong>（也称为<strong>原子一致性（atomic consistency）</strong>，<strong>强一致性（strong consistency）</strong>，<strong>立即一致性（immediate consistency）</strong>或<strong>外部一致性（external consistency ）</strong>【8】）</p><p>它基本的想法是让一个系统看起来好像只有一个数据副本，而且所有的操作都是原子性的。</p><p>在一个线性一致的系统中，只要一个Client成功完成写操作，所有其他Client从数据库中读取数据必须能够看到刚刚写入的值。线性一致性是一个<strong>新鲜度保证（recency guarantee）</strong></p><h3 id="什么使得系统线性一致？"><a href="#什么使得系统线性一致？" class="headerlink" title="什么使得系统线性一致？"></a>什么使得系统线性一致？</h3><p>线性一致性背后的基本思想很简单：使系统看起来好像只有一个数据副本。 通过记录所有请求和响应的时序，并检查它们是否可以排列成有效的顺序，测试一个系统的行为是否线性一致性是可能的（尽管在计算上是昂贵的）</p><h3 id="依赖线性一致性"><a href="#依赖线性一致性" class="headerlink" title="依赖线性一致性"></a>依赖线性一致性</h3><p>线性一致性在什么情况下有用？对于少数领域，线性一致性是系统正确工作的一个重要条件。</p><h4 id="锁定和领导选举"><a href="#锁定和领导选举" class="headerlink" title="锁定和领导选举"></a>锁定和领导选举</h4><p>一个使用单主复制的系统，为了确保领导真的只有一个，一种选择领导者的方法是使用锁：每个节点在启动时尝试获取锁，成功者成为领导者。不管这个锁是如何实现的，它必须是线性一致的：所有节点必须就哪个节点拥有锁达成一致</p><h4 id="约束和唯一性保证"><a href="#约束和唯一性保证" class="headerlink" title="约束和唯一性保证"></a>约束和唯一性保证</h4><p>唯一性约束在数据库中很常见：例如，用户名或电子邮件地址必须唯一标识一个用户，而在文件存储服务中，不能有两个具有相同路径和文件名的文件。</p><h3 id="实现线性一致的系统"><a href="#实现线性一致的系统" class="headerlink" title="实现线性一致的系统"></a>实现线性一致的系统</h3><p>由于线性一致性本质上意味着“表现得好像只有一个数据副本，而且所有的操作都是原子的”，所以最简单的答案就是，真的只用一个数据副本。如果副本的节点失效，数据就会丢失或需要重新启动。 使系统容错最常用的方法是使用复制。</p><ul><li>单主复制（可能线性一致）</li><li>多主复制（线性一致）</li><li>无主复制（可能线性一致）</li><li>共识算法（线性一致）</li></ul><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p>任何线性一致的数据库只要在任何不可靠的网络上，无论单复制还是多复制，即使在同一个数据中心内也是如此。问题面临的权衡如下：</p><ul><li>如果应用需要线性一致性，且某些副本因为网络问题与其他副本断开连接，那么这些副本掉线时不能处理请求。请求必须等到网络问题解决，或直接返回错误。（无论哪种方式，服务都<strong>不可用（unavailable）</strong>）。</li><li>如果应用不需要线性一致性，那么某个副本即使与其他副本断开连接，也可以独立处理请求（例如多主复制）。在这种情况下，应用可以在网络问题前保持可用，但其行为不是线性一致的。</li></ul><p>因此不需要线性一致性的应用对网络问题有更强的容错能力。这种见解通常被称为CAP定理</p><p>CAP最初是作为一个经验法则提出的，没有准确的定义， CAP定理的正式定义仅限于很狭隘的范围，它只考虑了线性一致性模型和一种故障（网络分区，或活跃但彼此断开的节点）。它没有讨论任何关于网络延迟，死亡节点或其他权衡的事，对于设计系统而言并没有实际价值</p><h4 id="线性一致性和网络延迟"><a href="#线性一致性和网络延迟" class="headerlink" title="线性一致性和网络延迟"></a>线性一致性和网络延迟</h4><p>虽然线性一致是一个很有用的保证，但实际上，线性一致的系统非常少。现代多核CPU上的内存甚至都不是线性一致的：如果一个CPU核上运行的线程写入某个内存地址，而另一个CPU核上运行的线程不久之后读取相同的地址，并没有保证一定能一定读到第一个线程写入的值（除非使用了<strong>内存屏障（memory barrier）</strong>或<strong>围栏（fence）</strong>）。</p><p>这种行为的原因是每个CPU核都有自己的内存缓存和存储缓冲区。默认情况下，内存访问首先走缓存，副本是异步更新的，所以就失去了线性一致性。</p><p>对多核内存一致性模型而言，CAP定理是没有意义的，因为在一台计算机中通信是可靠的，所以牺牲线性一致性的原因是性能，而不是容错。</p><p>能找到一个更高效的线性一致存储实现吗？看起来答案是否定的：如果你想要线性一致性，读写请求的响应时间至少与网络延迟的不确定性成正比。在像大多数计算机网络一样具有高度可变延迟的网络中，线性读写的响应时间不可避免地会很高。</p><p>更快地线性一致算法不存在，但更弱的一致性模型可以快得多，所以对延迟敏感的系统而言，这类权衡非常重要。</p><h2 id="顺序保证"><a href="#顺序保证" class="headerlink" title="顺序保证"></a>顺序保证</h2><h3 id="顺序与因果"><a href="#顺序与因果" class="headerlink" title="顺序与因果"></a>顺序与因果</h3><p><strong>顺序</strong>反复出现有几个原因，其中一个原因是，它有助于保持<strong>因果关系（causality）</strong></p><p>因果关系对事件施加了一种<strong>顺序</strong>：因在果之前；如果一个系统服从因果关系所规定的顺序，我们说它是<strong>因果一致（causally）</strong>的。</p><h4 id="因果顺序不是全序的"><a href="#因果顺序不是全序的" class="headerlink" title="因果顺序不是全序的"></a>因果顺序不是全序的</h4><p><strong>全序（total order）</strong>允许任意两个元素进行比较，所以如果有两个元素，你总是可以说出哪个更大，哪个更小。例如，自然数集是全序的：5和13里，13大于5。</p><p>然而数学集合并不完全是全序的，<code>&#123;a, b&#125;</code>比<code>&#123;b, c&#125;</code>更大吗？二者都不是对方的子集。我们说它们是<strong>无法比较（incomparable）</strong>的，因此数学集合是<strong>偏序（partially order）</strong>的</p><p>全序和偏序之间的差异反映在不同的数据库一致性模型中：</p><p><strong>线性一致性</strong></p><p>在线性一致的系统中，操作是全序的，对任何两个操作，我们总是能断定哪个先发生</p><p><strong>因果性</strong></p><p>如果两个操作都没有在彼此<strong>之前发生</strong>，那么这两个操作是并发的，是无法比较的</p><p>根据这个定义，在线性一致的数据存储中是不存在并发操作的：必须有且仅有一条时间线，所有的操作都在这条时间线上，构成一个全序关系。</p><h4 id="线性一致性强于因果一致性"><a href="#线性一致性强于因果一致性" class="headerlink" title="线性一致性强于因果一致性"></a>线性一致性强于因果一致性</h4><p>那么因果顺序和线性一致性之间的关系是什么？答案是线性一致性<strong>隐含着（implies）</strong>因果关系：任何线性一致的系统都能正确保持因果性</p><p>线性一致性并不是保持因果性的唯一途径，还有其他方法可以保证一个系统是因果一致的，但无需承担线性一致带来的性能折损（尤其是CAP定理不适用的情况）实际上在所有的不会被网络延迟拖慢的一致性模型中，因果一致性是可行的最强的一致性模型。而且在网络故障时仍能保持可用</p><p>在许多情况下，看上去需要线性一致性的系统，实际上需要的只是因果一致性</p><h4 id="捕获因果关系"><a href="#捕获因果关系" class="headerlink" title="捕获因果关系"></a>捕获因果关系</h4><p>为了维持因果性，你需要知道哪个操作发生在哪个其他操作之前（<strong>happened before</strong>），这是一个偏序。用于确定“哪些操作发生在其他操作之前”的技术，在之前的无领导者数据存储中的因果性里有说为了防止丢失更新，我们需要检测到对同一个键的并发写入。</p><p>因果一致性则更进一步：它需要跟踪整个数据库中的因果依赖，可以推广版本向量以解决此类问题</p><h3 id="序列号顺序"><a href="#序列号顺序" class="headerlink" title="序列号顺序"></a>序列号顺序</h3><p>虽然因果是一个重要的理论概念，但实际上跟踪所有的因果关系是不切实际的。</p><p>在许多应用中，客户端在写入内容之前会先读取大量数据，所以弄清因果依赖是有很高成本的。我们可以使用<strong>序列号（sequence nunber）</strong>或<strong>时间戳（timestamp）</strong>来排序事件。时间戳不一定来自时钟，可以来自一个逻辑钟</p><p>这样的序列号或时间戳是紧凑的（只有几个字节大小），它提供了一个全序关系：每操作都有一个唯一的序列号，而且总是可以比较两个序列号，确定哪一个更大（即哪些操作后发生）。</p><h4 id="非因果序列号生成器"><a href="#非因果序列号生成器" class="headerlink" title="非因果序列号生成器"></a>非因果序列号生成器</h4><p>如果是多主数据库或无主数据库，操作生成序列号要用其他方法：</p><ul><li>每个节点生成自己独立的一组序列号</li><li>物理时钟时间戳（要求精准分辨率）</li><li>预先分配好序列号区块，节点AB分用</li></ul><h4 id="兰伯特时间戳"><a href="#兰伯特时间戳" class="headerlink" title="兰伯特时间戳"></a>兰伯特时间戳</h4><p>尽管刚才描述的三个序列号生成器与因果不一致，，但实际上有一个简单的方法来产生与因果关系一致的序列号。它被称为兰伯特时间戳：</p><p>每个节点都有一个唯一标识符，和一个保存自己执行操作数量的计数器。 兰伯特时间戳就是两者的简单组合：（计数器，节点ID）$$(counter, node ID)$$。两个节点有时可能具有相同的计数器值，但通过在时间戳中包含节点ID，每个时间戳都是唯一的。</p><p>它提供了一个全序：如果你有两个时间戳，则<strong>计数器</strong>值大者是更大的时间戳。如果计数器值相同，则节点ID越大的，时间戳越大。</p><p>使兰伯特时间戳因果一致的关键思想如下所示：每个节点和每个客户端跟踪迄今为止所见到的最大<strong>计数器</strong>值，并在每个请求中包含这个最大计数器值。当一个节点收到最大计数器值大于自身计数器值的请求或响应时，它立即将自己的计数器设置为这个最大值。</p><h3 id="全序广播"><a href="#全序广播" class="headerlink" title="全序广播"></a>全序广播</h3><p>如果你的程序只运行在单个CPU核上，那么定义一个操作全序是很容易的：可以简单地就是CPU执行这些操作的顺序。在分布式系统里，如果吞吐量超出单个主库的处理能力，这种情况下如何扩展系统；以及，如果主库失效如何处理故障切换。在分布式系统文献中，这个问题被称为<strong>全序广播（total order broadcast）</strong>或<strong>原子广播（atomic broadcast）</strong></p><p>全序广播通常被描述为在节点间交换消息的协议。 非正式地讲，它要满足两个安全属性：</p><p><strong>可靠交付（reliable delivery）</strong></p><p>没有消息丢失：如果消息被传递到一个节点，它将被传递到所有节点。</p><p><strong>全序交付（totally ordered delivery）</strong></p><p>消息以相同的顺序传递给每个节点。</p><h4 id="使用全序广播"><a href="#使用全序广播" class="headerlink" title="使用全序广播"></a>使用全序广播</h4><p>像ZooKeeper和etcd这样的共识服务实际上实现了全序广播。全序广播正是数据库复制所需的：如果每个消息都代表一次数据库的写入，且每个副本都按相同的顺序处理相同的写入，那么副本间将相互保持一致（除了临时的复制延迟）。这个原理被称为<strong>状态机复制（state machine replication）</strong></p><h2 id="分布式事务与共识"><a href="#分布式事务与共识" class="headerlink" title="分布式事务与共识"></a>分布式事务与共识</h2><p><strong>共识</strong>是分布式计算中最重要也是最基本的问题之一。从表面上看似乎很简单：非正式地讲，目标只是<strong>让几个节点达成一致（get serveral nodes to agree on something）</strong>。</p><p><strong>两阶段提交（2PC, two-phase commit）</strong>算法，这是解决原子提交问题最常见的办法，并在各种数据库、消息队列和应用服务器中实现。事实证明2PC是一种共识算法，但不是一个非常好的算法</p><h3 id="原子提交与二阶段提交（2PC）"><a href="#原子提交与二阶段提交（2PC）" class="headerlink" title="原子提交与二阶段提交（2PC）"></a>原子提交与二阶段提交（2PC）</h3><p>事务原子性的目的是在多次写操作中途出错的情况下，提供一种简单的语义。事务的结果要么是成功提交，在这种情况下，事务的所有写入都是持久化的；要么是中止，在这种情况下，事务的所有写入都被回滚（即撤消或丢弃）。</p><p>正常情况下，2PC事务以应用在多个数据库节点上读写数据开始。我们称这些数据库节点为<strong>参与者（participants）</strong>。当应用准备提交时，协调者开始阶段 1 ：它发送一个<strong>准备（prepare）</strong>请求到每个节点，询问它们是否能够提交。然后协调者会跟踪参与者的响应：</p><ul><li>如果所有参与者都回答“是”，表示它们已经准备好提交，那么协调者在阶段 2 发出<strong>提交（commit）</strong>请求，然后提交真正发生。</li><li>如果任意一个参与者回复了“否”，则协调者在阶段2 中向所有节点发送<strong>中止（abort）</strong>请求。</li></ul><h4 id="系统承诺"><a href="#系统承诺" class="headerlink" title="系统承诺"></a>系统承诺</h4><p>为了理解它的工作原理，我们必须更详细地分解这个过程：</p><ol><li>当应用想要启动一个分布式事务时，它向协调者请求一个事务ID。此事务ID是全局唯一的。</li><li>应用在每个参与者上启动单节点事务，并在单节点事务上捎带上这个全局事务ID。所有的读写都是在这些单节点事务中各自完成的。如果在这个阶段出现任何问题（例如，节点崩溃或请求超时），则协调者或任何参与者都可以中止。</li><li>当应用准备提交时，协调者向所有参与者发送一个<strong>准备</strong>请求，并打上全局事务ID的标记。如果任意一个请求失败或超时，则协调者向所有参与者发送针对该事务ID的中止请求。</li><li>参与者收到准备请求时，需要确保在任意情况下都的确可以提交事务。这包括将所有事务数据写入磁盘（出现故障，电源故障，或硬盘空间不足都不能是稍后拒绝提交的理由）以及检查是否存在任何冲突或违反约束。通过向协调者回答“是”，节点承诺，只要请求，这个事务一定可以不出差错地提交。换句话说，参与者放弃了中止事务的权利，但没有实际提交。</li><li>当协调者收到所有准备请求的答复时，会就提交或中止事务作出明确的决定（只有在所有参与者投赞成票的情况下才会提交）。协调者必须把这个决定写到磁盘上的事务日志中，如果它随后就崩溃，恢复后也能知道自己所做的决定。这被称为<strong>提交点（commit point）</strong>。</li><li>一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，直到成功为止。没有回头路：如果已经做出决定，不管需要多少次重试它都必须被执行。如果参与者在此期间崩溃，事务将在其恢复后提交——由于参与者投了赞成，因此恢复后它不能拒绝提交。</li></ol><p>因此，该协议包含两个关键的“不归路”点，以此区分“两阶段”：当参与者投票“是”时，它承诺它稍后肯定能够提交（尽管协调者可能仍然选择放弃）。一旦协调者做出决定，这一决定是不可撤销的。这些承诺保证了2PC的原子性。</p><h4 id="协调者失效"><a href="#协调者失效" class="headerlink" title="协调者失效"></a>协调者失效</h4><p>如果协调者在发送<strong>准备</strong>请求之前失败，参与者可以安全地中止事务。但是，一旦参与者收到了准备请求并投了“是”，就不能再单方面放弃，它必须等待协调者回答事务是否已经提交或中止。如果此时协调者崩溃或网络出现故障，参与者只能等待。参与者的这种事务状态称为<strong>存疑（in doubt）</strong>的或<strong>不确定（uncertain）</strong>的。</p><p>可以完成2PC的唯一方法是等待协调者恢复，协调者恢复后，通过读取其事务日志来确定所有存疑事务的状态。任何在协调者日志中没有提交记录的事务都会中止。</p><h3 id="实践中的分布式事务"><a href="#实践中的分布式事务" class="headerlink" title="实践中的分布式事务"></a>实践中的分布式事务</h3><p>分布式事务的名声毁誉参半，尤其是那些通过两阶段提交实现的。一方面，它被视作提供了一个难以实现的重要的安全性保证；另一方面，它们因为导致运维问题，造成性能下降，做出超过能力范围的承诺而饱受批评。</p><p>分布式事务的某些实现会带来严重的性能损失 —— 例如据报告称，MySQL中的分布式事务比单节点事务慢10倍以上。两阶段提交所固有的性能成本，大部分是由于崩溃恢复所需的额外强制刷盘（<code>fsync</code>）以及额外的网络往返。</p><p><strong>数据库内部的分布式事务</strong></p><p>一些分布式数据库（即在其标准配置中使用复制和分区的数据库）支持数据库节点之间的内部事务。例如，VoltDB和MySQL Cluster的NDB存储引擎就有这样的内部事务支持。在这种情况下，所有参与事务的节点都运行相同的数据库软件。</p><p><strong>异构分布式事务</strong></p><p>在<strong>异构（heterogeneous）</strong>事务中，参与者是两种或以上不同技术：例如来自不同供应商的两个数据库，甚至是非数据库系统（如消息代理）。跨系统的分布式事务必须确保原子提交，尽管系统可能完全不同。</p><h4 id="恰好一次的消息处理"><a href="#恰好一次的消息处理" class="headerlink" title="恰好一次的消息处理"></a>恰好一次的消息处理</h4><p>异构的分布式事务处理能够以强大的方式集成不同的系统。例如：消息队列中的一条消息可以被确认为已处理，当且仅当用于处理消息的数据库事务成功提交。这是通过在同一个事务中原子提交<strong>消息确认</strong>和<strong>数据库写入</strong>两个操作来实现的，但这是两种不相关的技术</p><p>如果消息传递或数据库事务任意一者失败，两者都会中止，因此消息代理可能会在稍后安全地重传消息。因此，通过原子提交<strong>消息处理及其副作用</strong>，即使在成功之前需要几次重试，也可以确保消息被<strong>有效地（effectively）</strong>恰好处理一次。中止会抛弃部分完成事务所导致的任何副作用。</p><p>然而，只有当所有受事务影响的系统都使用同样的<strong>原子提交协议（atomic commit protocl）</strong>时，这样的分布式事务才是可能的。XA事务：X/Open XA（<strong>扩展架构（eXtended Architecture）</strong>的缩写）是跨异构技术实现两阶段提交的标准</p><h3 id="容错共识"><a href="#容错共识" class="headerlink" title="容错共识"></a>容错共识</h3><p>共识算法可以用来确定这些<strong>互不相容（mutually incompatible）</strong>的操作中，哪一个才是赢家。共识问题通常形式化如下：一个或多个节点可以<strong>提议（propose）</strong>某些值，而共识算法<strong>决定（decides）</strong>采用其中的某个值。了哪个顾客获得了座位。</p><p>在这种形式下，共识算法必须满足以下性质：</p><ul><li><strong>一致同意（Uniform agreement）</strong></li></ul><p>没有两个节点的决定不同。</p><ul><li><strong>完整性（Integrity）</strong></li></ul><p>没有节点决定两次。</p><ul><li><strong>有效性（Validity）</strong></li></ul><p>如果一个节点决定了值<code>v</code>，则<code>v</code>由某个节点所提议。</p><ul><li><strong>终止（Termination）</strong>由所有未崩溃的节点来最终决定值。</li></ul><p>前两个是基本属性，有效性保证了没有平凡解决方案（比如始终提议<code>null</code>），如果不关心容错，那么可以设定一个节点为“独裁者”，让该节点做出所有决定，终止属性包含容错的思维，一个共识算法不能简单地永远闲坐着等死，它必须取得进展。即使部分节点出现故障，其他节点也必须达成一项决定。</p><p>事实上可以证明，任何共识算法都需要至少占总体<strong>多数（majority）</strong>的节点正确工作，以确保终止属性</p><h4 id="共识算法和全序广播"><a href="#共识算法和全序广播" class="headerlink" title="共识算法和全序广播"></a>共识算法和全序广播</h4><p>最著名的容错共识算法是<strong>视图戳复制（VSR, viewstamped replication）</strong>，Paxos ，Raft 以及 Zab 。</p><p>大多数这些算法实际上并不直接使用这里描述的形式化模型（提议与决定单个值，一致同意，完整性，有效性和终止属性）。取而代之的是，它们决定了值的<strong>顺序（sequence）</strong>，这使它们成为全序广播算法，全序广播要求将消息按照相同的顺序，恰好传递一次，准确传送到所有节点。如果仔细思考，这相当于进行了几轮共识：</p><ul><li>由于<strong>一致同意</strong>属性，所有节点决定以相同的顺序传递相同的消息。</li><li>由于<strong>完整性</strong>属性，消息不会重复。</li><li>由于<strong>有效性</strong>属性，消息不会被损坏，也不能凭空编造。</li><li>由于<strong>终止</strong>属性，消息不会丢失。</li></ul><h4 id="共识的局限性"><a href="#共识的局限性" class="headerlink" title="共识的局限性"></a>共识的局限性</h4><p>共识算法对于分布式系统来说是一个巨大的突破：它为其他充满不确定性的系统带来了基础的安全属性（一致同意，完整性和有效性），然而它们还能保持容错</p><p>尽管如此，它们并不是在所有地方都用上了，因为好处总是有代价的。</p><p>节点在做出决定之前对提议进行投票的过程是一种同步复制。通常数据库会配置为异步复制模式。在这种配置中发生故障切换时，一些已经提交的数据可能会丢失。但是为了获得更好的性能，许多人选择接受这种风险。</p><p>共识系统通常依靠超时来检测失效的节点。在网络延迟高度变化的环境中，特别是在地理上散布的系统中，经常发生一个节点由于暂时的网络问题，错误地认为领导者已经失效。虽然这种错误不会损害安全属性，但频繁的领导者选举会导致糟糕的性能表现，也会在领导者问题上花费更多成本</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迟来的五月</title>
    <link href="/2021/05/07/%E8%BF%9F%E6%9D%A5%E7%9A%84%E4%BA%94%E6%9C%88/"/>
    <url>/2021/05/07/%E8%BF%9F%E6%9D%A5%E7%9A%84%E4%BA%94%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<h2 id="起"><a href="#起" class="headerlink" title="起"></a>起</h2><p>“度假”这个东西非常小布尔乔亚，对年轻人或想保持年轻的人很有吸引力，我也不能幸免。秉持“没有调查就没有发言权”的原则，我去海南开启了“度假实验”。</p><p>说起来，自己对海南的向往由来已久。首先是一个土生土长在温带季风气候北纬44度地区的东北人对“能把人包裹住的温暖”十分渴望；然后是20年里见到的海洋集中在黄海和渤海工业区的港口，大海拿蓝色的美观性换取了灰黄的功能性。</p><p>我总会觉得，平原地区的孩子和海边的孩子是有共通之处的，当你站在在天地间，视野里全是一片广袤而看不到边际的自然。目光所及的变化只有麦浪和同时空下的海浪，耳边是喜鹊或是海鸥在鸣叫。</p><p>如今再问高中同学《赤壁赋》，大家普遍都不会背了，但是有一句所有人都记得：“寄蜉蝣于天地，渺沧海之一粟”。我猜是这话和十八年生活的潜意识走到一起，成了“共识”。</p><hr><h2 id="站在能分割世界的桥"><a href="#站在能分割世界的桥" class="headerlink" title="站在能分割世界的桥"></a>站在能分割世界的桥</h2><p>小曹和我一起在2018年毕业，一个去了成都，一个去了海南。我问她是不是也有着不想留家的叛逆，她没有否定。而我问她现在还有没有保留这个叛逆，她也没有肯定。</p><p>认识快十年的老朋友遇到了头疼的问题，又一次走到人生的岔路口。</p><p>考研 工作 选调 考公 转行 回家 漂泊···</p><p>作为一个18岁做了一次世俗意义上“正确”的选择的人，每次看到老同学们因为这种事情纠结或苦痛，安慰他们之余，心里是有些恶趣味的窃喜的。</p><p>我尚且不能免俗的人之丑恶：看到别人过得没有自己好而愉悦。</p><p>有句话叫“未经他人苦，莫劝他人善”，还有句话叫“如人饮水，冷暖自知”，大抵意思其实差不多。我能做到的，只有一些安慰和倾听。</p><p>在安慰的话里，我最常说的是“你才二十岁”。</p><p>我们都才二十岁，十八岁的选择不一定代表你的一生，二十岁的选择同样也不能。你才二十岁，你知道你想要什么吗？</p><p>这个问题，现在我可以直截了当的回答，我想要钱。</p><p>我想三年前的自己肯定想不到现在是这个b样。那个时候我在看《一只特立独行的猪》 看《情人》 看《拙匠随笔》</p><p>现在我在看《价值共生》、《深入浅出Vue.js》、《俞军产品方法论》</p><p>我始终觉得有些东西被磨灭了。来到海南之前，心里是空落落的。</p><p>“大海会抚平一切” 我这样想着。</p><p>直到我站在祖国南端的小岛上，看到平和的蓝色海洋，脑海里突然响起了万青的小号</p><blockquote><p><strong>站在能分割世界的桥</strong><br><strong>还是看不清 在那些时刻</strong><br><strong>遮蔽我们 黑暗的心 究竟是什么</strong><br><strong>住在我心里孤独的</strong><br><strong>孤独的海怪 痛苦之王</strong></p></blockquote><hr><h2 id="恰似方便面的浪漫"><a href="#恰似方便面的浪漫" class="headerlink" title="恰似方便面的浪漫"></a>恰似方便面的浪漫</h2><p>我一直相信“万物守恒定律”，比如它在抽卡这块的表现形式就是“运气这个东西谁用完谁先走”。</p><p>对“浪漫”，我的理论是，每天可以生产出定量的浪漫，它会在生活的方方面面被消耗掉，有的是工作，有的是恋人，有的是下班路上遇到的猫猫。</p><p>单身的人，每天的浪漫都消耗不完，所以会有对恋爱的幻想，能将两人的浪漫互相交换。</p><p>有对象的人，每天的浪漫是消耗殆尽的，他们在工作之后残留的余量不足以“浪漫”另一个人，所以他们会有摩擦，会有争吵，直到矛盾不可调和到分开。</p><p>有点像方便面，一包会觉得吃不饱，两包又觉得太多。</p><p>所以和另外一个人保持暧昧是很好的合作形式，因为边界，两个人可以随意的轻量交换而不会有更深层次的冲突。昨天我可以吃一块钱的小浣熊，今天你可以只消耗五毛钱换一包魔法士。</p><p>平稳的小本买卖，这很合理，不是吗？在这个强调独立和自我的时代里，何必提高“浪漫产能”呢？这实在太累了，还是对自己好一点吧。</p><hr><h2 id="小家"><a href="#小家" class="headerlink" title="小家"></a>小家</h2><p>三亚的两天里，是住在一间设备齐全的两居室。每天早上拉开窗帘看到深绿的椰子树和不远处闪烁波光的内海和盛满阳光的露台。晚上是暖黄色的灯光，冰箱里镇了一天的可乐和躺在沙发上快乐游戏和聊天。</p><p>这是我预想中的，“家”的感觉。平淡的日常，可以囿于厨房餐厅，随时下楼开车买菜，阳台有花儿，要再加上只猫，啧，齐活了。</p><p>“温馨”这个词在脑海构建出的意象，大抵如此。</p><p>一个人吃饭叫做吃饲料，两个人吃饭才叫吃饭。我挺喜欢这句话的。</p><p>我看到天上的云，看到夜晚的星星，看到路边可爱的猫猫，听到一首好听的歌曲，看到任何美好事物的时候，感叹之余的第一个想法就是讲给另一个人听。</p><p>但那个人是谁呢</p><p>对于青春的滥情人而言，并没有一个特定的ta。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">life</span><span class="hljs-params">(myLover)</span> </span>&#123;&#125;Copy<br></code></pre></td></tr></table></figure><p>就像JS函数里一个普通的形参，传入谁都可以，连类型检查都没有<br>对此我是自责的。我只是这样构建着一个符合自己臆想的世界。</p><p>为什么以后的ta会一定喜欢下厨呢？那明明是一件吃力不讨好的事情。</p><p>为什么以后的ta会一定和我坐在那间我喜欢的馆子一起吃饭呢？ta是不吃这个不吃那个的</p><p>为什么以后的ta会一定会和我一起养猫呢？ta猫毛过敏，或是不喜欢猫的</p><p>···</p><p>每每想到这些，我会想到自己确确实实是个自私的人，一个以自我为中心的人，一个给别人强加自己想法的人</p><p>反过来说，而这些碰撞与磨擦，是否就是消磨了爱情的罪魁祸首呢。那样一来，会磨损消逝的爱情是不是还不如一开始就没有呢？</p><p>如果只是秉持着“让两个人都可以变得更好”的想法，也没必要付出更多的成本吧。</p><p>还是说这些东西被先贤们从人类开始研究到了现在，也依旧没有答案。</p><h2 id="若能绽放光芒"><a href="#若能绽放光芒" class="headerlink" title="若能绽放光芒"></a>若能绽放光芒</h2><p>你越强调什么，越害怕失去什么。</p><p>身边的人和我都很喜欢说自己的年纪。我的同事说你还小，部门新人要给年纪更大的单身男同事介绍；家里说你才二十出头，他们那个时候高中还没毕业，而你都已经快工作了；我自己每次说自己二十岁，我猜是因为我没什么好说的了。</p><p>我大概除了这个，一无所有</p><p>喜欢是一个慢慢陷进去的过程，我也不例外。</p><p>可是为什么会是她呢，为什么能聊诗聊歌，聊到半夜的人是她呢，那个激发了自己隐藏已久的浪漫的人，为什么会是她呢，一个只能做一辈子朋友的人。</p><p>为什么可以聊成一句顶一万句的人，是我永远追赶不上的人呢。如果每个人生来就是独立的个体就好了，原子化的个人没有任何束缚地游荡在空间里。或者从传统的思路想，我是一个女孩子，他是男生，好像还能上演一出灰姑娘的故事。</p><p>和她所拥有的，或是她家里拥有的一切相比，我能拿得出来的，大概只有一个“年轻”了。</p><p>二十岁的我要用年轻换取什么呢？我想我会思考这个问题，直到我二十一岁时，旋而问自己“二十一岁的你要用青春换取什么呢？”</p><p>或许我将无休无止的这样迷茫下去</p>]]></content>
    
    
    
    <tags>
      
      <tag>胡说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的Koa: 中间件机制</title>
    <link href="/2021/04/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Koa-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Koa-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/koajs/koa">Koa源码</a></p><p>Koa 是一个 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。</p><p>和Express相比，Koa没有内置任何中间件，甚至连路由、日志都没有。这些能力需要开发者自己编码或使用第三方包。Koa只是提供了一套级联中间件的方式(koa-compose)。因此，Koa是一个极小的框架，内置的概念只有5个：</p><ul><li>Application：应用</li><li>Middleware：中间件</li><li>Context：上下文</li><li>Request：请求</li><li>Response：响应</li></ul><p>Koa总共的代码还没过2000行，非常符合“小而美”的定义</p><p>那么下面请欣赏《如何用8行代码起一个简单的Koa服务》：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<br><br>app.use(<span class="hljs-keyword">async</span> ctx =&gt; &#123;<br>  ctx.body = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>&#125;);<br><br>app.listen(<span class="hljs-number">3000</span>);Copy<br></code></pre></td></tr></table></figure><p>起好了，然后呢？他只是个会返回Hello world的小笨蛋而已，我现在想让它干点别的事情。</p><h3 id="从简单的中间件讲起"><a href="#从简单的中间件讲起" class="headerlink" title="从简单的中间件讲起"></a>从简单的中间件讲起</h3><p>Koa 中间件是一个很核心的概念，但是它的用法很简单，直接app.use()：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);<br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<br><br>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">await</span> next();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;);<br><br>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>  <span class="hljs-keyword">await</span> next();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>);<br>&#125;);<br><br>app.use(<span class="hljs-keyword">async</span> (ctx, next) =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>);<br>  <span class="hljs-keyword">await</span> next();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);<br>&#125;);<br><br>app.use(<span class="hljs-keyword">async</span> ctx =&gt; &#123;<br>  ctx.body = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>&#125;);<br><br>app.listen(<span class="hljs-number">3000</span>);Copy<br></code></pre></td></tr></table></figure><p>返回的结果还是Helloworld，而打印结果会像这样：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">5</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">6</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">4</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">2</span>Copy<br></code></pre></td></tr></table></figure><p>上述中间件执行顺序如下图所示：</p><p><a href="https://z3.ax1x.com/2021/04/16/cRfifx.png"><img src="https://z3.ax1x.com/2021/04/16/cRfifx.png" alt="cRfifx.png"></a></p><p>Koa的实例app是这样通过 app.use()方法为应用添加中间件的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>   <span class="hljs-comment">// ...</span><br>   <span class="hljs-built_in">this</span>.middleware = []<br>   <span class="hljs-comment">// ...</span><br> &#125;<br>  <br> <span class="hljs-function"><span class="hljs-title">use</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>   <span class="hljs-comment">// 检查fn</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;middleware must be a function!&#x27;</span>);<br>   <span class="hljs-comment">// ...</span><br>   <span class="hljs-built_in">this</span>.middleware.push(fn);<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>我们可以看出，调用app.use()方法后，应用会依次将中间件放入应用的属性middleware数组里，那么在哪里用到了middleware呢？答案就在最后一行的app.listen()</p><h3 id="深入探索app-listen-做了什么"><a href="#深入探索app-listen-做了什么" class="headerlink" title="深入探索app.listen()做了什么"></a>深入探索app.listen()做了什么</h3><p>遇事不决，直接读源代码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// Application.js  </span><br>  <span class="hljs-built_in">listen</span>(...args) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">const</span> server = http.<span class="hljs-built_in">createServer</span>(<span class="hljs-keyword">this</span>.<span class="hljs-built_in">callback</span>());<br>    <span class="hljs-keyword">return</span> server.<span class="hljs-built_in">listen</span>(...args);<br>  &#125;Copy<br></code></pre></td></tr></table></figure><p><a href="https://z3.ax1x.com/2021/04/16/cRfkp6.png"><img src="https://z3.ax1x.com/2021/04/16/cRfkp6.png" alt="cRfkp6.png"></a></p><p>出现了！所有Node服务端框架用到的核心模块：http</p><p>而http.createServer()的参数，也就是this.callback()的返回值，一定是一个函数，它长这个样子：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">(req, res) =&gt; &#123;<br>  <span class="hljs-regexp">//</span> Do something<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>那我们循着这个逻辑看源码里的callback函数</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">callback() &#123;<br>  <span class="hljs-keyword">const</span> fn = compose(<span class="hljs-keyword">this</span>.middleware);<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">const</span> handleRequest = (req, res) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> ctx = <span class="hljs-keyword">this</span>.createContext(req, res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.handleRequest(ctx, fn);<br>  &#125;;<br>  <span class="hljs-keyword">return</span> handleRequest;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>callback()函数做了两件事：</p><ol><li>用compose函数处理middleware数组</li><li>返回handleRequest给http.createServer作为参数，这样每收到一个请求，其实内部就会执行一次this.handleRequest</li></ol><h4 id="先说说handleRequest"><a href="#先说说handleRequest" class="headerlink" title="先说说handleRequest"></a>先说说handleRequest</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  handle<span class="hljs-constructor">Request(<span class="hljs-params">ctx</span>, <span class="hljs-params">fnMiddleware</span>)</span> &#123;<br>    const res = ctx.res;<br>    res.statusCode = <span class="hljs-number">404</span>;<br>    const onerror =<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> ctx.onerror(err);<br>    const handleResponse =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> respond(ctx);<br>    on<span class="hljs-constructor">Finished(<span class="hljs-params">res</span>, <span class="hljs-params">onerror</span>)</span>;<br>    return fn<span class="hljs-constructor">Middleware(<span class="hljs-params">ctx</span>)</span>.<span class="hljs-keyword">then</span>(handleResponse).catch(onerror);<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>这段代码做了三件事情：</p><ul><li>错误处理：新建onerror函数</li><li>onFinished监听response执行完成，来做一些资源清理工作</li><li>执行传入的fnMiddleware<br>fnMiddleware就是compose处理中间件数组返回的结果，根据后面的then可以知道，他是一个返回Promise对象的函数。在resolve后会开始执行respond逻辑。</li></ul><h4 id="【核心】compose函数对middleware做的处理"><a href="#【核心】compose函数对middleware做的处理" class="headerlink" title="【核心】compose函数对middleware做的处理"></a>【核心】compose函数对middleware做的处理</h4><p>先把compose的核心逻辑贴在下边，因为比较冗长难懂，接下来将会拆开讲</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可以不看🙈</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compose</span> (<span class="hljs-params">middleware</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Array</span>.isArray(middleware)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Middleware stack must be an array!&#x27;</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> fn <span class="hljs-keyword">of</span> middleware) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&#x27;function&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;Middleware must be composed of functions!&#x27;</span>)<br>  &#125;<br>  <br> <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, next</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> dispatch(<span class="hljs-number">0</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span> (<span class="hljs-params">i</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br>      index = i<br>      <span class="hljs-keyword">let</span> fn = middleware[i]<br>      <span class="hljs-keyword">if</span> (i === middleware.length) fn = next<br>      <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>乍一看还是混乱的，让我们简化一下逻辑：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">return <span class="hljs-keyword">function</span> (context, <span class="hljs-keyword">next</span>) &#123;<br>  <span class="hljs-regexp">//</span> last called middleware <span class="hljs-comment">#</span><br>  let index = -<span class="hljs-number">1</span><br>  return dispatch(<span class="hljs-number">0</span>)<br>  <span class="hljs-regexp">//</span> i表示预期想要执行哪个中间件<br>  <span class="hljs-keyword">function</span> dispatch (i) &#123;<br>  <span class="hljs-regexp">//</span> 先省略      <br>  &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>刚刚提到的fnMiddleware其实就是这个函数，每一次请求都会执行这里。它的参数context是上下文对象，next表示所有中间件走完之后，最后执行的一个函数。函数里标识了一个索引index， ——用于标识「上一次执行到了哪个中间件」</p><p>有了这几个概念之后，接下来就仔细看dispatch的实现，其中，i是即将执行中间件的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span> (<span class="hljs-params">i</span>) </span>&#123;     <br>   <span class="hljs-comment">// 校验预期执行的中间件（索引i），其索引是否在已经执行的中间件（索引index）之后</span><br>   <span class="hljs-keyword">if</span> (i &lt;= index) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))     <br>   <span class="hljs-comment">// 校验通过，状态改变，预期执行 =&gt; 已经执行</span><br>   index = i    <br>   <span class="hljs-comment">// 取预期执行的中间件函数</span><br>   <span class="hljs-keyword">let</span> fn = middleware[i]      <br>   <span class="hljs-comment">// 校验预期执行的中间件索引是否已经越界，是则说明中间件已经全部执行完毕</span><br>   <span class="hljs-keyword">if</span> (i === middleware.length) fn = next <span class="hljs-comment">// 越界则使用闭包的next   </span><br>   <span class="hljs-comment">// 校验fn，如果fn是undefined就直接返回一个reolved的Promise对象</span><br>   <span class="hljs-keyword">if</span> (!fn) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve()<br>   <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">// 递归调用，对中间件的执行结果包裹一层Promise.resolve</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(fn(context, dispatch.bind(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>)));<br>   &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(err)<br>   &#125;<br> &#125;Copy<br></code></pre></td></tr></table></figure><p>有些晦涩，所以我们结合上文的🌰来模拟一下一次请求的处理过程</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs lua">app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span><span class="hljs-params">(ctx, next)</span></span> &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">next</span>();<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br><br>app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">two</span><span class="hljs-params">(ctx, next)</span></span>&#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>  <span class="hljs-built_in">next</span>();<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br>&#125;);<br><br>app.use(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">three</span><span class="hljs-params">(ctx, next)</span></span>&#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>  <span class="hljs-built_in">next</span>();<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br>&#125;);Copy<br></code></pre></td></tr></table></figure><p>刚才说到，首先执行的是dipatch(0)，索引为0的是即将执行的中间件，此时index为-1，我们可以顺利的走过第一行代码的验证，并将index更新，以供后续逻辑使用</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-keyword">index</span>) <span class="hljs-keyword">return</span> Promise.reject(<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;next() called multiple times&#x27;</span>))<br><span class="hljs-keyword">index</span> = iCopy<br></code></pre></td></tr></table></figure><p>然后用fn变量来保存「即将执行」的中间件，fn是middleware[0]</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">let fn = middleware[i] <span class="hljs-regexp">//</span> <span class="hljs-keyword">function</span> one<br><span class="hljs-regexp">//</span> 下面的两个判断都通过了<br><span class="hljs-keyword">if</span> (i === middleware.length) fn = <span class="hljs-keyword">next</span><br><span class="hljs-keyword">if</span> (!fn) return Promise.resolve()Copy<br></code></pre></td></tr></table></figure><p>接下来的逻辑：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 原代码</span><br><span class="hljs-keyword">try</span> &#123;<br>   <span class="hljs-comment">// 对中间件的执行结果包裹一层Promise.resolve</span><br>  <span class="hljs-keyword">return</span> Promise.resolve(<span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">context, dispatch.bind(<span class="hljs-params"><span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span></span>)</span>))</span>;<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>  <span class="hljs-keyword">return</span> Promise.reject(err)<br>&#125;<br><br><span class="hljs-comment">// 细分成三行</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> next = dispatch.bind(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// next为函数dispatch(1)</span><br>  <span class="hljs-keyword">const</span> fnResult = <span class="hljs-function"><span class="hljs-keyword">fn</span>(<span class="hljs-params">context, next</span>)</span>; <span class="hljs-comment">// 相当于 fnResult = one(context, dispath(1))</span><br>  <span class="hljs-keyword">return</span> Promise.resolve(fnResult);<br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>  <span class="hljs-keyword">return</span> Promise.reject(err)<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>可以看到这段代码做了三件事：</p><ol><li>定义了next函数，且绑定了执行上下文和第一个参数为i+1，下一个执行的函数就是它</li><li>执行fn函数，在i为0的情况下，即第一个中间件</li><li>三是对第一个中间件执行的结果进行了Promise包装，确保返回值是Promise对象，并完成了错误的处理。</li></ol><p>第一个中间件长这个样子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span><span class="hljs-params">(ctx, next)</span></span> =&gt; &#123;<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>  <span class="hljs-built_in">next</span>();<br>  console.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>执行<code>one(context, dispatch(1))</code>就很好分析了，先<code>console.log(1)</code>，然后执行next，这一步相当于执行dispatch(1)，而dispath(1)又重新走了之前的逻辑。这样形成了递归调用，每个中间件函数所传入的next都封装了“要执行的下一个中间件”。</p><p>然后执行<code>dispatch(1)</code>，实际执行了中间件two，<code>console.log(3)</code>，next调用了中间件three···<br>如果我们打几个断点，可以看出来实际调用的函数堆栈和上文分析的相符合：</p><p><a href="https://z3.ax1x.com/2021/04/16/cRfN7j.png"><img src="https://z3.ax1x.com/2021/04/16/cRfN7j.png" alt="cRfN7j.png"></a></p><p>到了这里，下一个该执行的函数就是dispatch(3)了，这个时候</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">index = i <span class="hljs-regexp">//</span> index = <span class="hljs-number">3</span><br>let fn = middleware[i] <span class="hljs-regexp">//</span> 发生越界<br><span class="hljs-regexp">//</span> i为<span class="hljs-number">3</span>，middleware长度为<span class="hljs-number">3</span>，fn赋值为闭包的<span class="hljs-keyword">next</span>，是fnMiddleware执行时所传入的第二个参数<br><span class="hljs-keyword">if</span> (i === middleware.length) fn = <span class="hljs-keyword">next</span> <span class="hljs-regexp">//</span> 如果看了compose函数你会发现<span class="hljs-keyword">next</span>是undefined<br><span class="hljs-regexp">//</span> fn是undefined，直接返回Promise<br><span class="hljs-keyword">if</span> (!fn) return Promise.resolve()Copy<br></code></pre></td></tr></table></figure><p>next()返回的是resolved的promise对象，没有新的中间件函数入栈了，那么接下来就是出栈的过程，three继续执行console.log(6)然后是dispatch(2)结束，然后是console.log(4)···</p><p>此时我们再回头看handleRequest，当fnMiddleware设置的then回调执行的时候，所有的中间件已经执行完毕了</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  handle<span class="hljs-constructor">Request(<span class="hljs-params">ctx</span>, <span class="hljs-params">fnMiddleware</span>)</span> &#123;<br>    const res = ctx.res;<br>    res.statusCode = <span class="hljs-number">404</span>;<br>    const onerror =<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> ctx.onerror(err);<br>    const handleResponse =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> respond(ctx);<br>    on<span class="hljs-constructor">Finished(<span class="hljs-params">res</span>, <span class="hljs-params">onerror</span>)</span>;<br>    return fn<span class="hljs-constructor">Middleware(<span class="hljs-params">ctx</span>)</span>.<span class="hljs-keyword">then</span>(handleResponse).catch(onerror);<br>&#125;Copy<br></code></pre></td></tr></table></figure><h3 id="引入异步"><a href="#引入异步" class="headerlink" title="引入异步"></a>引入异步</h3><p>刚才的🌰里，引入的中间件并没有async/await的出现，那么引入async await会怎样呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.use(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">one</span>(<span class="hljs-params">ctx, next</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">await</span> next();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;);<br><br><br>app.use(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">two</span>(<span class="hljs-params">ctx, next</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span>&#123;<br>        ctx.body = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>        resolve();<br>      &#125;, <span class="hljs-number">100</span>)<br>  &#125;)<br>&#125;);Copy<br></code></pre></td></tr></table></figure><p>一样的逻辑，当one中间件执行next，到了这一步</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-keyword">next</span> = dispatch.bind(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">// next为函数dispatch(1)</span><br>  <span class="hljs-keyword">const</span> fnResult = fn(context, <span class="hljs-keyword">next</span>); <span class="hljs-comment">// 相当于 fnResult = one(context, dispath(1))</span><br>  <span class="hljs-comment">// fnResult 将在100ms后变为Resolved</span><br>  <span class="hljs-keyword">return</span> Promise.resolve(fnResult); <span class="hljs-comment">// Promise.resolve包裹住了一层promise对象</span><br>&#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>  <span class="hljs-keyword">return</span> Promise.reject(err)<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>如果Promise.resolve()接受的参数还是个Promise，那么外部的Promise会等待该内部的Promise变成resolved之后，才变成resolved</p><p>中间件执行的过程中，one中间件带有await语句，会等待two中间件执行完毕后继续执行，而实现的关键点是Promise.resolve()，如此一来便实现了洋葱圈模型：</p><p><a href="https://z3.ax1x.com/2021/04/16/cRfwhq.png"><img src="https://z3.ax1x.com/2021/04/16/cRfwhq.png" alt="cRfwhq.png"></a></p><h3 id="总结陈词"><a href="#总结陈词" class="headerlink" title="总结陈词"></a>总结陈词</h3><p>去年的<a href="https://2020.stateofjs.com/en-US/technologies/back-end-frameworks/">Stateofjs</a>问卷调查结果显示，Koa的使用率和满意度都在逐年下滑（数据来源基本在海外，国内是另外一副景象，Koa反倒很受欢迎）</p><p><a href="https://z3.ax1x.com/2021/04/16/cRff41.png"><img src="https://z3.ax1x.com/2021/04/16/cRff41.png" alt="cRff41.png"></a></p><p>出现这样的情况的原因比较容易理解。在Koa框架里写代码其实就是在写中间件，Koa只是为Node.js 的 http 模块基础上提供了一个异步 http server 的模型，它任何功能比如路由、静态文件、测试、日志、进程管理等等，都需要搭配第三方包或手动编写。</p><p>Koa没有中间件编写规范，而复杂业务需要很多第三方中间件，导致难以维护。开发者要持续关注项目中使用的第三方包，非常心累（2019年就出了一个Koa-Router项目被卖掉的事件<a href="https://www.infoq.cn/article/SsX4YwffzjG*WKVwAdxV%EF%BC%89">https://www.infoq.cn/article/SsX4YwffzjG*WKVwAdxV）</a></p><p>因此，为了统一代码结构、目录结构和稳定成熟的应用模块加持等方面，阿里在Koa的基础上开发了egg.js框架。Koa的优势是很明显的，中间件的写法非常有效率，高自由度带来的高扩展性更是给足了定制化的空间。在大型业务居多的企业里，有技术人员专门维护第三方插件也可以补足中间件混乱不规范的短板。因此Koa是一个优秀的技术选型。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>总有很多历史原因</title>
    <link href="/2021/04/03/%E6%80%BB%E6%9C%89%E5%BE%88%E5%A4%9A%E5%8E%86%E5%8F%B2%E5%8E%9F%E5%9B%A0/"/>
    <url>/2021/04/03/%E6%80%BB%E6%9C%89%E5%BE%88%E5%A4%9A%E5%8E%86%E5%8F%B2%E5%8E%9F%E5%9B%A0/</url>
    
    <content type="html"><![CDATA[<p>第一次尝试翻译，原文：<a href="https://www.hillelwayne.com/post/always-more-history/">THERE’S ALWAYS MORE HISTORY</a></p><h2 id="为什么Vim用hjkl移动上下光标而不用方向键？"><a href="#为什么Vim用hjkl移动上下光标而不用方向键？" class="headerlink" title="为什么Vim用hjkl移动上下光标而不用方向键？"></a>为什么Vim用hjkl移动上下光标而不用方向键？</h2><p><strong>常规解释</strong>：为了手指保持在一行上</p><p><strong>历史原因</strong>：Bill Joy在ADM-3A上开发了vi，而ADM-3A没有专门的箭头键。</p><p><a href="https://www.hillelwayne.com/post/always-more-history/adm-keyboard.png"><img src="https://www.hillelwayne.com/post/always-more-history/adm-keyboard.png" alt="picture of ADM keyboard"></a></p><p>看ADM键盘，箭头键是放在hjkl键上的，因此，Joy设计vi时也应用了同样的的逻辑，也自然沿用到了Vim</p><p><strong>更深度的历史</strong>：还是很奇怪，为什么ADM用hjkl当作方向键，而不是其他字母呢？</p><p>要回答这个问题，要看1967年版本的ASCII码表：</p><p><a href="https://www.hillelwayne.com/post/always-more-history/ascii-table.png"><img src="https://www.hillelwayne.com/post/always-more-history/ascii-table.png" alt="1967 ASCII table"></a></p><p>每个字符是七个bit组成的，前32个字符是‘控制字符’，对计算机通信比较重要，但并不是实际的字母，用QWERTY布局制成的键盘需要在这样的布局上保证能够输入这些字符。为了解决这个问问题，ADM的设计者引入了一个额外的‘ctrl’键，将输入从实际的字母更换成控制字符。</p><p>按住‘ctrl’ 按键的第六位和第七位最高位会清零，如果要使用退格控制字符，就直接按住ctrl + H / ^ H，就会转换100 1000为000 1000，同样，对于行分隔符，需要按 ctrl + J / ^ J</p><p>翻阅<a href="http://www.bitsavers.org/pdf/learSiegler/ADM_3/DP2880486F_ADM3A_UM_Apr86.pdf">ADM手册</a>，我们会发现ADM的“退格键”的含义是“向左移动光标”而不是删除当前字符。在已经将^ H和^ J用作左和下的情况下，将^ K和^ L变成向上和向右就很合适。这意味着ADM用户在使用hjkl作为导航，而Bill Joy开发Vi也是遵循了这个先例。</p><p>（译者题外话：很多人使用Vim时会发现esc键作为退出‘编辑模式’的按键其实非常难按到，这是因为ADM的esc是在Q键的旁边，而不是非常远的键盘左上角，因此会有很多人将esc改键到tabs或caps lock键）</p><h2 id="为什么JS的月份从0到11而不是1到12？"><a href="#为什么JS的月份从0到11而不是1到12？" class="headerlink" title="为什么JS的月份从0到11而不是1到12？"></a>为什么JS的月份从0到11而不是1到12？</h2><p><strong>常规解释</strong>：因为这样数组索引会更简单，你需要的是月份的名字而不是序号。你有一个月份名的数组并用data.getMonth()来编索引</p><p><strong>历史原因</strong>：这是与Java兼容的方式，也是与C兼容的方式。</p><p><strong>更深度的历史</strong>：那么C为什么要这么做呢？还有为什么除了月份的天数之外都是从0开始为索引？</p><p>ANSI C89标准首先正式确定了<code>tm_date</code>结构，直到今天都没有改动，这项标准在C问世后17年确立，让各种各样的Unix标准统一。如果我们回顾Unix历史，可以发现在最早的&lt;ctime.c&gt;样例是没有用结构体的，而是用了一个数组来存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEC   0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MIN   1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HOUR  2</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MDAY  3</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MON   4</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YEAR  5</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> WDAY  6</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YDAY  7</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ISDAY 8Copy</span><br></code></pre></td></tr></table></figure><p>ctime将一天中的时间存储为 秒-分-时(SMH)，但是显示是时-分-秒(HMS)，这样特殊的处理在实际使用中是有意义的，Unix 5只用这段数据展示时间给用户</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs powershell">asctime(t) <br>int *t;<br>&#123;<br>    register char *<span class="hljs-built_in">cp</span>, *ncp;<br>    register int *tp;<br><br>    <span class="hljs-built_in">cp</span> = cbuf;<br>    <span class="hljs-keyword">for</span> (ncp = <span class="hljs-string">&quot;Day Mon 00 00:00:00 1900\n&quot;</span>; *<span class="hljs-built_in">cp</span>++ = *ncp++;);<br>    ncp = &amp;<span class="hljs-string">&quot;SunMonTueWedThuFriSat&quot;</span>[<span class="hljs-number">3</span>*<span class="hljs-type">t</span>[<span class="hljs-number">6</span>]];<br>    <span class="hljs-built_in">cp</span> = cbuf;<br>    *<span class="hljs-built_in">cp</span>++ = *ncp++;<br>    *<span class="hljs-built_in">cp</span>++ = *ncp++;<br>    *<span class="hljs-built_in">cp</span>++ = *ncp++;<br>    <span class="hljs-built_in">cp</span>++;<br>    tp = &amp;t[<span class="hljs-number">4</span>];<br>    ncp = &amp;<span class="hljs-string">&quot;JanFebMarAprMayJunJulAugSepOctNovDec&quot;</span>[(*<span class="hljs-type">tp</span>)*<span class="hljs-number">3</span>]; // (a)<br>    *<span class="hljs-built_in">cp</span>++ = *ncp++;<br>    *<span class="hljs-built_in">cp</span>++ = *ncp++;<br>    *<span class="hljs-built_in">cp</span>++ = *ncp++;<br>    <span class="hljs-built_in">cp</span> = numb(<span class="hljs-built_in">cp</span>, *-<span class="hljs-literal">-tp</span>); // (b)<br>    <span class="hljs-built_in">cp</span> = numb(<span class="hljs-built_in">cp</span>, *-<span class="hljs-literal">-tp</span>+<span class="hljs-number">100</span>); // (c)<br>    <span class="hljs-built_in">cp</span> = numb(<span class="hljs-built_in">cp</span>, *-<span class="hljs-literal">-tp</span>+<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">cp</span> = numb(<span class="hljs-built_in">cp</span>, *-<span class="hljs-literal">-tp</span>+<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">cp</span> =+ <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">cp</span> = numb(<span class="hljs-built_in">cp</span>, t[<span class="hljs-type">YEAR</span>]);<br>    <span class="hljs-keyword">return</span>(cbuf);<br>&#125;<span class="hljs-built_in">Copy</span><br></code></pre></td></tr></table></figure><p>我注释了一些比较有意思的代码行，我们在(a)处第一次用到存储的月份，开发者没有把所有月份的名称存储在一个数组里，而是把每个月的三个字符的缩写存储在单个字符串中，然后把月份号作为指针算法的一部分来获取实际需要的三个字节。</p><p>然后通过指针地址递减三次来获得日期(b)，然后获得HMS日期(c) 这样，将其存储为SMH可以节省额外的显式跳转（可以通过向后迭代获得），他们利用了字段作为数组的元素存储，在内存里是紧挨着的特性</p><p>曲折的算法告诉我们他们在想尽办法做优化，这是因为Unix的第一个版本实在在PDP-7上开发的，1970年代一台像样的计算机也只有几千字节的内存，如果将所有月份名都存储在内存里，那几乎要占用总内存的10%！</p><p>因此，开发者为了尽可能少的使用内存和cpu，他们选择用指针算法来做。使用索引为0的月份要比从1开始的算法更容易实现，另一方面，除了显示给用户看，他们不会使用月份里的天数，因此以可以直接表示的方式存储</p><p>该解释还解释了结构上的一个微小的不一致：<code>MDAY</code>（月份的天）从1开始，而<code>YDAY</code>（年份的天）从0开始。这和“便于计算 vs 便于显示”的对立是保持一致的，因为从“年份的天”是从不会给用户展示的，它只用于计算夏令时的开始时间。</p><hr><p>这些解释仍然是不完整的。才两层历史，我们可以更深入研究。</p><p>对于hjkl问题，我们可以问为什么以<a href="https://textfiles.meulie.net/bitsaved/Books/Mackenzie_CodedCharSets.pdf">这种方式设计ASCII表</a>。对于<code>tm_date</code>问题，我们可以找比较早版本的Unix，看它们在汇编里做的工作，或者直接与开发人员联系。甚至那也不是最后的一层。我们可以随时往前看，越来越深挖历史。</p><p>但是就本文而言，这两层就足够了。通过两层，我们可以看到研究历史的一个共同模式：找答案和解释之间的区别。当被问及“为什么是这样”时，大多数人都会给出“事后”的合理解释。他们看到现在，倒推以这种方式会“更好”的原因。但如果稍微回看过去，就会发现“事情是这样的，因为本来就是这样”。如果你回看得更远一些，你就会发现是什么让它变成这个样子。</p><p>历史的第一层和第二层之间的差异构成了陷阱。人们看到了第一层就认为这是全部，这让历史显得无关紧要。而且即使意识到它还有更多内容，但是挖掘每一层要比之前花费更多的精力：搜索到Bill Joy使用ADM-3A机器是很快的，但是找到更深的原因，我花了两个小时。</p><p>还有一些历史层级的例子：为什么现代语言用<code>=</code>等号来进行分配？第一层是“因为C是这么干的”，第二层是<a href="https://www.hillelwayne.com/equals-as-assignment/">跟踪从ALGOL到C的语言发展链</a>。为什么这么多的面试官问链表问题？第一层是“打开面试的起手式”，第二层涉及<a href="https://www.hillelwayne.com/talks/software-history/">阅读数百条Usenet旧帖子并采访退休的程序员</a>。</p><p>但这些努力都是值得的。深入研究第二层可以使我们更多地了解上下文以及事物之所以如此的原因。我不否认有些谜题是很难，但解决掉它带来的快乐也无法拒绝：失落的知识被找回来的感觉。</p><p><em>感谢Lito Nicolai和<a href="http://alexkoppel.com/">Alex Koppel</a>的反馈。我在<a href="https://buttondown.email/hillelwayne/">时事通讯</a>上分享了这篇文章的初稿。如果您喜欢我的作品，点一个订阅吧？</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讲讲OAuth的授权认证</title>
    <link href="/2021/03/15/%E8%AE%B2%E8%AE%B2OAuth%E7%9A%84%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81/"/>
    <url>/2021/03/15/%E8%AE%B2%E8%AE%B2OAuth%E7%9A%84%E6%8E%88%E6%9D%83%E8%AE%A4%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间一直在忙SSO统一登录的事情，也算是对登录这块有了点新得体会，比之前为了应付面试死记硬背的情况好了一些，今天就先小讲一下OAUTH机制</p><p>先说说情景：你是一个初出茅庐的写代码爱好者，StackOverflow是你常上的网站。有一天你想回答一个问题，但你突然发现长久以来都是在看回帖，连账号都没有注册。于是你点击了 Log in 按钮。</p><p>你对这个问题颇有兴致，恨不得立即写下回答，但你一想到漫长的注册流程（思考密码、点这里点那里、打开邮箱等待确认邮件···）</p><p>正当你因为注册账号而预感到恼火的时候，你看到了它旁边的熟悉的Gitub的logo：章鱼猫。互联网冲浪多年的你下意识的点了上去，因为你知道，它的作用就是用Github的账号授权给StackOverflow，直接登录，轻松加愉快。（国内往往因为政策原因要继续让你用手机注册，所以体验会差些）</p><p>所以，你有没有想过它的原理是是什么呢？</p><h3 id="oauth简单原理"><a href="#oauth简单原理" class="headerlink" title="oauth简单原理"></a>oauth简单原理</h3><p>oauth全称Open Authorization（开放授权），是关于授权的开放网络标准，允许用户让第三方应用访问该用户在某一网站上存储的私密的资源。而这些“私密”资源其实也算不得什么特别隐私的，只是你的用户名、你的基础资料，它们可以标识你在互联网上的身份。而更加隐私的资料，是不能获取到的。</p><p>（你问非隐私资源？我想如果有的话就直接跨域共享了吧）</p><p><a href="https://s3.ax1x.com/2021/03/15/6B8c9g.png"><img src="https://s3.ax1x.com/2021/03/15/6B8c9g.png" alt="图片"></a></p><p>图源：RFC 6749</p><p>（A）客户端向资源拥有用户申请资源授权</p><p>（B）用户同意给予客户端授权，并返回授权凭证。</p><p>（C）客户端使用上一步获得的授权凭证，向认证服务器申请令牌。</p><p>（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。</p><p>（E）客户端使用令牌，向资源服务器申请获取资源。</p><p>（F）资源服务器确认令牌无误，同意向客户端开放资源。</p><p>资源服务器未必就和认证服务器完全分开，有可能只是不同路由的区别。</p><h3 id="以微信登录授权为例"><a href="#以微信登录授权为例" class="headerlink" title="以微信登录授权为例"></a>以微信登录授权为例</h3><ol><li>获取授权凭证-授权码authorization_code（A、B步）</li></ol><p>第三方应用（比如知乎）想要获取你的基本信息，它显示了登录页面，下面有微信登录选项。你点击了它，知乎调用了微信开放平台提供的 SDK 进行授权登录请求接入，在终端本地拉起微信进入授权页面，微信用户确认后微信再拉起第三方应用，并附带上<strong>临时</strong>授权码（authorization_code）</p><ol><li>第三方应用通过拿到的临时授权码、加上appId（第三方应用登记在微信平台的ID）、secret（appID 对应的密码）请求微信平台，获取到微信授予的access_token（C、D步）</li></ol><p>access_token是存储在客户端的（当然这块也有可能有安全性问题，这里就不讨论了）</p><ol><li>请求中携带access_token作为凭证请求资源（E、F步）</li></ol><p>由于 access_token 有效期较短，当 access_token 超时后，可以使用 refresh_token 进行刷新，也可以停掉access_token的权限</p><h3 id="仔细说说"><a href="#仔细说说" class="headerlink" title="仔细说说"></a>仔细说说</h3><p>为啥要把登录体系做的这么别扭且复杂呢？为了回答这个问题，我们可以开几个if线：</p><ul><li>如果我直接将微信用户名密码告诉第三方应用：</li></ul><p>第三方应用为了后续持续服务，保存用户的密码，而当第三方应用逐渐变多，那么只要有一个恶意应用拿到了你的密码（或者攻破了一个应用），全体GG，你互联网上的所有账号被洗劫一空</p><ul><li>如果只有临时授权码，没有appid和secret就可以获取资源：</li></ul><p>恶意第三方应用直接拿着授权码（或者盗取来的授权码）请求你的资源，再次GG</p><ul><li>如果微信服务器无法ban掉你的access_token：</li></ul><p>等同于你家里的钥匙托付给了邻居，但是邻居不还了</p><p>OAUTH是一个很高级的资源授权方式，“认证层”的出现既保证了安全性又能灵活的访问资源。</p><h3 id="授权类型"><a href="#授权类型" class="headerlink" title="授权类型"></a>授权类型</h3><p>OAuth 2.0 列举了四种授权类型，分别用于不同的场景：</p><ul><li>Authorization Code（授权码 code）：服务器与客户端配合使用。</li><li>Implicit（隐式 token）：用于移动应用程序或 Web 应用程序（在用户设备上运行的应用程序）。</li><li>Resource Owner Password Credentials（资源所有者密码凭证 password）：资源所有者和客户端之间具有高度信任时（例如，客户端是设备的操作系统的一部分，或者是一个高度特权应用程序），以及当其他授权许可类型（例如授权码）不可用时被使用。</li><li>Client Credentials（客户端证书 client_credentials）：当客户端代表自己表演（客户端也是资源所有者）或者基于与授权服务器事先商定的授权请求对受保护资源的访问权限时，客户端凭据被用作为授权许可。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021年了，为什么我还在看逃耻</title>
    <link href="/2021/02/06/2021%E5%B9%B4%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%BF%98%E5%9C%A8%E7%9C%8B%E9%80%83%E8%80%BB/"/>
    <url>/2021/02/06/2021%E5%B9%B4%E4%BA%86%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%BF%98%E5%9C%A8%E7%9C%8B%E9%80%83%E8%80%BB/</url>
    
    <content type="html"><![CDATA[<p>2021年了，我为什么还在看逃耻</p><p>我是在2016年成为Gakki的丈夫的</p><p>彼时的自己刚刚高一结束，拿着姐姐为祝我升学而买的ipad mini，用了一个暑假的时间，我在B站上看完了李狗嗨两季（当时资源还没被删）</p><p>2016年的知乎尚且余留着些许精英气息，关于李狗嗨和Gakki的各种讨论和安利屡见不鲜，谁也想不到四年后的知乎的搜索栏会是“双非三本如何考研逆袭上清华”。</p><p>而关于Gakki，这个很有魅力的“冲绳巨萝”以可爱甜美的微笑折服世人，亚洲最大重婚犯，从那时开始，我不可救药的爱上了她。</p><p><a href="https://s3.ax1x.com/2021/02/06/yYvcAH.png"><img src="https://s3.ax1x.com/2021/02/06/yYvcAH.png" alt="img"></a>)</p><p>（放一张结婚证）</p><p>而逃耻，我也是一路看下来的，这部剧从最开始的播出就有很大的反响，而且如果我这样描述它，你就会知道它就算放到现在也是时髦的：</p><p>一位无论男性女性都非常喜欢的可爱女明星</p><p>一个讨论现代婚姻新形式和独立女性生存方式的优秀剧本</p><p>一部主题是都市恋爱+狗粮的轻喜剧</p><p>一个苦逼草食系社畜娶到人妻属性拉满的大美女的剧情（这个才是重点🐶）</p><p>要素过多了，这不爆没有天理</p><p>《逃耻》是秋天播出的剧，Gakki的笑容、轻松又略带思考的剧情和温暖的氛围布景，都给那年秋天带来一片明亮。讨论也是有不少的，有关家装：</p><p>关于日剧《逃避可耻但有用》的家居装修? - 草三冉CSR的回答 - 知乎</p><p><a href="https://www.zhihu.com/question/55061189/answer/150329903">https://www.zhihu.com/question/55061189/answer/150329903</a></p><p>【考据党】剧情时间轴|平匡家平面结构图|拍摄地点</p><p><a href="https://movie.douban.com/review/8200657/">https://movie.douban.com/review/8200657/</a></p><p>有关剧情：</p><p>日剧《逃避虽可耻但有用》中，森山实栗是从什么时候开始对津崎平匡产生恋人的喜欢的？ - 时间无言的回答 - 知乎</p><p><a href="https://www.zhihu.com/question/54503093/answer/159211281">https://www.zhihu.com/question/54503093/answer/159211281</a></p><p>当年看的也是津津有味，老友甚至还在我生日的时候送了日制光碟+OST给我，至今都还放在书架上。而大学冥冥之中选择了跟男主一样的CS/SE专业，我想也是有逃耻的因素在的（笑</p><p>说起大学为什么选了这个专业，我身边的人说法都不一样。一个同事姐姐进这行是因为《微微一笑很倾城》里的肖奈（我记得馨悦学姐也是，她在博客里自曝过）一个在公检法的朋友说是因为《逆转裁判》（后来他说逆转裁判在真实法庭完全不一样，上当了）一个学五年制城乡规划的朋友说是梁思成的《拙匠随笔》（高中时候她桌子上常有没用橡皮擦干净的铅笔画设计图）</p><p>很奇妙，18岁时候的选择很大程度上决定了你的后五年乃至十多年，而你做这个决定的时候，往往是由成长过程中印象最深刻的东西影响着。以一个成年人的角度看，这属实是一个相当不理智的决策，但是这应该就是青春，这是每个人必经的第一次。</p><p>而且这些第一次来的时候，你往往没有任何经验和准备，就像2021年年初《逃耻》新春sp里的情节一样，平匡和实栗在十分突然的情况下成为人父人母。</p><p>这部sp不长，我是一边在工作室复习一边看完的。而我的感受是，好像要素都齐全了，又好像没到位。</p><p>先说逃耻最广为讨论的女性议题，职场女性怀孕、请假、男同事表达偏见，实栗纠正偏见的情节一气呵成，然后马不停蹄地转场到家庭，讲夫妻关于育儿、家务的矛盾。sp缺少了原来剧情里的轻松感，一集一个议题的节奏被一个半小时的狭小篇幅挤成了连环炮，缺少了日剧常有的一集结束时主角煽情+总结的节奏。</p><p>另外，我个人猜测是新冠疫情的原因，影片前半段和后半段的割裂极其明显，明明还没有解决前半段的问题，剧情的一场新冠就直接将全局打破，直接抛给角色们新问题。想必是2020年拍摄的时候突然遇到疫情无法继续原来的剧情拍摄，索性破罐子破摔“那我拍疫情好了”，毕竟Gakki和Gen桑的片酬还是不少的。</p><p>这样一来，东拼西凑成了一部完整剧场版的sp于2021年初赶鸭子上映，想必也是无奈之举了。</p><p>也正是因为剧情前后割裂，逃耻一直以来的“提出问题”——“讨论问题”——“产生冲突”——“交流/讨论使问题解决”——“结束点题总结”的模式没有得到发挥，流水账痕迹有些重，先是“改姓”，又是“产假”，还有因为买卫生纸引发的“成年人的崩溃往往就在一瞬间”，一切问题都飞速解决，且非常完美地解决了，这样极大地加强了整部剧给人的童话感和不真实感。</p><p>本身《逃耻》这部作品是很接地气的，社畜的真实生活状态和女性面临的就业压力等等无不体现着作者对这些话题的关注和思考。而在sp里，这些问题仿佛都不是问题一般，只要两个人相互体谅，各让一步就得到完美的解决了。</p><p>这好吗？这不好，我觉得这很取巧。</p><p>就算这部分的剧情是有原著漫画作情节支撑的，我也认为它的质量下降得明显。为什么实栗因为“麻烦”而最终选择了“改姓”，为什么平匡请产假请育儿假要靠“忽悠智商不高的上司”且是靠着连哄带吓唬的手段达成？</p><p>仔细想想，是不是不太对劲？</p><p>平匡和实栗最后的选择无非是在整个系统里用尽浑身解数达到了最优解，而且这很大程度上是归功于他们所在的优秀环境和充足的条件。但是全程看下来，他们只是每次面对问题时简单地对系统提出疑问和表达了不满，却从没做出“挑战系统”的行动或思考。</p><p>电视剧里的格局是一个小的家庭，所以两个人可以挑战传统，选择“重构”一个新式系统，可是只要将他们放在更大的系统中，放到社会、放到职场，当他们面临外部的压力，他们十分默契地选择了适应和妥协。</p><p>这是我最不喜欢逃耻sp的原因，它太幸福了，它太保守了。我得说它确确实实是一道美味的菜肴。</p><p>只可惜，没有营养。</p>]]></content>
    
    
    
    <tags>
      
      <tag>胡说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端/Web学习Roadmap</title>
    <link href="/2021/01/30/%E5%89%8D%E7%AB%AF-Web%E5%AD%A6%E4%B9%A0Roadmap/"/>
    <url>/2021/01/30/%E5%89%8D%E7%AB%AF-Web%E5%AD%A6%E4%B9%A0Roadmap/</url>
    
    <content type="html"><![CDATA[<p>前面讲了一些“鸡汤”，接下来就是站在一个前端工程师的视角上给出的学习Roadmap</p><p><strong>提前声明：书籍（包括电子书）、网站等仅供参考，是我自己的入门路径，大家不必“完美复刻”，不要忘记自己探索的重要性哦</strong></p><h3 id="第一步：爬虫"><a href="#第一步：爬虫" class="headerlink" title="第一步：爬虫"></a>第一步：爬虫</h3><p>是的，你没有看错，一个前端工程师的最开始要学习的是爬虫。</p><p>理由（新人可能看不懂，可以学会一些东西之后回头看）：</p><ul><li>爬虫包含了最基本的知识，包括网络请求处理、数据交互与存储、网页的组成等等</li><li>现代Web技术以编程语言而不是HTML等静态标记语言为核心，且常见的爬虫语言Python、Go、JS等可以作为C语言知识之外的补充</li><li>信软科班教学，从科班出身的前端人员是重应用、重开发而不是重视觉、重交互</li></ul><p>爬虫的教学有很多，个人的入门是通过这本书：</p><p><a href="https://www.ituring.com.cn/book/1980">Python网络爬虫权威指南（第2版）</a></p><p>（里面的代码，我之前曾一行一行敲了两三遍，现在回想起来也是很有意义的事）</p><p>如果你还不会Python，可以考虑用这本书入门：</p><p><a href="https://www.ituring.com.cn/book/2784">Python编程：从入门到实践（第2版）</a></p><p>如果只是入门Python，你可以只看第一部分，你感兴趣可以顺便学习后面的Django（一个后端框架）和小游戏。</p><p>网络上的课程方面，<a href="https://developer.aliyun.com/learning/roadmap/python?spm=a2c6h.21110250.9515527460.1.12613c67ONV9BY">阿里云的Python</a>感觉节奏不错，如果有其他py入门课程可以回复，让大家都看到</p><p>另外，<a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰的Python课程</a>可以作为进阶课程</p><h3 id="第二步：前端两件套"><a href="#第二步：前端两件套" class="headerlink" title="第二步：前端两件套"></a>第二步：前端两件套</h3><p>当你用BeautifulSoap库获取数据的时候，你有没有发现网页的构成是什么样的？它是一个一个结构化的标签组成的，我们看到的所有网页都不例外，“盒子模型”贯穿始终。那么它们都是什么呢？接下来就是学习HTML了</p><p>而我们在筛选标签的过程中，用到了很多标签的特性，比如颜色，它是和标签放在一起的还是分离的？相同的的标签，比如div是靠什么让我们在视觉上区分开？这些都是CSS的作用，那么，CSS也要安排一下咯</p><p>网络资源推荐（CSS也是同样的平台去学）：</p><p><a href="https://www.w3school.com.cn/html/index.asp">w3school-HTML</a></p><p><a href="https://www.runoob.com/html/html-tutorial.html">菜鸟教程-HTML</a></p><p>书籍推荐：</p><p><a href="https://www.ituring.com.cn/book/1199">HTML5与CSS3基础教程</a>（进阶书籍，先看HTML再看HTML5哦）</p><h3 id="第三步：综合运用"><a href="#第三步：综合运用" class="headerlink" title="第三步：综合运用"></a>第三步：综合运用</h3><p>恭喜你，凭借以上的知识，你已经可以完成一个网站的搭建了，不信？快回去看看Python的Web教程（阿里云和廖雪峰都有），开始学习（或者重新学习）里面的课程吧，如果你之前学习了一些却没太理解，现在的你一定会茅塞顿开</p><p>给个传送门：</p><p><a href="https://developer.aliyun.com/learning/roadmap/python?spm=a2c6h.21110250.9515527460.1.12613c67ONV9BY">阿里云-Python阶段2 Web开发</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1018138095494592">廖雪峰-Python Web APP</a></p><p>如果你喜欢书本上的课程，我推荐这一本：</p><p><a href="https://www.ituring.com.cn/book/2463">Flask Web开发：基于Python的Web应用开发实战（第2版）</a></p><p>这个时候，你已经是一个合格的前端/Web入门者了，你已经有了知识体系的初步构建和动手能力</p><h3 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h3><p>无论是爬虫还是Web App，少不了的一个部分就是数据存储。你可能会想，存储有什么呢？只要保存和读取就够了。那么如何做好保存和读取，它的形式是和我们在电脑里的文件一样吗？如果不一样，它的优势在哪里呢？</p><p>抱着这些问题，你可以开始入门数据库和SQL了，如果这个时候你已经是大二下学期，那么我很推荐你去抱着课程的书本学习，如果你还是一个小白，这本书应该可以帮助你入门</p><p><a href="http://봃觷sq뤏뮁l(鸅내2)/">SQL基础教程（第2版）</a></p><p>当然，这个时候也少不了廖雪峰</p><p><a href="https://www.liaoxuefeng.com/wiki/1177760294764384">廖雪峰的SQL课程</a></p><p>如果你已经有了数据库基础，也很对数据库技术很感兴趣，论坛里的<a href="https://d.jotang.club/t/topic/547">另一篇关于数据库的帖子</a>可能会帮到你哦（有种RPG游戏里从基础角色转职的感觉呢）</p><h3 id="第四步：网络初入门"><a href="#第四步：网络初入门" class="headerlink" title="第四步：网络初入门"></a>第四步：网络初入门</h3><p>这个阶段，你已经对整个知识体系有了初步的认识。但是我们之前做的大多数工作都是在自己的计算机上进行的，有想过把自己写的Web应用给其他人使用吗？该怎么做呢？还有一个新的问题是为什么我们，为什么很多事情只有连接上网络（WiFi或是宽带、流量）才能进行？“互联网”的本质是什么？</p><p>能回答以上问题的是计算机网络的知识，而作为初入门，你可以先看这本书：</p><p><a href="https://www.ituring.com.cn/book/1229">图解HTTP</a></p><p>（有很多图片，读起来相对简单）</p><p>如果你学有余力，还想了解更深层的计算机网络的知识，就去看这本书吧（同时它也是大二下计网课程的教材）</p><p><a href="https://book.douban.com/subject/30280001/">计算机网络</a></p><h3 id="第五步，JavaScript"><a href="#第五步，JavaScript" class="headerlink" title="第五步，JavaScript"></a>第五步，JavaScript</h3><p>JS，现代Web无法离开的语言，它随着web的浪潮起势，在它成长的过程中有了Ajax异步技术，正式宣告了前后端分离时代的诞生，09年Nodejs的诞生让JS的能量爆发，到了今天，GitHub上JS依然是最活跃的语言（甚至没有之一）</p><p>JS是极其重要的，强大的JS功底也是一个优秀的前端工程师必备的条件，那么让我们开始吧！</p><p>JS从es6（js的标准）开始突变，因此有教程是专讲es5及之前的语法，有些教程不区分es6和es5，在下面的资源推荐中会标明白</p><p>JS基础教程：</p><p><a href="https://wangdoc.com/javascript/">网道-JavaScript</a>（es5）</p><p><a href="https://zh.javascript.info/">现代JavaScript教程</a>（包含es6和es5）</p><p><a href="https://es6.ruanyifeng.com/">阮一峰ES6 入门教程</a> （只讲es6）</p><p>JS书籍</p><p><a href="https://www.ituring.com.cn/book/2472">JavaScript高级程序设计（第4版）</a>（经典红宝书，第四版应该有es6内容，存疑，非常推荐读）</p><p><a href="http://你不知道的javascript/">你不知道的JavaScript</a>（主讲es6，很喜欢的一套书，共分为上中下三卷，像一本武林秘籍）</p><p><a href="https://www.ituring.com.cn/book/42">JavaScript DOM编程艺术（第二版）</a>（可以读读）</p><p>但是以上这些还只是入门的标准，（其实我现在都不敢说自己会JS）所以，持续学习吧！</p><h3 id="第六步，但也不是第六步"><a href="#第六步，但也不是第六步" class="headerlink" title="第六步，但也不是第六步"></a>第六步，但也不是第六步</h3><p>这个小标题是什么意思呢？是说你可以不用同步地去学习了，接下来的知识可以并发学习（那么问题来了，什么是并行什么是并发呢？）</p><h4 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h4><p>如果让我推荐初学者学习哪种前端框架，我一定会说是Vue，因为它足够新手友好</p><p>网络资源推荐：</p><p><a href="https://cn.vuejs.org/v2/guide/">Vue中文官网</a>，内部有教程和规范等等，生态很好，中文文档很优秀</p><p><a href="https://godbasin.github.io/front-end-playground/vue/">被删的Vue学习教程</a> 来自勇聪、原寒的推荐，质量很有保证</p><p>而进阶知识，有本书推荐：</p><p><a href="https://www.ituring.com.cn/book/2675">深入浅出Vue.js</a></p><p>以上的这些都是Vue2的教程，Vue3即将来到，那么该如何获取知识呢？</p><p>从这个时候开始，你会发现你来到了瞬息万变的现代Web时代，你会发现在本部分之后，书籍的推荐减少了，更多是在网络上的知识。因为很多有趣有用的教程、课程是你自己搜索到的，包括但不限于B站的课程、各种在线编程培训班视频资源、CSDN、知乎、掘金等社区的优秀文章等等</p><p>很多事情是自己搜索到的，是其他人推荐的，这就是探索能力的体现</p><p>除了Vue，我更想向大家介绍Vue的作者尤雨溪，可以看看这个：<a href="https://www.bilibili.com/video/BV1iE411H71U?from=search&seid=9938655123101131915">尤雨溪的访谈视频</a></p><p>PS：之前听同事和大牛推荐过国外的前端课程<a href="https://frontendmasters.com/">Frontend Master</a>，如果你足够有💰和精力，可以选购</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="Nodejs"><a href="#Nodejs" class="headerlink" title="Nodejs"></a>Nodejs</h4><p>因为你有过用Python开发Web应用的经验，所以入门Node对你来说并不难，如果你想了解更多Node的优势，可以看看进阶知识里推荐的那本书</p><p>教程推荐：</p><p><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040">廖雪峰-Nodejs</a>（为什么总是你）</p><p>进阶知识：</p><p><a href="https://www.ituring.com.cn/book/1290">深入浅出Nodejs</a></p><h4 id="Linux知识"><a href="#Linux知识" class="headerlink" title="Linux知识"></a>Linux知识</h4><p>如果你没有在学校上Unix操作系统基础这门课，我比较推荐你看这本书：</p><p><a href="https://www.ituring.com.cn/book/171">Linux程序设计(第4版)</a></p><h4 id="React"><a href="#React" class="headerlink" title="React"></a>React</h4><p>前端两大框架里，另一个就是React，它在国外被使用的更多，而在国内没有Vue火（有多方面的原因导致，可以再开一篇帖子分析了）但这并不影响React也是一个优秀的前端“框架”，React和Vue在相互抄袭借鉴中都获得了成长</p><p>入门推荐；</p><p><a href="http://huziketang.mangojuice.top/books/react/">React小书</a></p><p><a href="https://react.docschina.org/docs/getting-started.html">React中文网</a></p><p>进阶知识？快去自己探索（其实是自己也并没有太多好的教程啦）推荐阅读国外的论坛或博客，讲解React的会很多</p><p>PS：如果大家有好的React教程、资料，可以在下面回复！</p><h4 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h4><p>如果你是网络安全方向，这块可以跳过。</p><p>Web安全是网络安全的一个重要部分，虽然现在的各大公司工种里已经将安全工程师和前后端开发区分开来，但是一本的安全知识素养还是要有，如XSS、CSRF等攻击的原理</p><p>书籍推荐：</p><p><a href="https://book.douban.com/subject/10546925/">白帽子讲Web安全</a></p><h4 id="回答一个问题"><a href="#回答一个问题" class="headerlink" title="回答一个问题"></a>回答一个问题</h4><p>你已经学习到很多了，那么有这样一个问题：</p><p>从浏览器里的地址栏里输入一串域名并回车，到一个页面展现在你面前都发生了什么事情？</p><p>如果你能回答出50字，说明你已经入门了</p><p>如果你能回答出400字，说明你已经有了Web的整体脉络</p><p>如果你能用这个题目写一篇长长的文章，事无巨细滔滔不绝，那么我要给你竖起大拇指👍</p><p>每学习一段时间，就更新一下这个问题的回答吧！这个问题可以贯穿你的学习始终</p><h4 id="Docker与服务端知识"><a href="#Docker与服务端知识" class="headerlink" title="Docker与服务端知识"></a>Docker与服务端知识</h4><p>你知道什么是LAMP/LNMP嘛？</p><p>它是Linux + Apache/Nginx + MySQL + PHP的缩写，是非常经典的一套动态网站的开源技术选型，你可以尝试用这一套东西搭建起自己的网站</p><p>（非常抱歉，这个部分没有推荐的教程，因为我自己也是零散着学习的😭 ，读者朋友们有推荐的可以在下面回复）</p><p>而Docker的出现，给前端朋友们一个快乐的方式部署自己的Web App，只需要一台云服务器即可，那么，尝试把自己写的Web App（无论是Vue项目还是React项目）部署起来，并在网络上访问它吧！</p><h4 id="小程序-Serverless"><a href="#小程序-Serverless" class="headerlink" title="小程序 + Serverless"></a>小程序 + Serverless</h4><p>如今，各家互联网公司都推出了自己的小程序应用，从微信小程序到支付宝小程序、头条小程序甚至快手小程序等等，在这样一个繁杂的“小程序”世界里，和前端是脱不开关系的，如何开发小程序，小程序的实现是什么样的，小程序的未来如何？</p><p>书籍推荐</p><p><a href="https://book.douban.com/subject/27661869/">微信小程序开发入门和实践</a>（缺点是这本书比较老了，是2017年的版本，但是可以看看）</p><p>Serverless在近年是一个很热门的话题，将“服务端”细化简化，为前端服务，Serverless在各大公司都有技术落地，且在国外也有创业公司专门做Serverless服务，代表的有<a href="https://www.netlify.com/">Netlify</a>，而微信小程序的开发也和腾讯云Serverless有很深的融合，可以多多了解</p><h4 id="其他前端-Web技术"><a href="#其他前端-Web技术" class="headerlink" title="其他前端/Web技术"></a>其他前端/Web技术</h4><ul><li>Webpack，打包工具</li><li>TypeScript，我认为会成为未来的JS技术标准（爆论）</li><li>Babel，都快成为JS APP的基石了</li><li>Electron（桌面端）</li><li>React Native、Flutter（移动端）</li><li>ES7、8、9与TC39 （当你了解了JS之后，就知道关注这些了）</li><li>Deno （Node作者最近的新作）</li><li>SSR （服务端渲染）</li><li>V8 （V8引擎，与编译技术相关）</li><li>WebAssembly（如何用其他语言开发Web）</li><li>jquery （看看曾经的王者，可以学到很多）</li><li>Wordpress/CMS （一个至今都很有价值的建一个网站的方式？）</li><li>Low-code （前端未来的技术趋势之一）</li><li>前端智能化（前端未来的技术趋势之一）</li><li>前端工程化（前端是怎么成为一个工种的）</li></ul><p>·······</p><h2 id="一些很值得推荐的教程-Book-博文链接-会议"><a href="#一些很值得推荐的教程-Book-博文链接-会议" class="headerlink" title="一些很值得推荐的教程/Book/博文链接/会议"></a>一些很值得推荐的教程/Book/博文链接/会议</h2><ul><li>现代Web开发<a href="https://zhuanlan.zhihu.com/p/88616149">https://zhuanlan.zhihu.com/p/88616149</a></li><li><a href="https://2019.jsconfchina.com/">JSConfChina</a> 看到上面的文章发现的，也很有意思</li><li><a href="https://www.alibabaf2e.com/">D2前端论坛</a> 阿里组织的论坛</li><li><a href="https://2019.stateofjs.com/">一年一度的前端技术趋势可视化</a></li><li><a href="https://jamstackconf.com/">Jamstack Conf </a>，讲web的</li><li><a href="https://dev.to/rahxuls/ultimate-roadmap-with-so-many-resources-for-front-end-development-597f">RoadMap for FrontEnd</a></li><li><a href="https://dev.to/theme_selection/how-to-become-a-pro-front-end-developer-5gbo">另一个RoadMap</a></li><li><a href="https://blog.uptrends.com/web-performance/the-psychology-of-web-performance/">The psychology of web performance</a></li><li><a href="https://stateofcss.com/">一年一度的CSS技术趋势可视化</a></li><li><a href="https://github.com/dexteryy/spellbook-of-modern-webdev">现代web魔法指南</a></li><li><a href="https://hopl4.sigplan.org/">HOPL-IV一个研究编程语言历史的会议</a></li><li><a href="https://github.com/ykfe/fe-dev-playbook">打造舒适的前端开发环境</a></li><li><a href="https://pomb.us/build-your-own-react/">Build-your-own-react</a></li><li><a href="https://basarat.gitbook.io/typescript/">TypeScript Deep Dive</a></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>对于这个Roadmap，我深知上文罗列的资源教程并不会是全网最好的，但确确实实是我自己学习的历程，大家主要可以采取和而不同的策略，拿这个做个路径参考。</p><p>而学习的时候也不要心急，因为这些看似“课外”的知识会最终与你学习的课内知识结合起来，你的知识体系是不断扩充和完善的，相信我，大二结束的时候才是你的质变。</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当我们说入门的时候，我们谈些什么</title>
    <link href="/2021/01/30/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%85%A5%E9%97%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/"/>
    <url>/2021/01/30/%E5%BD%93%E6%88%91%E4%BB%AC%E8%AF%B4%E5%85%A5%E9%97%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E8%B0%88%E4%BA%9B%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>在谈这个话题之前，我想先说说大一刚进来时候的自己。</p><p>众所周知，前后端的概念是计算机行业的新人最早、最容易接触的，无论是听周围人的言谈，还是在网络上铺天盖地的培训班，前后端是最热门的主题。</p><p>当我刚刚进入大学，还是个弱鸡🐔，没有入门的时候，我看到这些新鲜的名词感到十分头大：</p><p>CMS、Severless、Nodejs、NoSQL、Docker、Vue、MySQL、nginx、虚拟化、Python、React、Java、Spring、Golang、高并发、JavaScript、HTTP、云计算、PHP····</p><p>以上的这些（还有无数没有列出来的词汇）都与web相关，而我当时遇到这样的环境，感到了深深的迷茫，甚至开始怀疑人生：这么多技术，要学到哪年哪月去？我要怎么开始学？</p><p>最开始的时候，我采用了一种非常笨的方法：挨个查找，每一个没看过的都丢到百度百科/维基百科里，去了解它是什么，它有什么用。但是看着看着，就看不下去了，因为一个概念的定义和使用里总会衍生出新的名词，而去搜索新的名词又有新的概念出现，如此反反复复，脑子还是一团糟，完全梳理不出来知识的脉络。</p><p>于是我想，一不做二不休，从一个名词的百科描述开始，把它当作一个副本，打穿了它再去学下一个（后来我知道了上面的方法叫广度优先搜索，这个叫深度优先搜索）这个方法还是有问题，就是看的很多东西印象不深，像是高中的文科知识点一样，很容易忘记，概念与概念之间也有混淆。</p><p>两条路都走不通，该怎么做呢？焦糖的学长学姐给我的建议是： <strong>Learning by doing</strong></p><p>计算机学科是一门对实践动手能力很强的学科，而且前后端技术本身是你“看得见摸得着”的，一个页面的展示，一次请求的返回结果，都是学习中很强烈的正反馈，这是保证了“做中学”方法学习效率高的重要因素。</p><p>所以， <strong>tips第一条：“做中学”，一定要动手写代码，不能偷懒</strong></p><p>掌握了正确的学习方法，那下一步是什么呢？我猜你现在的状态是：已经拿起了锤子，在寻找着哪里可以钉钉子吧。</p><p>不要着急，我接下来要先摆明一个事实： <strong>没有适用于所有人的Roadmap，只有永远的探索</strong></p><p>如果大家到了就业的岗位上，和你的同事闲聊时谈到是怎么入门学习的，他们的回答一定是千奇百怪的。</p><p>有的同学是从初高中就接触了信息学竞赛，早早的接触到了计算机，从C语言、数据结构开始学起，之后才接触到了开发；有的同学是从小玩游戏，总寻思着搞个“盗取QQ密码”或是“破解游戏”的金手指给同学们显摆一手才学习了网络攻防知识；也有之前完全没接触过代码，甚至大学非计算机相关专业的同学因为“一个东西不怎么顺手，干脆自己搞一个”而成为了百万级下载量的开源库的作者。</p><p>一千个互联网从业者有一千个入行的路径，其实并不是前人的脚印不可以复刻，而是因为他们在路上走的太多太杂，导致所有路都被踩得平平整整。对于一个新人而言，最难的事情不是没有路可以选，而是有太多路可以选，人就懵掉了。</p><p>看技术书籍学习吗？可以</p><p>看MOOC/Bilibili上的视频学习吗？可以</p><p>看廖雪峰的博客/菜鸟教程的文档和例子学习吗？可以</p><p>你可以从千奇百怪各式各样的网站、平台上学到前后端、Web开发的知识，这就是计算机行业的魅力，它是开放共享给所有人的，而学习这些知识，没有固定的路径，没有RPG游戏里的线性打怪升级，只有开放世界的无限探索。</p><p>而在探索的过程里，你会学到很多东西，不仅仅是技术，还有计算机学科十分突出的思维。即使你踩了坑，发现了很多资源其实并不优质（比如谭浩强的C语言），但你也记住了信息筛选的重要性。当我现在站在一个从业者的位置上，回顾大学时期入门时东看看西瞧瞧的时光，我并不认为有哪些知识，哪些技术“白学了”，因为它们是一直陪伴着你的，总会在你不经意间发现它的用处。</p><p>所以， <strong>tips第二条:不留余力地探索吧，每个人都有属于自己的路，路上的所有都是收获</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>胡说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《异类》读书笔记</title>
    <link href="/2021/01/22/%E3%80%8A%E5%BC%82%E7%B1%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/01/22/%E3%80%8A%E5%BC%82%E7%B1%BB%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>因为豆瓣奇怪的审核机制，把书评写在这备个份</p></blockquote><p>在2020年，“成功学”的泡沫已经被很多人无情戳破。养生的文火慢炖心灵鸡汤滋味悠长，却再也无法触动在最近几年在社会上摸爬滚打的年轻人了。</p><p>标榜“成功学”的书籍少了，但是它的套路长盛不衰，各类公众号、百家号和专栏都有它的影子：“二本跨考逆袭清北”、“我是如何从班级吊车尾学习一年高考985的”、“字节面试算法很难？这位Offer收割机不这么认为”……</p><p>此处就是在影射某些问答网站及公众号文章。他们的回答无外乎一些基础的内容，你若说它没用，仔细想来也很对，但你要说它的内容很有营养，倒也不敢恭维。尤其是在文章的最后多半还会有个二维码，要么是卖课做广告，要么是拉人进群，美其名曰共（割）同（韭）学习（菜）</p><p>人人都想有一个万能的“key”（在软件领域的相同概念叫“银弹”）可以解决一切的问题，只要有它就可以所向披靡，无往不利。 但是根据辩证唯物主义，我们都知道，复杂的问题是不能通过简单的答案解决的。</p><p>说回这本书，它的全名叫《异类，不一样的成功启示录》，乍一听是一个很标准的成功学书籍，但仔细读来会发现这是一个讲的很清楚明白道理的强心针，颇有几分“毒鸡汤”的现实感。 通篇说来，全书的观点只有一个，用大白话讲是：</p><p><strong>一个人的奋斗固然重要,但也要考虑历史的进程</strong></p><p>这个道理很简单很清楚，但这不是一个讨人喜欢的事实，因为当你自己也身处时代的洪流之中时，它是涨潮还是退潮将很大程度上决定你一生的命运，但更大的事实是，你压根也不知道现在的时代是什么样的，只能化用狄更斯的名言：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">这是最好的时代，这是最坏的时代 <span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>书中描述了一个例子 美国的计算机时代的黎明开始于1975年，那一时期有能力把握住这个机会的群体，也是那个时候处在二十几岁年龄的那个群体。你如果太老，你不会放弃手头高薪的机会去做计算机这个不知道能用来干什么的笨重机器，你如果太年轻，也是没有能力去把握。</p><p>所以说，对于这个时代来说，最好的出生年份是1954年左右。 比尔盖茨是1955年，保罗艾伦是1953年，鲍尔默是1956年。计算机天才比尔乔伊出生于1954年，乔布斯出生于1955年，软件革命的另一位先驱，埃里克施密特也出生于1955年。</p><p>作者也提到，他并不是在说每一位计算机时代的大佬都出生于这个年代，但是这样的案例永远都是少数。所以道理就是，<strong>成功者往往是受到了机遇的特别眷顾，并且牢牢抓住了这个机遇的那一批人。和得到机会相比，勤奋努力显得太微不足道。</strong></p><p>这是一个“细思恐极”的事实，在“大势”面前，长久的努力很大可能是徒劳无功的，因为一个与你紧密相关，你却知之甚少的“时代”将决定你一生能企及的高度，而这个“看不见的手”只能由后人站在历史的角度着笔评判，像读写数据库的log记录一样写一笔，and that’s over</p><p>但是思考下来，自己好像也陷入了一个误区，“天降的机遇”难道真的就是替代了“努力”的地位，成为了走向成功的最关键因素吗？这是不是陷入了成功学的反面，完全将因果归于天命了呢？</p><p>前几天阅读了一篇文章，讲的是在1934年10月5日，上海国民党捣毁了共产党的地下秘密据点，中共的整个电台系统被摧毁，而产生的连锁反应是：在江西苏区的中央红军，因为第五次反围剿失败，准备进行战略转移。而因为无法通过电台联系到共产国际，当时的领导人博古、李德（权力完全来自共产国际的批准）逐渐离开权力中心，教员的话语权愈发强大，带领红军逆势翻盘</p><p>从某种程度上说，这一件远在上海的，看起来不起眼的小行动，居然就真的像蝴蝶效应般地，对历史的进程造成了这样大的影响。</p><p>其实很多的野史、传奇，就是笔者在这戛然而止，这就够了。但是，难道我们党的历史、我们国家的历史，就真的建立在这样一件充满巧合的事情上吗？假如电台不被摧毁，假如长征中博古等人还能得到共产国际的指示和帮助，毛泽东、红军乃至中共的命运就会完全不同吗？ 作者查阅了更多的资料，</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">我看到，早在<span class="hljs-number">1923</span>年，当时的中共中央 <span class="hljs-number">5</span> 个委员 ，就曾经对共产国际的一项提议表示了一致反对。我看到，<span class="hljs-number">1927</span>年周恩来在一次会上因为和共产国际意见不同怒而拍了桌子。<span class="hljs-number">20</span> 多年之后，周恩来还说：“拍桌子这个举动，是我平生仅有的一次。” <br><br>我看到，<span class="hljs-number">1930</span>年李立三主持中央工作的时候，更是经常把共产国际的指示放到一边，甚至公开指责共产国际远东局。 <br><br>到了<span class="hljs-number">1931</span>年的时候，对共产国际最直接的反抗出现了。 <br><br>在六届四中全会后，因为强烈反对共产国际破坏组织程序的做法，更反对王明、博古未经选举就进人党中央领导层。 <br><br>何孟雄、林育南、李求实等党内骨干在上海开秘密会议商议对策。 <span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>我并不认同那种“一件小事，改变了历史的进程”的观点，也不同意“天降猛男”的说法，历史的车轮虽然滚滚向前，但推动历史进步的总是由无数的量变引起的质变</p><p>所以话又说回来了，一个人的命运，到底是靠自我的奋斗还是历史的进程？</p><p>我对这个问题有一个最简单最朴素的答案： <strong>一个人的命运，当然要靠自我的奋斗，但是也要考虑到历史的进程。 但人生的魅力就在于，你永远也不会知道，自己处在什么样的历史进程里</strong> 如果一个人能在历史的迷雾中，穿透重重表象，透析世界、社会和人生的本质，看到了常人所不能看到的规律。 排除穿越、开天眼、以及一切无法验证的可能之后，那就只有一个终极答案： <strong>这个人成功的背后，一定是经历了更加艰苦卓绝的自我奋斗</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>胡说</tag>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年度总结-永无止境的四月</title>
    <link href="/2021/01/21/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83%E7%9A%84%E5%9B%9B%E6%9C%88/"/>
    <url>/2021/01/21/2020%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93-%E6%B0%B8%E6%97%A0%E6%AD%A2%E5%A2%83%E7%9A%84%E5%9B%9B%E6%9C%88/</url>
    
    <content type="html"><![CDATA[<p>2020年是一个奇妙的年份</p><p>在这一年的开头，我年龄的十位数字突变。如果一直处在同龄人的圈子里，感受尚且不明显。直到过年回家，身边80%的人挂在嘴边的话从“十几岁的孩子”到“他已经是一个二十多岁的小伙子了”会让你顿觉时光飞逝。</p><p>时间确实过得很快，还在大一的时候，我还有想过“女大三抱金砖”的谐音烂梗去调侃打自己两岁的姐姐，不知不觉间，充满着各种回忆的2018年离开了，迷茫的2019年也过去了，自己竟也站在了和她们同样的位置。</p><p>你若是问我，有什么感受吗？</p><p>我只能回答：没有呢，好像一切都还和以前一样。</p><p>自己总归还是有点失望的。生活慢慢走向平淡，真的是一个无法避开的事情。因为突如其来的新冠疫情，自己一直呆在家里。那段时间我还不知道我要持续这个状态七个月之久，只知道面对着电脑屏幕，很快的，一天过去了</p><p>一天过去了</p><p>又一天过去了</p><p>在这段时间里经历了从羽绒服到短袖，从在冰雪上画画到出门必仔仔细细地涂一层防晒霜的跨度，四季的更迭完全看在眼里。</p><p>不仅自然界有四季，人也是有四季的。</p><p>说到这个，我想起了和两个高中同学的一次夜话，他们中的徐君在深圳读书，而崔君打小每年都有一半的时间在深圳，算是半个“深圳人”，现在在厦门上学。</p><p>一次和他们出去吃饭，他们谈到了一个话题：“为什么我们这帮人离开东北求学后人不约而同的‘网抑云’起来”，我一马当先，以学生的立场审视，给出的结论是社会热点话题“内卷”。但他们的想法却跟我截然不同。</p><p>在十八年的时间里，我们这帮祖国东北方的汉子习惯了跟随者一年四季更迭，而在温暖的南方，“你活在一个没有任何变化的世界，无论春夏秋冬，你的环境都是一样的，树木和草本宽大的枝叶四季长青，他们在任何时候都不会衰败，它们一直在生长，一直在扩张，像一个牢笼一样将你锁在里面，你离不开，逃不出，只能眼看着它不停的长大，将你包裹”</p><p>我们的潜意识里习惯了一年里有四季，外界环境的每一次变化都在时间上刻了一笔。外部的亘古不变影响了我们的心境。当生老病死与四季轮回的暗示映射不到内心，永恒的囚徒感促使着人变得焦躁和低落。</p><p>在家的这段时间里，一个意外的收获是经典老番《凉宫春日的忧郁》（感谢阿B买了它）京阿尼在制作09版《凉宫》里有一个惊天操作震撼观众和动画界至今，就是“漫无止境的八月”事件，连续8集的内容都几乎是一模一样的（新番形式播出，相当于两个月里剧情毫无变化）但每集服饰、分镜头、角色站位和背景音乐却都不相同，画面截然不同而剧情毫无变化，不断循环暑假的枯燥。</p><p>我也找到了自己从小到大都讨厌夏天的原因，它是那样的慵懒，它是那样的灼热，它是那样的无法逃离，如同剧情里的暑假一样。</p><p>白日的炎热和干燥让人难以工作，傍晚和夜晚的清凉宁静反倒是觉得舒服</p><p>从三月的数模到四月准备面试，最后只收获了一个简单的帮忙干活的差事。没怎么学习，但是事情做了不少。现实总是不如人愿的，但是在这样的生活里寻求变化很重要。</p><p>这时候应该来句阿里味儿很浓的话：“拥抱变化”。我学马哲很粗浅，但是记住了一句话：“变化是绝对的，永无止境的，而静止是相对的，短暂的。”从这个角度上来说，阿里的这句话还真是颇具哲理。</p><p>既然变化是绝对的，那从中获得什么收获，怎样拥抱变化是值得思考的问题，而2020的下半年里，我得到了答案。</p><p>大学的时间已经过半，该体验的也都体验了，不该体验的也体验了。身为 学校里的“老油条”，开始琢磨炸“新油条”了。这个时间段里，自己是真的站在一个管理者的角度（不管是不是，反正实际上是这样的）去思考工作室的事情。如何去利用这个部分的权力？如何去与人沟通协作？怎样交代给他人任务？从一个按部就班的学生转变为社团的真正的管理者之后，视角的变化也带来了更多的问题。</p><p>我是受着焦糖的学长学姐们的帮助才成长到今天的，而到了大三这个分水岭，我能给我的学弟学妹们做些什么？</p><p>焦糖为什么是焦糖？</p><p>焦糖到底是一个怎样的工作室或是社团？</p><p>我们和其他工作室的差别在哪里？</p><p>同学们需要什么？焦糖得以存续的原因是什么？</p><p>···</p><p>Time and time again,I ask myself</p><p>这些问题至今都没有一个明确的答案，但是从组会到焦糖文创，再到Roadmap和焦糖Radio，新的焦糖人在不断探索和接近着更好的“焦糖”。</p><p>真的很感谢焦糖大家的努力。</p><p>长久以来的实践和得来的经验告诉了我，The journey is the reward. 有时候不要去想，不要犹豫，做就好了，做这件事情本身就是变化，就是生机，就是推动着事物不断前进的动力。当你回头去看的时候，即使并没有一个很好的结果，但因为你做了，旅程中的点点滴滴都是你的收获。</p><p>2020年，自己的20岁，想通了很多东西</p><p>——21.1.20 在北京断断续续写了一个月</p>]]></content>
    
    
    
    <tags>
      
      <tag>学期总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>threejs与webgl</title>
    <link href="/2020/09/29/threejs%E4%B8%8Ewebgl/"/>
    <url>/2020/09/29/threejs%E4%B8%8Ewebgl/</url>
    
    <content type="html"><![CDATA[<h2 id="最小环境"><a href="#最小环境" class="headerlink" title="最小环境"></a>最小环境</h2><p>Threejs在底层其实还是调用html5中的canvas api来实现绘图的，Threejs在底层使用的是canvas的webgl context来实现3D绘图，其中比绘制2D图像更直接对gpu操作。</p><p>Threejs在顶层对3D绘图所需的各种元素（例如场景，摄影机，灯光，几何图像，材质等）进行了封装，如果我们需要使用Threejs来绘图，需要创建一个最小绘图环境</p><p>一个最小绘图环境包含了三个要素：</p><ol><li>场景–包含所有需要显示的3D物体以及其他相关元素的容器</li><li>摄像机–决定3D场景如何投影到2D画布之上</li><li>渲染器–用于最后绘制的画笔</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import &#123; Scene, PerspectiveCamera, WebGLRenderer &#125; from ‘three’;<br><br>var scene = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Scene()</span>; <span class="hljs-comment">// 创建场景</span><br><br>var camera = <span class="hljs-keyword">new</span> <span class="hljs-constructor">PerspectiveCamera(45, <span class="hljs-params">window</span>.<span class="hljs-params">innerWidth</span> <span class="hljs-operator">/</span> <span class="hljs-params">window</span>.<span class="hljs-params">innerHeight</span>, 1, 1000)</span>; <span class="hljs-comment">// 创建摄影机</span><br>camera.position.z = <span class="hljs-number">8</span>;<br><br>var renderer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">WebGLRenderer()</span>; <span class="hljs-comment">// 创建渲染器</span><br>renderer.set<span class="hljs-constructor">Size(<span class="hljs-params">window</span>.<span class="hljs-params">innerWidth</span>, <span class="hljs-params">window</span>.<span class="hljs-params">innerHeight</span>)</span>; <span class="hljs-comment">// 设置画布大小</span><br>renderer.set<span class="hljs-constructor">PixelRatio(<span class="hljs-params">window</span>.<span class="hljs-params">devicePixelRatio</span>)</span>; <span class="hljs-comment">// 设置像素比，针对高清屏</span><br>renderer.set<span class="hljs-constructor">ClearColor(0x000000, 1)</span>; <span class="hljs-comment">// 设置默认背景色</span><br><br>document.body.append<span class="hljs-constructor">Child(<span class="hljs-params">renderer</span>.<span class="hljs-params">domElement</span>)</span>; <span class="hljs-comment">// 把画笔插入到dom中Copy</span><br></code></pre></td></tr></table></figure><p>简单的几句代码，就可以建立起一个最小绘图环境</p><p>我们还需要告诉Threejs，到底需要显示什么物体。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> &#123; Mesh, MeshBasicMaterial, BoxGeometry &#125; from ‘three’;<br><br><span class="hljs-keyword">var</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-type">BoxGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 创建一个长方体，用来定义物体的形状</span><br><br><span class="hljs-keyword">var</span> material = <span class="hljs-keyword">new</span> <span class="hljs-type">MeshBasicMaterial</span>(&#123; color: <span class="hljs-type">0xff0000 </span>&#125;); <span class="hljs-comment">// 创建一个材质，用来定义物体的颜色</span><br><br><span class="hljs-keyword">var</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-type">Mesh</span>(geometry, material); <span class="hljs-comment">// 使用形状和素材，来定义物体</span><br><br>scene.add(mesh);<br><br>renderer.render(scene, camera);Copy<br></code></pre></td></tr></table></figure><p>Threejs在定义一个3D物体时，需要提供两个信息：</p><ol><li>形状信息，也就是这个物体上每一个点，每一个面的坐标信息</li><li>材质信息，用于告诉Threejs物体的颜色，纹理，反光等信息。</li></ol><p><code>new BoxGeometry(1, 1, 1)</code>是告诉Threejs要显示一个长宽高各为1的长方形，而<code>new MeshBasicMateriall(&#123; color: 0xff0000&#125;)</code>是告诉Threejs要显示的长方形颜色是红色，最后根据形状和素材<code>new Mesh(geometry, material)</code>，生成需要显示的物体。</p><p>物体的材质用于确定物体的颜色，纹理，以及反光等属性。Threejs里的灯光设置需要设置光源</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import &#123; SpotLight &#125; from ‘three’<span class="hljs-comment">;</span><br>var light = new SpotLight(<span class="hljs-number">0</span>xffffff)<span class="hljs-comment">;、</span><br>light.position.z = <span class="hljs-number">5</span><span class="hljs-comment">;</span><br>light.position.x = <span class="hljs-number">5</span><span class="hljs-comment">;</span><br>light.position.y = <span class="hljs-number">5</span><span class="hljs-comment">;</span><br><br>scene.add(light)<span class="hljs-comment">;Copy</span><br></code></pre></td></tr></table></figure><p>MeshLambertMaterial的材质，这种材质的特点是漫反射强烈，主要用来模拟真实环境下的物体，例如木材，石料等物质的反光情况。另外Threejs还有另外一种材质叫MeshPhongMaterial，这种材质主要是镜面反射强烈，用来模拟镜子，金属等拥有高光的物体就比较合适。</p><p>如果绘制3D物体时，只能使用纯色，那也未免太单调了，没关系，Threejs提供了接口来帮忙解决这个问题。Threejs的材质，除了可以设置颜色，还支持纹理贴图，我们可以把一个图片，覆盖在3D物体上作为他的纹理</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">import</span> &#123; TextureLoader, MeshLambertMaterial &#125; <span class="hljs-keyword">from</span> ‘three’;<br><br>var texture = <span class="hljs-keyword">new</span> TextureLoader().load(‘.<span class="hljs-regexp">/assets/</span>texture/crate.gif’);<br><br>var material = <span class="hljs-keyword">new</span> MeshLambertMaterial(&#123; map: texture &#125;);<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>能绘图了，但如何加入动画？</p><p>Threejs是通过渲染器来绘图的，我们在场景中摆好灯光，摆好道具，渲染器就绘制画面。那如果要做成动画，只需要在渲染器来个定时连拍。</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> &#123;</span><br>    requestAnimationFrame(<span class="hljs-built_in">render</span>);<br>    update();<br>    renderer.<span class="hljs-built_in">render</span>(scene, camera);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> &#123;</span><br>    <span class="hljs-comment">// update your view</span><br>&#125;Copy<br></code></pre></td></tr></table></figure><p>通过requestAnimationFrame接口，来做定时刷新，每次进入render方法，都会先去执行update方法（用于更新场景），然后让渲染器拍照（renderer.render(scene, camera)），最后等待下一次render。</p><p>在update方法中，我们可以修改场景中所有物体的参数</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> <span class="hljs-keyword">update</span>() &#123;<br>    <span class="hljs-type">box</span>.rotation.x += <span class="hljs-number">0.005</span>;<br>    <span class="hljs-type">box</span>.rotation.y += <span class="hljs-number">0.01</span>;<br>&#125;<span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>这样就可以让盒子在屏幕中转动</p><p>Threejs还有很多额外的能力，例如刚刚我们使用图片作为纹理，那么我们也可以使用视频作为纹理，把这个纹理贴到一个盒子上，通过陀螺仪来控制摄像机的拍摄方向，Threejs也支持粒子系统，模型数据导入，自定义着色器等一系列高级功能</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统分析与设计</title>
    <link href="/2020/08/30/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    <url>/2020/08/30/%E7%B3%BB%E7%BB%9F%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="CH01-软件开发"><a href="#CH01-软件开发" class="headerlink" title="CH01 软件开发"></a>CH01 软件开发</h2><h3 id="软件开发困难"><a href="#软件开发困难" class="headerlink" title="软件开发困难"></a>软件开发困难</h3><ul><li>复杂性，软件规模与构建之间依赖关系复杂</li><li>一致性：软硬件平台，现有系统</li><li>可变性： 业务需求变化</li><li>不可见性：多数代码不可见</li></ul><p>软件开发的任务就是确保固有困难不会失去控制，不对项目产生较大负面影响</p><h3 id="成功主要因素分为三类"><a href="#成功主要因素分为三类" class="headerlink" title="成功主要因素分为三类"></a>成功主要因素分为三类</h3><h4 id="利益相关者"><a href="#利益相关者" class="headerlink" title="利益相关者"></a>利益相关者</h4><p>软件项目中存在利益关系的人：</p><ul><li>客户（用户和系统所有者）</li><li>开发者（分析员、设计人员、程序员）</li></ul><p>信息系统是由人（开发者）为人（客户）开发</p><p>软件失败的主要原因可以追溯到利益相关者</p><ul><li>客户<ul><li>客户需求被误解</li><li>客户需求不切实际</li><li>没有提足够资源</li><li>需求更改频繁</li></ul></li><li>开发者<ul><li>不胜任</li><li>“伟大的设计来源于伟大的设计者”</li></ul></li></ul><h4 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h4><p>软件过程定义完整软件生产和维护的所有活动的组织流程</p><p>软件过程模型（软件开发模型/软件生存周期模型）：</p><ul><li>声明所执行活动的次序</li><li>详细说明要开发的是什么产品什么时候交付</li><li>将活动与人工制品分配给开发者</li><li>提供用来监控项目进展、评估结果和未来项目的标准</li></ul><p>不易标准化，不同软件项目采用相应的软件过程模型</p><p>现代软件开发过程总是迭代与增量</p><p>迭代是短周期的，用户反馈是频繁的，规划是持续的</p><p>迭代与增量过程模型：</p><ul><li>螺旋模型</li><li>Rational统一过程(RUP)</li><li>模型驱动的体系结构(MDA)</li><li>敏捷开发过程</li><li>面向方面的软件开发</li></ul><p>迭代与增量开发：</p><ul><li>必须遵循特定体系结构设计框架</li><li>必须有计划有控制</li></ul><h4 id="CMM能力成熟度模型"><a href="#CMM能力成熟度模型" class="headerlink" title="CMM能力成熟度模型"></a>CMM能力成熟度模型</h4><p>有关软件工程和管理实践的最好的软件过程评估模型</p><ol><li>初始级，有能力的人与个人英雄主义</li><li>可重复级，基本项目管理</li><li>已定义级，过程标准化</li><li>量化管理级，量化管理</li><li>优化级，持续的过程改进</li></ol><h4 id="ITIL-ISO9000-COBIT"><a href="#ITIL-ISO9000-COBIT" class="headerlink" title="ITIL ISO9000 COBIT"></a>ITIL ISO9000 COBIT</h4><p>ITIL（Information Technology Infrastructure Library）是被最广泛使用和接受的、用于IT服务管理的最佳实践的框架</p><p>ISO 9000系列质量标准：如果过程是正确的，那么过程的结果（产品或服务）也将是正确的</p><p>COBIT是目前国际上通用的信息系统审计的标准，定义信息及相关技术的控制目标</p><p>ITIL、CMM和ISO 9000是过程标准，COBIT则是产品标准</p><h4 id="软件建模"><a href="#软件建模" class="headerlink" title="软件建模"></a>软件建模</h4><p>软件建模是指对软件系统进行抽象描述的活动，各个阶段都可以用建模工具对软件系统进行建模描述</p><ul><li>系统规划模型</li><li>系统需求模型</li><li>系统设计模型</li><li>软件实现模型</li><li>系统部署模型</li><li>系统测试模型</li></ul><p>建模必须：</p><ul><li>沟通（语言）</li><li>文档化（工具）</li></ul><p>统一建模语言（UML）是一个通用的、可视化的建模语言</p><p>计算机辅助软件工程（CASE）工具使得在中央存储库中实<br>现模型的存储和检索成为可能</p><h4 id="统一建模语言UML"><a href="#统一建模语言UML" class="headerlink" title="统一建模语言UML"></a>统一建模语言UML</h4><p>UML独立于</p><ul><li>任何开发过程：面向对象</li><li>任何实现技术：面向对象</li></ul><p>UML模型包括</p><ul><li>状态模型：描述静态数据结构</li><li>行为模型：描述对象协作</li><li>状态变化模型：描述随时间推移系统所允许的状态</li><li>体系结构构造：通用，无框架</li></ul><h4 id="软件开发策略"><a href="#软件开发策略" class="headerlink" title="软件开发策略"></a>软件开发策略</h4><ol><li>定制开发，按照特定的需求对系统进行完整开发实现</li><li>集成开发，基于现有系统和接口进行新软件系统和外部系统整合开发</li></ol><h3 id="系统规划"><a href="#系统规划" class="headerlink" title="系统规划"></a>系统规划</h3><p>对信息系统项目进行规划：识别、分类、排序和选择</p><ol><li>SWOT方法：优势、劣势、机会、威胁</li></ol><p>以调整组织的优势、劣势、机会和威胁的方式，来进行信息系统的识<br>别、分类、选择和排序，从确定组织使命开始，自顶向下</p><ol><li>VCM方法（价值链模型，value chain model）</li></ol><p>通过分析组织中完整的活动链（如：从原材料到销售及运送给客户的最终产品）来评估竞争优势</p><ol><li>Business Process Re-engineering，业务过程重组，过程再设计</li><li>ISA方法（information system architecture）</li></ol><h3 id="三级管理系统"><a href="#三级管理系统" class="headerlink" title="三级管理系统"></a>三级管理系统</h3><ul><li>策略级，支持组织长期目标的策略，知识，知识处理系统</li><li>战术级，支持短期目标和资源分配的政策，信息，分析处理系统</li><li>操作级，员工日常活动和生产支持，数据，事务处理系统</li></ul><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h4><p>结构化方法是以过程为中心的软件开发方法，由结构化分析方法、结构化设计方法和结构化程序设计方法组成。</p><ul><li>过程建模：数据流图（DFD）</li><li>数据建模：实体关系图（ERD）</li></ul><p>优点：简单实用、技术成熟、容易应用。</p><p>缺点：</p><ul><li>与现代软件工程不一致</li><li>顺序和转换的方法，而不是迭代和递增的</li><li>倾向于交付僵化的解决方案来满足已识别的业务功能集</li><li>假设开发从零开始，不支持已有构件的复用</li><li>对规模较大及处理复杂的软件系统项目不太适合，难以适应需求变更</li><li>难以解决软件复用，难以进行软件维护，难以提高软件生产效率等</li></ul><h4 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h4><p>面向对象方法是一种将面向对象思想应用于软件开发过程、指导软件开发活动的方法。</p><p>数据为中心——围绕类模型演化<br>– 但UML中用例的日渐重要性稍微的将重点从数据转向了过程</p><h4 id="生命周期的阶段"><a href="#生命周期的阶段" class="headerlink" title="生命周期的阶段"></a>生命周期的阶段</h4><ul><li>业务分析/需求分析</li><li>功能性和非功能性需求</li><li>系统设计<ul><li>体系结构设计</li><li>详细设计</li></ul></li><li>实现<ul><li>编码</li></ul></li><li>集成和部署</li><li>运行和维护</li></ul><h4 id="跨越生命周期的活动"><a href="#跨越生命周期的活动" class="headerlink" title="跨越生命周期的活动"></a>跨越生命周期的活动</h4><ol><li>项目规划<ul><li>估计项目的可交付性、代价、时间、风险、里程碑和资源需求</li><li>选择开发方法、过程、工具、标准、团队组织</li><li>随生命周期而改进</li><li>典型的约束是时间和费用</li></ul></li><li>度量<ul><li>度量开发时间和工作量，度量软件产品的质量和复杂性</li><li>在生命周期的不同阶段度量开发模型→评估过程的有效性和改进生命周期不同阶段的工作质量</li><li>没有对过去项目的度量，组织就无法精确计划未来的项目</li><li>测试</li><li>审查：规格说明等文档（包括程序源代码）</li><li>动态测试：规格说明测试（黑盒测试）、代码测试（白盒测试、玻璃盒测试）</li></ul></li></ol><h4 id="开发模型与方法"><a href="#开发模型与方法" class="headerlink" title="开发模型与方法"></a>开发模型与方法</h4><p>迭代和增量开发的代表性模型</p><ul><li>螺旋模型</li><li>IBM Rational统一过程（RUP）RUP统一过程模型是一种用例驱动的、增量迭代的、以体系结构为中心的软件开发流程框架，</li><li>模型驱动的体系结构（MDA）使用模型完成软件的分析、设计、构建、部署、维护等各开发活动</li><li>敏捷软件开发,适应不断变化的需求</li><li>面向方面的开发,为定义、说明、设计和构建方面/Aspect提供过程和方法</li></ul><h2 id="CH02-需求确定"><a href="#CH02-需求确定" class="headerlink" title="CH02 需求确定"></a>CH02 需求确定</h2><h3 id="业务过程建模"><a href="#业务过程建模" class="headerlink" title="业务过程建模"></a>业务过程建模</h3><h4 id="BPMN业务过程图（Business-Process-Model-andNotation，BPMN）"><a href="#BPMN业务过程图（Business-Process-Model-andNotation，BPMN）" class="headerlink" title="BPMN业务过程图（Business Process Model andNotation，BPMN）"></a>BPMN业务过程图（Business Process Model andNotation，BPMN）</h4><p>目的是为业务人员和IT人员提供共同的沟通语言，即是泳道图</p><ul><li><p>流对象，事件、活动、路由</p></li><li><p>连接对象，序列流、消息流、关联</p></li><li><p>泳道，一个业务实体</p></li><li><p>人工制品，数据对象、组、注释</p><p>过程是分层的，过程可能包含其他过程，过程中的原子活动叫做任务</p><h4 id="UML活动图"><a href="#UML活动图" class="headerlink" title="UML活动图"></a>UML活动图</h4><p>UML活动图是一种用于描述系统行为的模型图，它可用来描述过程（业务过程、工作流、事件流等）中的活动及其迁移</p></li></ul><ol><li>描述用例的行为,建模用例工作流</li><li>理解工作流程，画出业务工作流活动图</li><li>描复杂过程的算法</li></ol><ul><li>活动<ul><li>活动起点</li><li>活动终点</li><li>动作状态</li><li>活动状态</li><li>组合活动</li></ul></li><li>转换/转移<ul><li>描述一个活动转向另一个活动</li><li>带箭头的实线段，箭头指向转向的活动</li><li>转换上可以用文字标识转换发生的条件</li></ul></li><li>分叉与汇合</li><li>分支与合并</li><li>泳道</li><li>对象流</li></ul><h3 id="需求引导"><a href="#需求引导" class="headerlink" title="需求引导"></a>需求引导</h3><h4 id="软件需求（Software-Requirement）"><a href="#软件需求（Software-Requirement）" class="headerlink" title="软件需求（Software Requirement）"></a>软件需求（Software Requirement）</h4><p>是一个软件系统所需具有的功能与性能要求，它描述了待开发软件系统的行为、特性、属性及其约束条件</p><p>系统服务： 功能性需求<br>系统约束： 非功能性需求</p><h5 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h5><ol><li>性能<ul><li>响应时间</li><li>吞吐量</li><li>并发用户数</li></ul></li><li>可用性</li><li>可靠性</li><li>效率</li><li>适应性</li><li>复用性</li></ol><h5 id="需求的来源"><a href="#需求的来源" class="headerlink" title="需求的来源"></a>需求的来源</h5><p>最基本的需求来源就是用户需求。它反映了用户对系统的功能与性能等方面的要求</p><h5 id="需求引导的传统方法"><a href="#需求引导的传统方法" class="headerlink" title="需求引导的传统方法"></a>需求引导的传统方法</h5><ul><li>面谈</li><li>调查表</li><li>观察/业务示范</li><li>研究文档和软件系统</li></ul><h5 id="需求引导的现代方法"><a href="#需求引导的现代方法" class="headerlink" title="需求引导的现代方法"></a>需求引导的现代方法</h5><ul><li>原型法</li><li>头脑风暴</li><li>联合应用开发(Joint application development,JAD)</li><li>快速应用开发(Rapid application development,RAD)</li><li>基于用例的方法</li></ul><h3 id="需求协商与确认"><a href="#需求协商与确认" class="headerlink" title="需求协商与确认"></a>需求协商与确认</h3><p>需要“需求协商与确认”的原因</p><ul><li>可能是重叠与矛盾的，需要用需求依赖矩阵</li><li>可能是模棱两可或者不现实的</li><li>可能未被发现</li><li>可能超出范围</li><li>“需求协商”从需求文档的草稿开始，删除错误的需求，<br>增加新发现的需求</li><li>“需求确认”正式评审文档并‘盖章’（复审会议）</li></ul><h3 id="需求管理"><a href="#需求管理" class="headerlink" title="需求管理"></a>需求管理</h3><h4 id="需求标识与分类"><a href="#需求标识与分类" class="headerlink" title="需求标识与分类"></a>需求标识与分类</h4><p>需求采用自然语言陈述，大量需求陈述</p><p>标识与分类方案</p><ul><li>唯一标识符：通常是顺序号<ul><li>如有可能，由数据库产生（最灵活和不易出错）</li><li>如有可能，包含版本号</li></ul></li><li>在文档层次中的顺序编号：根据需求在文档中的位置</li><li>第2章第3节的第7条需求被编号为2.3.7 – 在需求分类中的顺序编号</li></ul><h4 id="需求层次"><a href="#需求层次" class="headerlink" title="需求层次"></a>需求层次</h4><p>需求可按父-子关系建立层次结构</p><h4 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h4><p>软件开发的任何阶段，需求都可能变更</p><h4 id="需求跟踪"><a href="#需求跟踪" class="headerlink" title="需求跟踪"></a>需求跟踪</h4><p>需求跟踪贯穿整个开发生命周期的需求变更</p><p>需求跟踪的方式：</p><ul><li>正向跟踪：检查《产品需求规格说明书》中的每个需求是否都能在后继工作成果中找到对应点。</li><li>逆向跟踪：检查设计文档、代码、测试用例等工作成果是否都能在《产品需求规格说明书》中找到出处。</li></ul><h4 id="需求业务模型"><a href="#需求业务模型" class="headerlink" title="需求业务模型"></a>需求业务模型</h4><p>业务用例模型-UML业务用例图</p><p>业务用例图主要包含业务参与者、业务用例、以及它们之间<br>的关系</p><p>主要参与者和次要参与者（外部实体）</p><ul><li>很多参与者对系统来说既是内部的又是外部的</li><li>业务用例模型中重要的关系是关联关系</li><li>需求分析阶段，业务用例图被转换为用例图，并完成详细<br>的用例规约</li></ul><h4 id="需求文档"><a href="#需求文档" class="headerlink" title="需求文档"></a>需求文档</h4><h5 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h5><p>针对目标管理者和决策制定者</p><ul><li>从项目的目的和范围开始</li><li>业务环境：为系统作一个业务案例</li><li>标识利益相关者</li><li>为解决方案提供初始想法<ul><li>包含现成的解决方案</li><li>现成的解决方案并不能省去需求分析与系统设计</li></ul></li><li>包含对文档其余部分的综述</li></ul><h5 id="系统服务"><a href="#系统服务" class="headerlink" title="系统服务"></a>系统服务</h5><p>专门讲系统服务的定义：系统必须完成什么</p><p>很可能占据整个文档的一大半</p><p>包含高层需求业务模型</p><ul><li>系统范围：环境图</li><li>功能需求：业务用例图</li><li>数据需求：业务类图</li><li>业务词汇表放在附录</li></ul><h5 id="系统约束"><a href="#系统约束" class="headerlink" title="系统约束"></a>系统约束</h5><ul><li>界面需求：</li><li>性能需求：</li><li>安全性需求：</li><li>操作性需求：</li><li>政策和法律需求</li><li>其他约束：</li></ul><h5 id="项目其他问题"><a href="#项目其他问题" class="headerlink" title="项目其他问题"></a>项目其他问题</h5><ul><li>待解决问题</li><li>初步计划</li><li>初步预算</li></ul><h5 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h5><ul><li>词汇表</li><li>业务文档和表格</li><li>参考文献</li></ul><h2 id="CH03-可视化建模基础"><a href="#CH03-可视化建模基础" class="headerlink" title="CH03 可视化建模基础"></a>CH03 可视化建模基础</h2><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h3><p>模型是系统的一种抽象表示</p><p>建模就是对系统进行抽象描述，使人们能够通过其模型去理解与<br>设计系统</p><ol><li>建模系统具有如下好处：<ul><li>通过创建系统的模型，可使人们便于理解、分析与设计系统</li><li>通过模型可发现与解决系统中的问题，其成本低</li><li>模型可帮助进行系统项目的计划、交流、评估和管理</li></ul></li><li>软件系统建模原则<ul><li>准确原则，模型必须准确地反映系统的真实情况</li><li>分层原则，模型以不同的抽象程度反映系统</li><li>分治原则，需要采用分治方法把问题分解为多个子模型来处理</li><li>标准原则，模型应该是通用的和标准的，这样便于交流与重用</li></ul></li></ol><h4 id="UML特点"><a href="#UML特点" class="headerlink" title="UML特点"></a>UML特点</h4><ol><li>规范并统一了面向对象模型元素的定义和表示法，以及对模型表示的规定，使得对系统的建模有章可循。有标准的语言工具可用，有利于保证系统的建模质量。</li><li>提供了简洁地达面向对象中的各种概念和模型元素的能力。UML能够在尽可能简单的同时，满足对实际开发的需要，对系统的各个方面进行建模。</li><li>可视化、表示能力强。系统的逻辑模型或实现模型均可用UML模型图形清晰表示，并提供用户的扩展支持，可以处理现代软件开发中出现的所有概念。</li><li>通用语言，具有庞大的标准符号体系，提供了多种模型，独立于开发过程。可支持其他面向对象开发和传统的软件开发过程。</li><li>文档化语言，能够为系统体系结构和细节建立文档</li></ol><h4 id="利用UML进行软件开发"><a href="#利用UML进行软件开发" class="headerlink" title="利用UML进行软件开发"></a>利用UML进行软件开发</h4><p>需求确定阶段</p><ul><li>捕获用户需求，建立用例模型，描述对系统感兴趣的外部角色及对系统的功能要求</li><li>采用业务用例图描述系统业务，确定项目范围</li></ul><p>系统分析阶段</p><ul><li>采用用例图和文档描述系统的功能需求</li><li>关心问题域中的主要概念（如类和对象等）和机制，识别类以及它们相互间的关系，并用UML类图来描述</li><li>为实现用例，类之间需要协作，用UML动态模型描述，采用活动图、顺序图、通信图、状态机图等描述系统逻辑流程、对象间交互等</li><li>文档编制人员采用用例图和文档编写用户手册和培训计划</li></ul><p>系统设计阶段</p><ul><li>使用构件图、部署图、包图，定义软件系统体系结构</li><li>采用类图、对象图等定义软件系统构件技术细节</li><li>使用活动图、状态机图、顺序图、通信图等描述系统的逻辑流程、</li></ul><p>系统实现阶段</p><ul><li>用面向对象编程语言将设计阶段的类转换成代码</li></ul><p>系统测试阶段</p><ul><li>单元测试使用类图和类规格说明</li><li>集成测试使用构件图和通信图</li><li>系统测试使用用例图</li><li>验收测试由用户进行，以验证系统测试的结果是否满足在分析阶段<br>确定的需求</li></ul><h2 id="CH04-需求规格说明"><a href="#CH04-需求规格说明" class="headerlink" title="CH04 需求规格说明"></a>CH04 需求规格说明</h2><p>软件体系结构定义了系统中相互作用的软件构件及子系统的<br>结构和组织形式。</p><h3 id="结构化分析方法"><a href="#结构化分析方法" class="headerlink" title="结构化分析方法"></a>结构化分析方法</h3><table><thead><tr><th></th><th>建模方法</th><th>模型表示</th></tr></thead><tbody><tr><td>功能建模</td><td>数据流分析方法</td><td>数据流图,层次数据流图,数据字典</td></tr><tr><td></td><td>IDEF0分析方法</td><td>活动数据图</td></tr><tr><td>数据建模</td><td>语义数据模型方法</td><td>实体-关系图（ER图）</td></tr><tr><td></td><td>IDEF1X模型方法</td><td>IDEF1X图例</td></tr></tbody></table><h3 id="面向对象分析方法"><a href="#面向对象分析方法" class="headerlink" title="面向对象分析方法"></a>面向对象分析方法</h3><table><thead><tr><th>建模方法</th><th>模型表示</th></tr></thead><tbody><tr><td>UML</td><td>用例图、活动图、顺序图等</td></tr><tr><td>OOSE</td><td>用例图、对象图、交互作用图、状态图等</td></tr><tr><td>Booch</td><td>对象图、状态跃迁图、交互作用图等</td></tr><tr><td>OMT</td><td>文本化的用例、事件跟踪图、事件流图、状态图、数据流图等</td></tr><tr><td>OOA/OOD</td><td>OOA图、对象状态图、服务图等</td></tr></tbody></table><h3 id="需求规格说明"><a href="#需求规格说明" class="headerlink" title="需求规格说明"></a>需求规格说明</h3><p>需求规格说明是客户和开发小组对将要开发的系统产品达成的一致协议。这一协议综合了业务需求、用户需求和软件功能和性能需求。它将作为系统开发、验证、评审最基本的依据和最重要的文档。</p><p>建立图形化模型，描绘转换过程、系统状态变化、数据关系、逻辑流程和它们的关系。</p><h4 id="需求规格说明书的使用对象"><a href="#需求规格说明书的使用对象" class="headerlink" title="需求规格说明书的使用对象"></a>需求规格说明书的使用对象</h4><ul><li>客户和营销部门：了解他们所能提供的产品</li><li>项目经理：制定规划并预测进度安排、工作量和资源</li><li>软件开发小组：理解他们将要开发的产品</li><li>测试小组：制定测试计划、测试用例和测试过程</li><li>软件维护和支持人员：了解产品的某部分是做什么的</li><li>产品发布组：在需求规格说明书和用户界面设计的基础上编写<br>客户文档，如用户手册和帮助屏幕等。</li><li>培训人员：根据需求规格说明书和用户文档编写培训材料。</li></ul><h3 id="状态规格说明"><a href="#状态规格说明" class="headerlink" title="状态规格说明"></a>状态规格说明</h3><p>状态规格说明提供系统的结构视图（静态视图）</p><p>主要任务是定义应用领域的类、类的属性、以及与其它类的关系</p><p>UML中使用类图（Class Diagram）和对象图（Object Diagram）进行状态规格说明</p><h4 id="类建模"><a href="#类建模" class="headerlink" title="类建模"></a>类建模</h4><p>类建模不是一个确定的过程，是高度迭代增量式</p><h5 id="发现类"><a href="#发现类" class="headerlink" title="发现类"></a>发现类</h5><ol><li><p>名词短语方法，将每一个名词或名词短语认为一个候选类，分成相关类、模糊类、无关类</p></li><li><p>公共模式方法：分类理论将对象世界划分成有用的组</p></li><li><p>用例驱动方法，根据用例图、用例规约、行为和交互模型来发现候选类</p></li><li><p>CRC方法，类-职责-协作者Classes-Responsibilities-Collaborators），分析对象之间为完成业务功能而进行的协作来识别类</p><p>头脑风暴式的集体讨论，使用一种特殊制作的卡片，卡片包含3栏：</p><ul><li>类名：最上面的分栏</li><li>类职责：左边的分栏</li><li>协作者：右边的分栏</li></ul></li><li><p>混合方法发现类的实际过程，常常是以上几种方法的混合</p></li></ol><h2 id="CH05-从分析到设计"><a href="#CH05-从分析到设计" class="headerlink" title="CH05 从分析到设计"></a>CH05 从分析到设计</h2><h3 id="高级类建模"><a href="#高级类建模" class="headerlink" title="高级类建模"></a>高级类建模</h3><h4 id="可见性与封装"><a href="#可见性与封装" class="headerlink" title="可见性与封装"></a>可见性与封装</h4><ul><li>私有可见性（-）</li><li>公共可见性（+）</li><li>保护可见性（#）</li><li>包可见性（~）</li></ul><h4 id="关联类与具体化类"><a href="#关联类与具体化类" class="headerlink" title="关联类与具体化类"></a>关联类与具体化类</h4><p>关联类：是一个关联，也是一个类</p><ul><li>如果两个类之间是多对多的关联，每个关联实例具有属性值，则使用关联类</li><li>关联类的约束：对于每一对链接起来的类的实例，只能存在关联类的一个实例</li></ul><p>如果不能满足该约束，则将关联具体化，使用普通类代替关联类（具体化类）</p><h3 id="高级泛化与继承建模"><a href="#高级泛化与继承建模" class="headerlink" title="高级泛化与继承建模"></a>高级泛化与继承建模</h3><p>泛化是类之间的语义关系，泛化关系用来描述类的一般和具体之间的关系，表明“是一种”关系。泛化的目的是“继承”、“可替换”、“多态性”</p><p>继承是一种机制，通过继承特殊的元素可以合并一般元素中定义的结构和行为</p><p>封装与继承是正交的,通过继承，封装可以被打破</p><p>封装和查询能力是正交的– 用户依靠SQL访问数据库，直接查阅属性证明是有效的</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类是对一组具有相同属性和方法的逻辑上有关系的事物的一种抽象</p><p>接口是对一组具有相同属性和方法的逻辑上不相关的事物的一种抽象</p><h3 id="高级聚合与委托建模"><a href="#高级聚合与委托建模" class="headerlink" title="高级聚合与委托建模"></a>高级聚合与委托建模</h3><p>聚合表示类之间的“整体和部分”关系。整体称为“复合类”，部分称为“构件类”</p><ul><li>ExclusiveOwns专属聚合</li><li>Member成员聚合</li><li>Owns从属聚合</li><li>Has拥有聚合</li></ul><h3 id="高级交互技术"><a href="#高级交互技术" class="headerlink" title="高级交互技术"></a>高级交互技术</h3><ul><li>说明基本技术</li><li>创建与销毁对象</li><li>结构化控制</li><li>alt条件片段、opt选择片段</li><li>loop循环片段</li><li>交互使用,是一个外围交互对另一个交互的引用</li></ul><h2 id="CH06-系统与程序设计"><a href="#CH06-系统与程序设计" class="headerlink" title="CH06 系统与程序设计"></a>CH06 系统与程序设计</h2><h3 id="体系结构与模式"><a href="#体系结构与模式" class="headerlink" title="体系结构与模式"></a>体系结构与模式</h3><ol><li>体系结构设计是从系统的模块方面对系统进行描述<ul><li>定义类和包的分层组织</li><li>将进程分配给计算设施</li><li>复用和构件管理</li></ul></li></ol><p>软件体系结构定义了系统中相互作用的软件构件及子系统的结构和组织形式</p><p><strong>至关重要：在详细的系统规格说明之前，选定体系结构模式和原则</strong></p><ol><li>详细设计是对每个模块（用例）内部工作的描述<ul><li>设计算法和数据结构</li><li>描述（实现用例的）协作模型</li></ul></li></ol><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式阐述了一个在软件系统设计和实现中反复出现的问题，记录了软件开发领域已得到充分证明的经验和良好的设计实践</p><h4 id="架构模式-体系结构模式"><a href="#架构模式-体系结构模式" class="headerlink" title="架构模式/体系结构模式"></a>架构模式/体系结构模式</h4><p>描述了在特定设计情形下反复出现的问题，并提供了已经得到充分证明的通用解决方案摘要。解决方案描述模式的组件、组件的职责和关系、以及这些组件协作的方式。</p><p>架构模式是软件架构（体系结构）的模板，描绘应用程序的系统级结构特征，并将影响子系统的架构。</p><h5 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h5><p>将程序分成三部分：处理、输出、输入</p><ul><li>模型组件（Model）：封装核心数据和功能，独立于输入和输出</li><li>视图组件（View）：向用户显示信息，一个模型可以有多个视图</li><li>控制器组件（Controller）：每个视图都有相关联的控制器组件，处理用户输入</li></ul><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><ul><li>外观（Façade）</li><li>抽象工厂（Abstract Factory）</li><li>责任链（Chain of Responsibility）</li><li>观察者（Observer）发布-订阅模式</li><li>中介者（Mediator）</li><li>Whole-Part（整体-部分）</li><li>Master-Slave（主-从）</li><li>Proxy（代理）</li><li>Command Processor（命令处理器）</li><li>View Handler(视图管理者)</li><li>Forwarder-Receiver（转发者-接收者）</li><li>Client-Dispatcher-Server（客户端-分配器-服务器）</li></ul><h4 id="体系结构设计"><a href="#体系结构设计" class="headerlink" title="体系结构设计"></a>体系结构设计</h4><ul><li>逻辑体系结构<ul><li>关注系统中相互作用的软件构件及子系统的结构和组织形式</li><li>使用UML构件图和UML包图建模</li></ul></li><li>物理体系结构<ul><li>关注部署方案的选择以及系统的工作负荷在多处理器上的分布</li><li>将处理构件分配给计算机结点</li><li>使用UML部署图建模</li></ul></li></ul><h4 id="体系结构建模"><a href="#体系结构建模" class="headerlink" title="体系结构建模"></a>体系结构建模</h4><ul><li>构件图</li><li>部署图</li><li>包图</li></ul><h2 id="CH07-GUI用户图形界面"><a href="#CH07-GUI用户图形界面" class="headerlink" title="CH07 GUI用户图形界面"></a>CH07 GUI用户图形界面</h2><h3 id="界面元素"><a href="#界面元素" class="headerlink" title="界面元素"></a>界面元素</h3><p>界面元素: 窗口、菜单、 按钮、标签、 滚动条、 下拉列表、 状态栏等<br>界面操作机制: 导航机制 输入机制 输出机制</p><h3 id="良好的特性"><a href="#良好的特性" class="headerlink" title="良好的特性"></a>良好的特性</h3><ol><li>易用性，操作简单方便</li><li>灵活性，可灵活处理</li><li>安全性，操作有效</li><li>艺术性，赏心悦目</li></ol><h3 id="GUI设计原则"><a href="#GUI设计原则" class="headerlink" title="GUI设计原则"></a>GUI设计原则</h3><ol><li>方便用户控制</li><li>提供定制化</li><li>界面美观</li><li>界面一致</li><li>减少用户记忆负担</li></ol><h3 id="桌面GUI设计"><a href="#桌面GUI设计" class="headerlink" title="桌面GUI设计"></a>桌面GUI设计</h3><p>主窗口是指桌面软件的主程序用户操作界面，它为窗口框架，其容器包含子窗口、菜单、控件等界面组件。</p><p>子窗口是指桌面软件功能子程序用户操作界面，它通常为弹出窗口、对话框、消息框</p><ul><li>非模态对话框子窗口</li><li>标签页子窗口</li><li>下拉列表子窗口</li><li>消息框子窗口</li></ul><h3 id="Web-GUI设计"><a href="#Web-GUI设计" class="headerlink" title="Web GUI设计"></a>Web GUI设计</h3><ul><li>Web表单设计</li><li>菜单与链接导航设计</li><li>面包屑和导航面板</li><li>文件上传控件设计</li><li>选项标签页设计</li></ul><h3 id="用户输入设计"><a href="#用户输入设计" class="headerlink" title="用户输入设计"></a>用户输入设计</h3><p>输入设计策略</p><ul><li>控制输入变量</li><li>减少输入延迟</li><li>减少输入错误</li><li>避免额外步骤</li><li>输入过程尽量简化</li></ul><h3 id="输入安全性设计"><a href="#输入安全性设计" class="headerlink" title="输入安全性设计"></a>输入安全性设计</h3><p>输入数据阶段产生的错误，如录入员的错读、漏读、误操作等原因引起的数据错误，可以采用数据验证检查来解决。</p><ul><li>顺序检查</li><li>存在性检查</li><li>数据类型检查</li><li>范围检查</li><li>合理性检查</li><li>有效性检查</li><li>组合性检查</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack入门笔记</title>
    <link href="/2020/06/09/Webpack%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/06/09/Webpack%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Webpack是什么"><a href="#Webpack是什么" class="headerlink" title="Webpack是什么"></a>Webpack是什么</h2><p>一个现代JavaScript应用程序的静态模块打包器</p><ol><li>默认：只对js进行处理，其他类型文件需要配置loader或者插件进行处理。</li><li>打包：将各个依赖文件进行梳理打包，形成一个JS依赖文件。</li></ol><h2 id="webpack产生的背景"><a href="#webpack产生的背景" class="headerlink" title="webpack产生的背景"></a>webpack产生的背景</h2><p>为什么需要打包？因为：</p><ol><li>各个依赖文件的关系难以梳理，耦合程度较高，代码难以维护。</li><li>把所有依赖包都打包成为一个js文件（bundle.js）文件，会有效降低文件请求次数，一定程度提升性能。</li><li>逻辑多、文件多，项目复杂度提高</li></ol><p>webpack除提供上述功能外，还充当了“翻译官”的角色，例如将ES6翻译为低版本的语法，将less、sass翻译为css等功能。</p><p>强大且灵活，loader和plugin可插拔。</p><h2 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h2><p>推荐两个很好看的讲前端模块化历程的ppt</p><ul><li><a href="https://huangxuan.me/2015/07/09/js-module-7day/">JS模块化七日谈——黄玄</a></li><li><a href="https://github.com/seajs/seajs/issues/588">前端模块化那点事——玉伯</a></li></ul><p>一个工程由各个模块组成，理想情况是高内聚低耦合，各司其职</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>定义：运行时变量、函数、对象可访问性</p><p>作用域决定了代码中变量和其他资源的可见性</p><ol><li>全局作用域</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">window</span>.a; <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">global</span>.a; <span class="hljs-comment">// 1Copy</span><br></code></pre></td></tr></table></figure><ol><li>局部作用域</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> v = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">window</span>.v; <span class="hljs-comment">// undefinedCopy</span><br></code></pre></td></tr></table></figure><p>如果引入多个script 会造成全局作用域冲突而导致不可预测的风险</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scr</span>=<span class="hljs-string">&quot;./moduleA.js&quot;</span>&gt;</span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">sciprt</span>&gt;</span></span></span><br><span class="xml"><span class="handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scr</span>=<span class="hljs-string">&quot;./moduleB.js&quot;</span>&gt;</span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">sciprt</span>&gt;</span></span></span></span></span><br><span class="xml"><span class="handlebars"><span class="xml"><span class="handlebars"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scr</span>=<span class="hljs-string">&quot;./moduleC.js&quot;</span>&gt;</span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">sciprt</span>&gt;</span></span></span></span></span></span></span><br><span class="xml"><span class="handlebars"><span class="xml"><span class="handlebars"><span class="xml"><span class="handlebars"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>Copy</span></span></span></span></span></span><br></code></pre></td></tr></table></figure><p>改进步骤一，使用变量作用域形成局部作用域：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义模块内的局部作用域，以moduleA为例</span><br><span class="hljs-keyword">var</span> Susan = &#123;<br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;susan&quot;</span>,<br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;female&quot;</span>,<br>    <span class="hljs-attr">tell</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;im susan&quot;</span>)<br>    &#125;<br>&#125;Copy<br></code></pre></td></tr></table></figure><p>但是步骤一无法保证模块属性内部安全性，比如可能不小心改掉属性值，可以通过立即执行函数进行改写，形成闭包。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义模块内的闭包作用域（模块作用域），以moduleA为例</span><br><span class="hljs-keyword">var</span> SusanModule = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> Susan = &#123;<br>    <span class="hljs-comment">// 自由变量</span><br><span class="hljs-attr">name</span>: <span class="hljs-string">&quot;susan&quot;</span>,<br>    <span class="hljs-comment">// 自由变量</span><br>    <span class="hljs-attr">sex</span>: <span class="hljs-string">&quot;female&quot;</span>,<br>    <span class="hljs-comment">// 只允许访问tell方法，不能访问和修改其他属性</span><br>    <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">tell</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;im susan&quot;</span>)<br>    &#125;<br>    &#125;<br>&#125;)()Copy<br></code></pre></td></tr></table></figure><p>如果加上参数(依赖)，就是前端模块化的基石了（来自黄玄的blog）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Module = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _$body = $(<span class="hljs-string">&quot;body&quot;</span>);     <span class="hljs-comment">// we can use jQuery now!</span><br>    <span class="hljs-keyword">var</span> foo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(_$body);    <span class="hljs-comment">// 特权方法</span><br>    &#125;<br><br>    <span class="hljs-comment">// Revelation Pattern</span><br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">foo</span>: foo<br>    &#125;<br>&#125;)(jQuery)<br><br>Module.foo();Copy<br></code></pre></td></tr></table></figure><h3 id="模块化优点"><a href="#模块化优点" class="headerlink" title="模块化优点"></a>模块化优点</h3><p>· 模块化封装，安全性高<br>· 可重用<br>· 解除耦合</p><h3 id="模块化方案进化史"><a href="#模块化方案进化史" class="headerlink" title="模块化方案进化史"></a>模块化方案进化史</h3><p>随着模块化优势体现，开发者更倾向于使用模块化协同开发项目，于是在发展过程中形成了很多规范：AMD、COMMONJS、ES6 MODULE</p><h4 id="AMD规范（Asynchronous-Module-Definition）"><a href="#AMD规范（Asynchronous-Module-Definition）" class="headerlink" title="AMD规范（Asynchronous Module Definition）"></a>AMD规范（Asynchronous Module Definition）</h4><p>异步模块定义：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">define</span><span class="hljs-params">(<span class="hljs-string">&quot;getSum&quot;</span>, [<span class="hljs-string">&quot;math&quot;</span>], funtion(math)</span></span>&#123;<br>return function (<span class="hljs-selector-tag">a</span>,b)&#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&quot;sum:&quot;</span>+ math<span class="hljs-selector-class">.sum</span>(<span class="hljs-selector-tag">a</span>, b))<br>    &#125;<br>&#125;)Copy<br></code></pre></td></tr></table></figure><h4 id="COMMONJS"><a href="#COMMONJS" class="headerlink" title="COMMONJS"></a>COMMONJS</h4><p>2009年出的规范，原本是为服务端的规范，后来nodejs采用commonjs模块化规范</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过require函数来引用</span><br><span class="hljs-keyword">const</span> math = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./math&quot;</span>);<br><span class="hljs-comment">// 通过exports将其导出</span><br><span class="hljs-built_in">exports</span>.getSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br> <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>Copy<br></code></pre></td></tr></table></figure><h4 id="ES6-MODULE"><a href="#ES6-MODULE" class="headerlink" title="ES6 MODULE"></a>ES6 MODULE</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 通过import函数来引用</span><br><span class="hljs-keyword">import</span> math <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./math&quot;</span>;<br><span class="hljs-comment">// 通过export将其导出</span><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>)</span>&#123;<br>   <span class="hljs-keyword">return</span> a + b;<br>&#125;Copy<br></code></pre></td></tr></table></figure><h2 id="Webpack-打包机制"><a href="#Webpack-打包机制" class="headerlink" title="Webpack 打包机制"></a>Webpack 打包机制</h2><p>根据import引入等关键字，将依赖文件打包成一个文件。</p><p>输出文件的大体结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">module</span></span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> installedModules = &#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__webpack_require__</span>(<span class="hljs-params">moduleId</span>)</span>&#123;<br>    <span class="hljs-comment">// SOME CODE</span><br>    &#125;<br>    <span class="hljs-comment">// 。。。</span><br>    <span class="hljs-keyword">return</span> __webpack_require__(<span class="hljs-number">0</span>); <span class="hljs-comment">// entry file</span><br>&#125;)([ <span class="hljs-comment">/* modules array */</span>])Copy<br></code></pre></td></tr></table></figure><p>上述结构中的核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">function <span class="hljs-title">__webpack_require__</span><span class="hljs-params">(moduleId)</span></span>&#123;<br>   <span class="hljs-comment">// check if module is in cache</span><br>    <span class="hljs-keyword">if</span>(installedModules[moduleId])&#123;<br>    <span class="hljs-keyword">return</span> installedModules[moduleId].<span class="hljs-keyword">exports</span>;<br>    &#125;<br><span class="hljs-comment">// create a new module (and put into cache)</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">module</span> = installedModules[moduleId] = &#123;<br>       i: moduleId,<br>        l: <span class="hljs-keyword">false</span>,<br>        <span class="hljs-keyword">exports</span>: &#123;&#125;<br>    &#125;;<br><span class="hljs-comment">// exe the module func</span><br>    modules[moduleId].call&#123;<br>      <span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span>,<br>        <span class="hljs-keyword">module</span>,<br>        <span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span>,<br>        __webpack_require__<br>    &#125;;<br><span class="hljs-comment">// flag the module as loaded</span><br>    <span class="hljs-keyword">module</span>.l = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// return the exxports of the module</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span>;<br>    &#125;Copy<br></code></pre></td></tr></table></figure><p>打包过程：</p><ol><li>从入口文件开始，分析整个应用的依赖树</li><li>将每个依赖模块包装起来，放到一个数组中等待调用</li><li>实现模块加载的方法，并把它放到模块执行的环境中，确保模块间可以互相调用</li><li>把执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数</li></ol><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="npm-install过程"><a href="#npm-install过程" class="headerlink" title="npm install过程"></a>npm install过程</h3><ul><li>寻找报版本信息文件（package.json）按照它进行安装</li><li>查找package.json中的依赖，检查项目中其他版本信息文件</li><li>发现新包，更新版本信息文件</li></ul><h2 id="常用Plugins"><a href="#常用Plugins" class="headerlink" title="常用Plugins"></a>常用Plugins</h2><h3 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h3><p>ES6 -&gt; ES5</p><p>使用方法（直接编译）：<br><code>babel -index.js --presets=@babel preset-env</code></p><p>使用方法1：<br>在package.json中加入babel配置参数</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-string">&quot;babel&quot;</span>: &#123;<br><span class="hljs-string">&quot;presets&quot;</span> : [<span class="hljs-string">&quot;@babel/preset-env&quot;</span>]<br>&#125;<br><span class="hljs-keyword">Copy</span><br></code></pre></td></tr></table></figure><p>使用方法2：<br>在package.json文件同目录下，设置.babelrc文件配置，同方法1</p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>又有一篇入门文<a href="https://www.cnblogs.com/wonyun/p/6030090.html">html-webpack-plugin详解</a></p><ul><li>为html文件中引入的外部资源如script、link动态添加每次compile后的hash，防止引用缓存的外部文件问题</li><li>可以生成创建html入口文件，比如单页面可以生成一个html文件入口，配置N个html-webpack-plugin可以生成N个页面入口</li></ul><h3 id="webpack-config-js配置项"><a href="#webpack-config-js配置项" class="headerlink" title="webpack.config.js配置项"></a>webpack.config.js配置项</h3><p><a href="https://yq.aliyun.com/articles/595117">配置文件详解</a></p><ol><li>是否缓存，提升webpack打包执行速度<br><code>cacheDictionary: true/false;</code></li><li>.js .jsx .json文件引用时候，不需要加入后缀，只需要文件名即可<br><code>resolve: extensions：[&#39;.js&#39;,&#39;.jsx&#39;,&#39;.json&#39;]</code></li></ol><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h3><ul><li>webpack-dev-server –open直接打开浏览器运行项目</li><li>提供文件变化监听，如果项目文件有更新，会自动打包，并刷新页面</li></ul><h3 id="webpack-HRM-模块热更新"><a href="#webpack-HRM-模块热更新" class="headerlink" title="webpack HRM 模块热更新"></a>webpack HRM 模块热更新</h3><p>plugin中加入：<code>webpack.HotModuleReplacementPlugin()</code></p><h3 id="打包优化"><a href="#打包优化" class="headerlink" title="打包优化"></a>打包优化</h3><p>体积优化（打包出来结果大小优化）：TerserPlugin</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">optimization:</span> &#123;<br><span class="hljs-symbol">minimizer:</span> [new TerserPlugin(&#123;<br>    <span class="hljs-comment">// 加快构建速度</span><br><span class="hljs-symbol">        cache:</span>true,<br><span class="hljs-symbol">        parrlel:</span> true,<span class="hljs-comment">// 多线程处理</span><br>        terserOptions : &#123;<br><span class="hljs-symbol">            compress:</span> &#123;<br>            <span class="hljs-comment">//删除掉一些没有用的代码</span><br><span class="hljs-symbol">                unused:</span> true,<br><span class="hljs-symbol">                drop_debugger:</span> true,<br><span class="hljs-symbol">                drop_console:</span> true,<br><span class="hljs-symbol">                dead_code:</span>true<br>            &#125;<br>        &#125;<br>    &#125;)]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MVC和MVVM</title>
    <link href="/2020/04/10/MVC%E5%92%8CMVVM/"/>
    <url>/2020/04/10/MVC%E5%92%8CMVVM/</url>
    
    <content type="html"><![CDATA[<h2 id="前端发展历史"><a href="#前端发展历史" class="headerlink" title="前端发展历史"></a>前端发展历史</h2><p>在上个世纪的1989年，欧洲核子研究中心的物理学家Tim Berners-Lee发明了超文本标记语言（HyperText Markup Language），简称HTML，并在1993年成为互联网草案。从此，互联网开始迅速商业化，诞生了一大批商业网站。</p><ul><li>静态网页<br>最早的HTML页面是完全静态的网页，它们是预先编写好的存放在Web服务器上的html文件。浏览器请求某个URL时，Web服务器把对应的html文件扔给浏览器，就可以显示html文件的内容了。</li><li>服务端动态生成html<br>如果要针对不同的用户显示不同的页面，显然不可能给成千上万的用户准备好成千上万的不同的html文件，所以，服务器就需要针对不同的用户，动态生成不同的html文件。一个最直接的想法就是利用C、C++这些编程语言，直接向浏览器输出拼接后的字符串。这种技术被称为CGI：Common Gateway Interface。</li><li>动态网页：<br>很显然，像新浪首页这样的复杂的HTML是不可能通过拼字符串得到的。于是，人们又发现，其实拼字符串的时候，大多数字符串都是HTML片段，是不变的，变化的只有少数和用户相关的数据，所以，又出现了新的创建动态HTML的方式：ASP、JSP和PHP——分别由微软、SUN和开源社区开发。</li></ul><p>在ASP中，一个asp文件就是一个HTML，但是，需要替换的变量用特殊的&lt;%=var%&gt;标记出来了，再配合循环、条件判断，创建动态HTML就比CGI要容易得多。</p><p>但是，一旦浏览器显示了一个HTML页面，要更新页面内容，唯一的方法就是重新向服务器获取一份新的HTML内容。如果浏览器想要自己修改HTML页面的内容，就需要等到1995年年底，JavaScript被引入到浏览器。</p><ul><li>JS时代<br>有了JavaScript后，浏览器就可以运行JavaScript，然后，对页面进行一些修改。JavaScript还可以通过修改HTML的DOM结构和CSS来实现一些动画效果，而这些功能没法通过服务器完成，必须在浏览器实现。</li></ul><p>用JavaScript在浏览器中操作HTML，经历了若干发展阶段：</p><ul><li>第一阶段，直接用JavaScript操作DOM节点，使用浏览器提供的原生API：</li><li>第二阶段，由于原生API不好用，还要考虑浏览器兼容性，jQuery横空出世，以简洁的API迅速俘获了前端开发者的芳心：</li><li>第三阶段，MVC模式，需要服务器端配合，JavaScript可以在前端修改服务器渲染后的数据。</li><li>现在，随着前端页面越来越复杂，用户对于交互性要求也越来越高，想要写出Gmail这样的页面，仅仅用jQuery是远远不够的。MVVM模型应运而生。</li></ul><p>MVVM最早由微软提出来，它借鉴了桌面应用程序的MVC思想，在前端页面中，把Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>几乎所有的App都只干这么一件事：将数据展示给用户看，并处理用户对界面的操作。<br>MVC的思想：一句话描述就是Controller负责将Model的数据用View显示出来，换句话说就是在Controller里面把Model的数据赋值给View，比如在controller中写<code>document.getElementById(&quot;box&quot;).innerHTML = data[”title”]</code>，只是还没有刻意建一个Model类出来而已。</p><ul><li>Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。<br>　　　　通常模型对象负责在数据库中存取数据。</li></ul><blockquote><p>比如我们人类有一双手，一双眼睛，一个脑袋，没有尾巴，这就是模型，Model定义了这个模块的数据模型。<br>在代码中体现为数据管理者，Model负责对数据进行获取及存放。<br>数据不可能凭空生成的，要么是从服务器上面获取到的数据，要么是本地数据库中的数据，<br>也有可能是用户在UI上填写的表单即将上传到服务器上面存放，所以需要有数据来源。<br>既然Model是数据管理者，则自然由它来负责获取数据。<br>Controller不需要关心Model是如何拿到数据的，只管调用就行了。<br>数据存放的地方是在Model，而使用数据的地方是在Controller，<br>所以Model应该提供接口供controller访问其存放的数据（通常通过.h里面的只读属性）</p></blockquote><ul><li>View（视图）：是应用程序中处理数据显示的部分。<br>　　　　通常视图是依据模型数据创建的。</li></ul><blockquote><p>View，视图，简单来说，就是我们在界面上看见的一切。<br>它们有一部分是我们UI定死的，也就是不会根据数据来更新显示的，<br>比如一些Logo图片啊，这里有个按钮啊，那里有个输入框啊，一些显示特定内容的label啊等等；<br>有一部分是会根据数据来显示内容的，比如tableView来显示好友列表啊，<br>这个tableView的显示内容肯定是根据数据来显示的。<br>我们使用MVC解决问题的时候，通常是解决这些根据数据来显示内容的视图。</p></blockquote><ul><li>Controller（控制器）：是应用程序中处理用户交互的部分。<br>　　　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</li></ul><p>Controller是MVC中的数据和视图的协调者，也就是在Controller里面把Model的数据赋值给View来显示<br>（或者是View接收用户输入的数据然后由Controller把这些数据传给Model来保存到本地或者上传到<br>服务器）</p><p>综合以上内容，实际上你应该可以通过面向对象的基本思想来推导出controller出现的原因：我们所有的App都是界面和数据的交互，所以需要类来进行界面的绘制，于是出现了View，需要类来管理数据于是出现了Model。我们设计的View应该能显示任意的内容比如页面中显示的文字应该是任意的而不只是某个特定Model的内容，所以我们不应该在View的实现中去写和Model相关的任何代码，如果这样做了，那么View的可扩展性就相当低了。而Model只是负责处理数据的，它根本不知道数据到时候会拿去干啥，可能拿去作为算法噼里啪啦去了，可能拿去显示给用户了，它既然无法接收用户的交互，它就不应该去管和视图相关的任何信息，所以Model中不应该写任何View相关代码。然而我们的数据和界面应该同步，也就是一定要有个地方要把Model的数据赋值给View，而Model内部和View的内部都不可能去写这样的代码，所以只能新创造一个类出来了，取名为Controller。</p><p><a href="https://s1.ax1x.com/2020/04/10/GITR4s.gif"><img src="https://s1.ax1x.com/2020/04/10/GITR4s.gif" alt="GITR4s.gif"></a></p><p>这张图把MVC分为三个独立的区域，并且中间用了一些线来隔开。很有意思的设计,C和V以及C和M之间的白线，一部分是虚线一部分是实线，这就表明了引用关系：C可以直接引用V和M，而V和M不能直接引用C，至少你不能显式的在V和M的代码中去写和C相关的任何代码，而V和M之间则是双黄线，没错，它们俩谁也不能引用谁，你既不能在M里面写V，也不能在V里面写M。哦，上面的描述有点小小的问题，你不是“不能”这样写，而是“不应该”这样写，没人能阻止你在写代码的时候在一个M里面去写V，但是一旦你这样做了，那么你就违背了MVC的规范，你就不是在使用MVC了，所以这算是MVC的一个必要条件：使用MVC –&gt; M里面没有V的代码。所以M里面没有V的代码就是使用MVC的必要条件。</p><p>按钮点击事件，是View来接收的，但是处理这个事件的应该是Controller，所以View把这个事件传递给了Controller，如何传递的呢，见图，看到View上面的action没有，这就是事件，看到Controller上面的target没有，这就是靶子，View究竟要把事件传递给谁，它被规定了传递给靶子，Controller实际上就是靶子。只是View只负责传递事件，不负责关心靶子是谁。就像你是一个负责运货的少年，你唯一知道的是你要把货（action）交给上头（开发者）告诉你的那个收货的人（target），至于那个收货的人是警察还是怪兽，你都不需要关心。这是V和C的一种交互方式，叫做target-action。所以你看，这张图简直就是神来之笔，旁边还栩栩如生的画出了V对C的另一种传值：协议-委托。委托有两种：代理和数据源。什么是代理，就是专门处理should、will、did事件的委托，什么是数据源，就是专门处理data、count等等的委托。</p><h3 id="一些新的思考"><a href="#一些新的思考" class="headerlink" title="一些新的思考"></a>一些新的思考</h3><p>M是干嘛的？上面说了，M就是数据管理者，你可以理解为它直接和数据库打交道。这里的数据库可能是本地的，也可能是服务器上的，M会从数据库获取数据，也可能把数据上传给数据库。M也将提供属性或者接口来供C访问其持有的数据。我们就拿一个简单的需求作为例子，假如我想在一个模块中显示一段文字，这段文字是从网上获取下来的。</p><p>那么使用MVC的话，在C中肯定需要一个UILabel（V）作为属性来显示这段文字，而这段文字由谁来获取呢，肯定是由M来获取了。而获取的地方在哪里呢？通常在C的生命周期里面，所以往往是在C的一个生命周期方法比如viewDidLoad里面调用M获取数据的方法来获取数据。现在问题来了，M获取数据的方法是异步的网络请求，网络请求结束后，C才应该用请求下来的数据重新赋值给V，现在的问题是，C如何知道网络请求结束了？</p><p>这里我们一定要换一种角度去思考，我们进一步考虑M和V之间的关系：它们应该是一种同步的关系，也就是，不管任何时刻，只要M的值发生改变，V的显示就应该发生改变（显示最新的M的内容）。所以我们可以关注M的值改变，而不用关心M的网络请求是否结束了。实际上C根本不知道M从哪去拿的数据，C的责任是负责把M最新的数据赋值给V。所以C应该关注的事件是：M的值是否发生了变化。</p><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>就像我们之前分析MVC是如何合理分配工作的一样，我们需要数据所以有了M，我们需要界面所以有了V，而我们需要找一个地方把M赋值给V来显示，所以有了C，然而我们忽略了一个很重要的操作：数据解析。在MVC出生的年代，手机APP的数据往往都比较简单，没有现在那么复杂，所以那时的数据解析很可能一步就解决了，所以既然有这样一个问题要处理，而面向对象的思想就是用类和对象来解决问题，显然V和M早就被定义死了，它们都不应该处理“解析数据”的问题，理所应当的，“解析数据”这个问题就交给C来完成了。而现在的手机App功能越来越复杂，数据结构也越来越复杂，所以数据解析也就没那么简单了。如果我们继续按照MVC的设计思路，将数据解析的部分放到了Controller里面，那么Controller就将变得相当臃肿。还有相当重要的一点：Controller被设计出来并不是处理数据解析的。</p><ol><li>管理自己的生命周期；</li><li>处理Controller之间的跳转；</li><li>实现Controller容器。</li></ol><p>这里面根本没有“数据解析”这一项，所以显然，数据解析也不应该由Controller来完成。那么我们的MVC中，M、V、C都不应该处理数据解析，那么由谁来呢？这个问题实际上在面向对象的时候相当好回答：既然目前没有类能够处理这个问题，那么就创建一个新的类出来解决不就好了？所以我们聪明的开发者们就专门为数据解析创建出了一个新的类：ViewModel。这就是MVVM的诞生。</p><p>搞清楚了MVVM为什么会出现，将对于你理解如何实现MVVM有极大的帮助。在我们开始着手实现MVVM之前，我先简单提一下之前遗留的一个问题：为什么MVVM这个名字里面，没有Controller的出现（为什么不叫MVCVM，C去哪了）。本来这个问题应该在实现后再来解释，但是我们这里是教学，为了让大家更好的明白我们接下来的思想，所以这里要提前解释一下这个结论：Controller的存在感被完全的降低了。我们在待会实现MVVM的时候你就能体会到了，这里请先把这个结论印在脑海当中：Controller的存在感被完全的降低了、Controller的存在感被完全的降低了、Controller的存在感被完全的降低了。</p><p>好的，我们终于要开始着手实现MVVM了。如果你已经搞懂了MVC，那么用MVVM实现一个相同的功能将会变得非常简单。你只需要记住两点：1、Controller的存在感被完全的降低了；2、VM的出现就是Controller存在感降低的原因。</p><p>在MVVM中，Controller不再像MVC那样直接持有Model了。想象Controller是一个Boss，数据是一堆文件（Model），如果现在是MVC，那么数据解析（比如整理文件）需要由Boss亲自完成，然而实际上Boss需要的仅仅是整理好的文件而不是那一堆乱七八糟的整理前的文件。所以Boss招聘了一个秘书，现在Boss就不再需要管理原始数据（整理之前的文件）了，他只需要去找秘书：你帮我把文件整理好后给我。那么这个秘书就首先去拿到文件（原始数据），然后进行整理（数据解析），接下来把整理的结果给Boss。所以秘书就是VM了，并且Controller（Boss）现在只需要直接持有VM而不需要再持有M了。如果再进一步理解C、VM、M之间的关系：因为Controller只需要数据解析的结果而不关心过程，所以就相当于VM把“如何解析Model”给封装起来了，C甚至根本就不需要知道M的存在就能把工作做好，前提它需要持有一个VM。那么我们MVVM中的持有关系就是：C持有VM，VM持有M。这里有一个比较争议的地方：C该不该持有M。我的答案是不该。为什么呢，因为C持有M没有任何意义。就算C直接拿到了M的数据，它还是要去让VM进行数据解析，而数据解析就需要M，那么直接让VM持有M而C直接持有VM就足够了。最后再分享一个我在实现MVVM中的一个技巧，也谈不上是技巧吧，算是一种必要的思想：一旦在实现Controller的过程中遇到任何跟Model（或者数据）相关的问题，就找VM要答案。。</p><p><a href="https://www.jianshu.com/p/b0aab1ffad93">文章链接</a><br><a href="https://blog.csdn.net/u013282174/article/details/51220199">另外一个文章链接</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tex数学公式索引</title>
    <link href="/2020/03/06/Tex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%B4%A2%E5%BC%95/"/>
    <url>/2020/03/06/Tex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Tex数学公式符号"><a href="#Tex数学公式符号" class="headerlink" title="Tex数学公式符号"></a>Tex数学公式符号</h2><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p>ɛ \varepsilon<br>ϕ \varphi<br>α \alpha Alpha Α<br>β \beta Beta Β<br>γ \gamma Gamma Γ<br>δ \delta Delta Δ<br>ε \epsi Epsilon Ε<br>ζ \zeta Zeta Ζ<br>η \eta Eta Η<br>θ \theta Theta Θ<br>λ \lambda Lambda Λ<br>μ \mu Mu Μ<br>ξ \xi Xi Ξ<br>π \pi Pi Π<br>ρ \rho Rho Ρ<br>σ \sigma Sigma Σ<br>τ \tau Tau Τ<br>ι \iota Iota Ι<br>κ \kappa Kappa Κ<br>ν \nu Nu Ν<br>ο \omicron Omicron Ο<br>ς \sigmaf Upsilon Υ<br>ς \varsigma<br>ϑ \vartheta<br>υ \upsilon<br>φ \phi Phi Φ<br>χ \chi Chi Χ<br>ψ \psi Psi Ψ<br>ω \omega Omega Ω<br>ϖ \varpi<br>ϱ \varrho</p><h3 id="其他特殊字符"><a href="#其他特殊字符" class="headerlink" title="其他特殊字符"></a>其他特殊字符</h3><p>任意的∀：\forall　　<br>无穷大∞：\infty　　<br>空集∅：\emptyset　　<br>存在∃：\exists　　<br>梯度∇：\nabla　　<br>垂直⊥：\bot　　<br>角∠：\angle　　<br>小于等于≤：\le　　<br>大于等于≥：\ge　　<br>恒等于≡：\equiv　　<br>因为∵：\because　　<br>所以∴：\therefore　　<br>乘号×：\times　　<br>向量点击符号⋅：\cdot　　<br>角度的显示30∘：30^circ 或 30∘：30^@</p><h3 id="极限与积分，累加与累乘"><a href="#极限与积分，累加与累乘" class="headerlink" title="极限与积分，累加与累乘"></a>极限与积分，累加与累乘</h3><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>若没有底标，则为\lim{正体}<br>例如 : \lim{(a+b)}</p><p>如果有底标，则为\lim_{底标}{正体}<br>例如 : \lim_{x-&gt;0}{f(x)}</p><h4 id="积分"><a href="#积分" class="headerlink" title="积分"></a>积分</h4><p>(1) \int{正体}</p><p>(2) \int_{底标}^{顶标}{正体}<br>例如 : \int_{i=0}^{5}{a_i}</p><h4 id="累加与累乘"><a href="#累加与累乘" class="headerlink" title="累加与累乘"></a>累加与累乘</h4><p>累加为 \sum 累乘为 \prod</p><p>(1)没有底标时，写作 \sum{}<br>例如 : \sum{a}</p><p>(2)有底标或顶标时，写作 \sum_{}^{}{}</p><p>其中_{}和^{}写和不写都可以，但是如果都出现的话，记得先底标再顶标</p><p>例如 : \sum_{n=1}^{4}{a_n}</p><h4 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h4><ol><li>上标与下标</li></ol><p>上标命令是 ^{角标}，下标命令是 _{角标}。当角标是单个字符时可以不用花括号</p><ol><li>分式</li></ol><p>输入较短的分式时，最简单的方法是使用斜线，譬如输入 (x+y)/2，可得到(x+y)/2 。</p><p>要输入带有水平分数线的公式，可用命令：\frac{分子}{分母}。</p><ol><li>根式</li></ol><p>排版根式的命令是：开平方：\sqrt{表达式}；开 n 次方：\sqrt[n]{表达式}</p><ol><li>矩阵</li></ol><p>对于少于 10 列的矩阵，可使用 matrix，pmatrix，bmatrix，Bmatrix，vmatrix 和 Vmatrix</p><p>$$\begin{matrix}1 &amp; 2\3 &amp;4\end{matrix}$$<br>$$\begin{pmatrix}1 &amp; 2\3 &amp;4\end{pmatrix}$$<br>$$\begin{bmatrix}1 &amp; 2\3 &amp;4\end{bmatrix}$$<br>$$\begin{Bmatrix}1 &amp; 2\3 &amp;4\end{Bmatrix}$$<br>$$\begin{vmatrix}1 &amp; 2\3 &amp;4\end{vmatrix}$$<br>$$\begin{Vmatrix}1 &amp; 2\3 &amp;4\end{Vmatrix}$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker小实践</title>
    <link href="/2020/02/29/docker%E5%B0%8F%E5%AE%9E%E8%B7%B5/"/>
    <url>/2020/02/29/docker%E5%B0%8F%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="为啥想整docker了"><a href="#为啥想整docker了" class="headerlink" title="为啥想整docker了"></a>为啥想整docker了</h3><p>记得大一上学期，参加工作室招新的时候，一共没做几道题，其中一个就是linux</p><p>折腾好半天装好虚拟机，搞了远程桌面啥的，这题目的分就算到手了</p><p>但是题目的进阶知识推荐里，有docker的简单介绍，当时忙着做其他题目，就将这个搁下了</p><p>最近重学前端，按理来说跟docker没什么相关的东西，但是py和java的一点小基础让自己萌生了“全干工程师”的想法（误）</p><p>正好linux也倒腾了很久，一年里换了ubuntu、centos、manjaro、kali、wsl，也算对操作系统有了比较粗浅的认知，于是对docker技术也充满好奇</p><p>好奇才是推动自己学习的动力呀！</p><p>打开天池竞赛，突然发现了docker的入门指南和小比赛</p><p>8说了，直接开冲！</p><h3 id="windows-with-docker"><a href="#windows-with-docker" class="headerlink" title="windows with docker"></a>windows with docker</h3><p>因为自己的机器还是dell xps-9360，装的是原装win，所以会有些小问题（我会有mac的！）</p><h4 id="第一步，看一下自己的win版本"><a href="#第一步，看一下自己的win版本" class="headerlink" title="第一步，看一下自己的win版本"></a>第一步，看一下自己的win版本</h4><p>打开控制面板-&gt;系统与安全-&gt;系统</p><p>发现自己的版本是windows10 家庭中文版</p><p>但是docker是要求win10 专业版的，所以要升级</p><p>行8，升级部分略过，至于怎么做嘛，建议tb</p><h4 id="第二步，开启虚拟化"><a href="#第二步，开启虚拟化" class="headerlink" title="第二步，开启虚拟化"></a>第二步，开启虚拟化</h4><p>打开任务管理器</p><p><a href="https://s2.ax1x.com/2020/02/29/3ywXz6.png"><img src="https://s2.ax1x.com/2020/02/29/3ywXz6.png" alt="3ywXz6.png"></a></p><h4 id="第三步，启动hyper-V"><a href="#第三步，启动hyper-V" class="headerlink" title="第三步，启动hyper-V"></a>第三步，启动hyper-V</h4><p>控制面板-&gt;程序</p><p><a href="https://s2.ax1x.com/2020/02/29/3yBQBD.th.png"><img src="https://s2.ax1x.com/2020/02/29/3yBQBD.th.png" alt="3yBQBD.th.png"></a></p><p>点击这几个选项，然后重启</p><h4 id="第四步，安装docker"><a href="#第四步，安装docker" class="headerlink" title="第四步，安装docker"></a>第四步，安装docker</h4><p><a href="https://www.docker.com/get-started">官网链接</a></p><p>安装之后，还要注册账号哦，windows里有desktop，操作起来还算简单</p><p>小鲸鱼！出现吧！</p><p><a href="https://s2.ax1x.com/2020/02/29/3yDixP.th.png"><img src="https://s2.ax1x.com/2020/02/29/3yDixP.th.png" alt="3yDixP.th.png"></a></p><h4 id="第五步，编写在此次任务中需要的任务文件"><a href="#第五步，编写在此次任务中需要的任务文件" class="headerlink" title="第五步，编写在此次任务中需要的任务文件"></a>第五步，编写在此次任务中需要的任务文件</h4><p>新建一个文件夹，出于习惯叫tianchi_submit_demo</p><p><a href="https://s2.ax1x.com/2020/02/29/3yD3rT.th.png"><img src="https://s2.ax1x.com/2020/02/29/3yD3rT.th.png" alt="3yD3rT.th.png"></a></p><p>里面要有四个文件</p><ol><li>Dockerfile</li></ol><p>里面的内容是</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># Base Images</span><br><span class="hljs-meta">## 从天池基础镜像构建</span><br>FROM registry.cn-shanghai.aliyuncs.com/tcc-<span class="hljs-keyword">public</span>/python:<span class="hljs-number">3</span><br><br><span class="hljs-meta">## 把当前文件夹里的文件构建到镜像的根目录下</span><br>ADD . /<br><br><span class="hljs-meta">## 指定默认工作目录为根目录（需要把run.sh和生成的结果文件都放在该文件夹下，提交后才能运行）</span><br>WORKDIR /<br><br><span class="hljs-meta">## 镜像启动后统一执行 sh run.sh</span><br>CMD [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;run.sh&quot;</span>]Copy<br></code></pre></td></tr></table></figure><ol><li>hello_world.py</li></ol><p>里面的内容是本次比赛的程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> csv<br><br>file_name = <span class="hljs-string">&#x27;/tcdata/&#x27;</span><br><br><span class="hljs-comment"># 第一题，直接写入 Hello world</span><br><br>result = &#123;<br><span class="hljs-string">&quot;Q1&quot;</span>: <span class="hljs-string">&quot;Hello world&quot;</span>,<br><span class="hljs-string">&quot;Q2&quot;</span>: <span class="hljs-number">0</span>,<br><span class="hljs-string">&quot;Q3&quot;</span>: []<br>&#125;<br><br><span class="hljs-comment"># 第二题，求和</span><br>list_data = []<br>sum_int = <span class="hljs-number">0</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name+<span class="hljs-string">&quot;num_list.csv&quot;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    reader = csv.reader(f)<br>    <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>        list_data.append(<span class="hljs-built_in">int</span>(row[<span class="hljs-number">0</span>]))<br>        sum_int += <span class="hljs-built_in">int</span>(row[<span class="hljs-number">0</span>])<br>result[<span class="hljs-string">&#x27;Q2&#x27;</span>] = sum_int<br><br><span class="hljs-comment"># 第三题</span><br>result[<span class="hljs-string">&#x27;Q3&#x27;</span>] = <span class="hljs-built_in">sorted</span>(list_data, reverse=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]<br><br><span class="hljs-comment"># 保存到 result.json</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;result.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(result, f)Copy<br></code></pre></td></tr></table></figure><ol><li>result.json</li></ol><p>一个空文件</p><ol><li>run.sh</li></ol><p>只有一行：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> hello_world.<span class="hljs-keyword">py</span><br></code></pre></td></tr></table></figure><h4 id="第六步，开启阿里云容器镜像服务"><a href="#第六步，开启阿里云容器镜像服务" class="headerlink" title="第六步，开启阿里云容器镜像服务"></a>第六步，开启阿里云容器镜像服务</h4><p>在<a href="https://tianchi.aliyun.com/competition/entrance/231759/tab/174?spm=5176.12282029.0.0.2e85381e2c2PkB">教程</a>里写得很明白了</p><p><a href="https://s2.ax1x.com/2020/02/29/3yreOK.png"><img src="https://s2.ax1x.com/2020/02/29/3yreOK.png" alt="3yreOK.png"></a></p><p>需要注意一定要设置密码！在“访问凭证”里，点“管理”即可</p><h4 id="第七步，构建镜像与推送"><a href="#第七步，构建镜像与推送" class="headerlink" title="第七步，构建镜像与推送"></a>第七步，构建镜像与推送</h4><p>打开powershell，首先要登陆，这个过程在镜像管理的页面里也有，Linux版本要加sudo，但是powershell直接docker开头就好</p><p>复制命令</p><p><a href="https://s2.ax1x.com/2020/02/29/3ysENQ.png"><img src="https://s2.ax1x.com/2020/02/29/3ysENQ.png" alt="3ysENQ.png"></a></p><p>输入密码</p><p>然后cd到刚刚创建了四个文件的那个目录下</p><p><a href="https://s2.ax1x.com/2020/02/29/3yse9s.png"><img src="https://s2.ax1x.com/2020/02/29/3yse9s.png" alt="3yse9s.png"></a></p><p>然后建立</p><p><a href="https://s2.ax1x.com/2020/02/29/3ysAAg.png"><img src="https://s2.ax1x.com/2020/02/29/3ysAAg.png" alt="3ysAAg.png"></a></p><p>注意：<code>registry.~~~</code>是创建仓库的公网地址，用自己仓库地址替换。地址后面的<code>：1.0</code>为自己指定的版本号，用于区分每次build的镜像。最后的.是构建镜像的路径，不可以省掉，而且后面有一个.不能省下！</p><p>然后推送！</p><p><a href="https://s2.ax1x.com/2020/02/29/3ysVhj.png"><img src="https://s2.ax1x.com/2020/02/29/3ysVhj.png" alt="3ysVhj.png"></a></p><p>这里不需要写后面的.了</p><h4 id="最后一步，验证结果"><a href="#最后一步，验证结果" class="headerlink" title="最后一步，验证结果"></a>最后一步，验证结果</h4><p>像是刚才的<a href="https://tianchi.aliyun.com/competition/entrance/231759/tab/174?spm=5176.12282029.0.0.2e85381e2c2PkB">手把手教程</a>一样</p><p><a href="https://s2.ax1x.com/2020/02/29/3yyuPH.png"><img src="https://s2.ax1x.com/2020/02/29/3yyuPH.png" alt="3yyuPH.png"></a></p><p>这样提交上去就ok了！</p><p>可以查看一下成绩：</p><p><a href="https://s2.ax1x.com/2020/02/29/3yywzn.png"><img src="https://s2.ax1x.com/2020/02/29/3yywzn.png" alt="3yywzn.png"></a></p><p>（为了博客截图所以提交了两次XD）</p><p>好了，这就是docker初战</p><p>在这里要吐槽一下tx云，学生优惠的10元/月还真是一点不差</p><p>十元一月，只有一个月有优惠，而且给的配置是最低的centos6.9 32位，装不了linux版本的docker</p><p>要赚钱还是你会赚啊！企鹅！（咬牙）</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>压缩文件里的_MACOSX文件夹是怎么回事</title>
    <link href="/2020/02/28/%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84-MACOSX%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/"/>
    <url>/2020/02/28/%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84-MACOSX%E6%96%87%E4%BB%B6%E5%A4%B9%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="奇怪的-MACOSX文件夹"><a href="#奇怪的-MACOSX文件夹" class="headerlink" title="奇怪的_MACOSX文件夹"></a>奇怪的_MACOSX文件夹</h3><p>前几天跟同学闲扯，唠着唠着他突然问我：</p><p>“诶诶？我打开压缩包之后总是有个macos文件夹是什么东西啊”</p><p>“里面文件还只有1kb，我电脑是不是中毒了啊？”</p><p>做计算机系学生一年半的我，突然羞愧了起来。</p><p>平时安装包下载的也不少，但是每次都将其忽略了，只知道压缩文件的原理，和macosx代表苹果的操作系统，但是这两件事之间到底是什么联系，还真是不知道。</p><p>我因自己的“不求甚解”感到有些羞耻</p><p>所以到底是什么呢？我带着好奇心打开百度搜索栏</p><h3 id="MACOSX的奇妙压缩"><a href="#MACOSX的奇妙压缩" class="headerlink" title="MACOSX的奇妙压缩"></a>MACOSX的奇妙压缩</h3><p>MacOS（或者叫Mac）作为苹果公司开发的操作系统，有许多来自领先的网络框架组织的核心人物会选择Mac作为开发平台，以及其他很多开发攻城狮们也会选择在Mac上开发程序或写代码。</p><p>而且，在Mac上压缩文件是一件很轻松的事情，只要在目录上点击右键选择“压缩为”就可以了。</p><p>但是会有其他的事情同时发生，因为Mac不仅仅是把想要的东西添加进压缩包，而且还写入了一些 ”MetaData” ，这样做的目的是为了方便其它的Mac用户使用，就像Windows会在图片目录下加入的 “Thumbs.db” 以方便显示预览图一样。</p><p>而这些 ”MetaData” 产生的文件就是 “__MACOSX”，本身这些文件在Mac上是隐藏属性的，也的确方便了用户的操作。</p><p>但是在windows里，“_MACOSX”文件夹是可见的，所以会有打开压缩包后发现有一个莫名其妙的文件夹的情况出现</p><p>好的，以上就是今天的小知识</p>]]></content>
    
    
    
    <tags>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL和zsh美化</title>
    <link href="/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/"/>
    <url>/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="为啥要装WSL"><a href="#为啥要装WSL" class="headerlink" title="为啥要装WSL"></a>为啥要装WSL</h3><p>Windows Subsystem for Linux（简称WSL）是一个在Windows 10上能够运行原生Linux二进制可执行文件（ELF格式）的兼容层</p><p>一方面是想继续熟悉linux，另一方面是windows实在是糟心，在没换mac之前只能拿wsl来过过瘾</p><p>yysy还是linux shell用得舒服</p><h3 id="1-安装WSL"><a href="#1-安装WSL" class="headerlink" title="1.安装WSL"></a>1.安装WSL</h3><p>控制面板-&gt;程序和功能-&gt;启用或关闭Windows功能-&gt;勾选 适用于Linux的Windows子系统</p><p><a href="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/install.png"><img src="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/install.png" alt="img"></a></p><p>在windows store 安装wsl，最好安装18.04或者16.04版，评价低的那个不推荐</p><p><a href="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/store.png"><img src="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/store.png" alt="img"></a></p><p>然后就可以直接在搜索栏里打ubuntu，直接开始运行了</p><p><a href="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/yunxing.png"><img src="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/yunxing.png" alt="img"></a></p><p>需要注意的是，子系统安装完的位置会在这个位置：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\(</span>用户名)<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\P</span>ackages<span class="hljs-symbol">\C</span>anonicalGroupLimited.UbuntuonWindows_79rhkp1fndgsc<span class="hljs-symbol">\L</span>ocalState<span class="hljs-symbol">\r</span>ootfs<br></code></pre></td></tr></table></figure><h3 id="2-安装zsh"><a href="#2-安装zsh" class="headerlink" title="2.安装zsh"></a>2.安装zsh</h3><p>终端输入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install zsh<br></code></pre></td></tr></table></figure><p>切换到 zsh，直接在终端输入 zsh 即可切换到 zsh。</p><p>安装 oh-my-zsh:</p><p>终端输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sh -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span><br></code></pre></td></tr></table></figure><p>没啥问题就按y就完事了</p><h3 id="3-美化环节"><a href="#3-美化环节" class="headerlink" title="3.美化环节"></a>3.美化环节</h3><h4 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h4><p>agnoster 主题在终端显示的效果比较暗，因此对主题文件修改一下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp ~<span class="hljs-regexp">/.oh-my-zsh/</span>themes<span class="hljs-regexp">/agnoster.zsh-theme ~/</span>.oh-my-zsh<span class="hljs-regexp">/custom/</span>themes/agnoster_wsl.zsh-theme<br></code></pre></td></tr></table></figure><p>在这一步的时候出现了一点问题，所以直接copy了文件paste到相应的目录里（注意要改名字的！）</p><p>在终端键入 vim ~/.oh-my-zsh/custom/theme/agnoster_wsl.zsh-theme 对主题文件进行修改。在主题文件中找到：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">prompt_dir</span><span class="hljs-params">()</span></span> &#123;<br>  prompt_segment blue <span class="hljs-variable">$CURRENT_FG</span> <span class="hljs-string">&#x27;%~&#x27;</span><br>&#125;Copy<br></code></pre></td></tr></table></figure><p>将 blue 修改为 075：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">prompt_dir</span><span class="hljs-params">()</span></span> &#123;<br>  prompt_segment <span class="hljs-number">075</span> <span class="hljs-variable">$CURRENT_FG</span> <span class="hljs-string">&#x27;%~&#x27;</span><br>&#125;Copy<br></code></pre></td></tr></table></figure><p>最后，在配置文件 ~/.zshrc 中修改主题为 agnoster_wsl：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">vim ~<span class="hljs-string">/.zshrc</span><br></code></pre></td></tr></table></figure><p>改成</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ZSH_THEME</span>=<span class="hljs-string">&quot;agnoster_wsl&quot;</span><br></code></pre></td></tr></table></figure><h4 id="隐藏终端前缀的用户名和主机名"><a href="#隐藏终端前缀的用户名和主机名" class="headerlink" title="隐藏终端前缀的用户名和主机名"></a>隐藏终端前缀的用户名和主机名</h4><p>在 ~/.zshrc 配置文件中添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DEFAULT_USER</span>=<span class="hljs-string">&quot;用户名&quot;</span> <span class="hljs-comment"># 引号的内容为你的用户名</span><br></code></pre></td></tr></table></figure><h4 id="字体修改"><a href="#字体修改" class="headerlink" title="字体修改"></a>字体修改</h4><p>只需要在终端顶部右键选择属性就可以</p><p><a href="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/tizi.png"><img src="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/tizi.png" alt="img"></a></p><p>在这一步还有了新的问题，我的显示里是没有终端箭头的，目测是字体有点问题</p><p><a href="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/terminal.png"><img src="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/terminal.png" alt="img"></a></p><p>需要更换为<a href="https://github.com/powerline/fonts">Powerline字体</a></p><p>我自己这边更换了Fira Code字体，显示就正常了</p><p>参考了<a href="https://www.jianshu.com/p/0effae21b862">这个博客</a>的内容</p><p><a href="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/change.png"><img src="https://yijing233.com/2020/02/21/WSL%E5%92%8Czsh%E7%BE%8E%E5%8C%96/change.png" alt="img"></a></p><p>都ok了，肥肠好看</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.jianshu.com/p/37f392355af1">WSL 使用 oh-my-zsh 让终端更美</a></p><p><a href="https://www.cnblogs.com/JettTang/p/8186315.html">WSL(Windows Subsystem for Linux)的安装与使用</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>幸运与自我的觉醒-大二上学期总结</title>
    <link href="/2020/01/21/%E5%B9%B8%E8%BF%90%E4%B8%8E%E8%87%AA%E6%88%91%E7%9A%84%E8%A7%89%E9%86%92-%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <url>/2020/01/21/%E5%B9%B8%E8%BF%90%E4%B8%8E%E8%87%AA%E6%88%91%E7%9A%84%E8%A7%89%E9%86%92-%E5%A4%A7%E4%BA%8C%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>每次都要花大力气思考开头，而且每次都丧得一笔</p><p>不知道为什么，在每个学期的这个环节，总是对自己很失望。无论这个学期到底如何。这个环节，更多的作为自我批判而存在。</p><p>在意识到了学校与专业的操蛋之处后，这个学期里选择了妥协，逐渐变成了别人口中的“不好好上课学习”的垃圾大学生。</p><p>为什么每个学期都间歇性踌躇满志，持续性混吃等死呢？</p><p>一直拿学姐做榜样也不是只学馨悦学姐一边写文章一边做工作啊····（自我吐槽</p><p>补考也没过，重修也没过，比赛基本靠陆总carry自己啥也没学到，学习学习拉胯，生活生活糜烂</p><p>总是在生活中的一点点细节或者无关紧要的事情上心，吃什么喝什么用什么，开始“投资自己”以消解学不进去带来的愧疚感。</p><p>还是太爱玩，太不喜欢学习了，期末一周里疯狂爆肝，在工作室熬了四个晚上，考试的时候脑子里基本上什么都不装了</p><p>还没出成绩，不过就那样吧，本来还打算出国或是怎么样，现在来看还不如直接学技术就业。</p><p>时间线安排的还是很明显的，学习技术，报名考试，一起做项目，还一直在接稿子。</p><p>细细复盘起来，这学期做的事情还是很多的，也是真的很累。</p><p>综设老大，软工老大，工作室细枝末节的琐碎事，疯狂写文档、接稿子写文章···</p><p>做了好多事情，但就是和学习无关（笑</p><p>技术力也没有什么改善和提高，该会的还是会，不会的照样做不到。</p><p>探索太多，成长太少。这其实应该是大一的时候该干的事情。但我的大一在干什么呢？迷茫得可怕。</p><p>该抓紧时间了，我这么想，也每次都这么想。</p><p>很羡慕学姐能在大二上的时候找到自己喜欢的方向，做到自己感兴趣的地方。也羡慕ywjj终于下了决心转行</p><p>我最缺乏的，就是“决心”</p><p>每次作出决定都软软弱弱的，也从来不敢做出可能决定自己五年、十年甚至半辈子的未来方向。还是怂的不行。</p><p>所谓的决定都是被迫做出的。</p><p>因为初试成绩差而被迫放弃保研，因为重修成绩不上心而无法出国</p><p>就只剩就业这一条道路了。</p><p>并不是这个选择不好，而是说这种丧失选择权的感觉，充满了无力感。</p><p>在大势所趋里，只有随波逐流的份儿。心情也逐渐空洞了。</p><p>我没办法做到样样优秀。早早的明白了这个道理的我总是不相信，还有着不切实际的想法。</p><p>这个学期里，“幸运”占了最大的比重。</p><p>遇到了可爱的工作室同学，遇到了强有力的技术力max学长，综设选了一位友善而温柔的老师，发现了自己写产业文的一点点才能，期末时找到了最可爱的人。</p><p>也不无收获</p><p>这就是生活🐴？我知道了呢。</p><p>我希望我的下学期，主题是：蜕变</p><p>加油吧，会变好的<br>🌼</p>]]></content>
    
    
    
    <tags>
      
      <tag>学期总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次重装系统</title>
    <link href="/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    <url>/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="重装linux（Ubuntu）"><a href="#重装linux（Ubuntu）" class="headerlink" title="重装linux（Ubuntu）"></a>重装linux（Ubuntu）</h1><p><a href="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E5%A4%B4%E5%9B%BE.jpg"><img src="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E5%A4%B4%E5%9B%BE.jpg" alt="img"></a></p><p>工作室里的一台Mac闲置，经过学姐的同意决定将上面装的Ubuntu刷掉！</p><h2 id="找教程"><a href="#找教程" class="headerlink" title="找教程"></a>找教程</h2><p>先找了一篇中文的<a href="https://www.linuxprobe.com/reinstall-ubuntu.html">如何重装Ubuntu系统</a></p><p>把大象装进冰箱需要分三步走（误）：</p><ol><li>下载一个版本的Ubuntu</li><li>创建一个 live USB</li><li>重新安装 Ubuntu</li></ol><p>先在<a href="https://ubuntu.com/download">Ubuntu官网</a>上找了Ubuntu的下载方式（Ubuntu还好啦，不用找国内镜像就可很快下完）</p><p>然后通过站内的链接找到了一个英文教程<a href="https://itsfoss.com/create-live-usb-of-ubuntu-in-windows/">如何在Windows中创建Ubuntu usb live</a></p><p>在英文教程的指引下跑到<a href="https://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/#more-3827">另一个网站下载UUI</a>（一种usb live工具）</p><p>PS：推荐用Chrome打开，直接翻译爽歪歪</p><p>将USB驱动器插入计算机，然后运行通用USB安装程序。您现在需要执行以下操作：</p><p>在步骤1下选择Ubuntu</p><p>在步骤2部分中浏览到下载的Ubuntu ISO的位置</p><p>在步骤3中，选择USB驱动器，然后检查选项以对其进行格式化。<a href="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/Create_Live_USB_1.PNG"><img src="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/Create_Live_USB_1.PNG" alt="img"></a></p><p>在Windows 8中创建Ubuntu 14.04的实时USB</p><p>显示明显的警告，单击“是”。</p><p><a href="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/Create_Live_USB_2.PNG"><img src="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/Create_Live_USB_2.PNG" alt="img"></a></p><p>等待一段时间以完成该过程。<br><a href="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/Create_Live_USB_3.PNG"><img src="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/Create_Live_USB_3.PNG" alt="img"></a><br>可以根据需要将其推送到后台。</p><p>创建Ubuntu的实时USB</p><p>也就是说，您的Ubuntu USB应该在几分钟内创建。</p><p>创建实时USB之后，就可以在实时模式下继续测试Ubuntu。</p><p>重启计算机。在启动时，按F2或F10或F12（取决于系统）以访问启动菜单。在那里，选择从USB或可移动媒体启动。(无需安装即可使用Ubuntu)</p><p>对于Mac来说，F2、F10等键都没用，需要长按Option键（win键盘的alt）</p><p>然后会出现：<br><a href="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/mac%E7%89%B9%E8%89%B2.jpg"><img src="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/mac%E7%89%B9%E8%89%B2.jpg" alt="img"></a><br>（网上找的图见谅）</p><p>选择右边的这个，就正式进入Ubuntu系统的安装了</p><p><a href="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E9%80%89%E9%A1%B9.jpg"><img src="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E9%80%89%E9%A1%B9.jpg" alt="img"></a> <a href="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E9%80%89%E9%A1%B92.jpg"><img src="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/%E9%80%89%E9%A1%B92.jpg" alt="img"></a></p><p>最后就是用户名之类的注册环节<br>上以上运行后装得git啥的截图8</p><p><a href="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/git.png"><img src="https://yijing233.com/2019/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/git.png" alt="img"></a></p><p>完美(￣▽￣)”</p>]]></content>
    
    
    
    <tags>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次黑客松</title>
    <link href="/2019/12/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%BB%91%E5%AE%A2%E6%9D%BE/"/>
    <url>/2019/12/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%BB%91%E5%AE%A2%E6%9D%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p><a href="https://www.huodongxing.com/event/3517188602600">链接放上</a></p><p>就是，工作室缺钱了嘛，这个比赛奖金还挺多的嘛，而且上学期就有一个微软的黑客松极限编程项目，有点心动嘛</p><p>如果能得到锻炼就好了（没想到是锻炼了肝功能，妈蛋）</p><p>三十二个小时也不是说不能做，只要注意休息就好（哪有那么简单啊魂淡！）</p><p>黑客松提前发了主题，如何让成都变得更美好，其实我觉得成都已经很好了，如果能有一个100%晴天女孩在就可以</p><p>但是非要交一个软件（web，小程序啥的都可）</p><p>行吧，也没怎么样，之后就是愉快（其实不是）地做课内的事情</p><p>u1s1你院学子要做的事情也太多了（实验报告、MOOC测验和测评、课内学习、综设blablabla）</p><p>这事情就抛在一边了，直到前一天才开会决定我们要做什么（deadline是第一生产力）</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>当天早上七点从床上爬起来，看到了成都一环里还没亮天的亚子（不对啊，上学期一两点钟睡六点起也困成这b样啊）</p><p>洗漱后背好前一天准备好的包：电脑、平板、充电线充电宝、一件羽绒服、一包纸</p><p>为什么没拿口香糖呢？我也不知道</p><p>十分佩服陆总，前一天也肝到很晚，但他就可以悠然自得的集合，甚至还能去拿一个快递（快递来的U型枕是真的舒服）</p><p>和小马哥、ycgg集合，坐车到了侠客岛</p><p>十点开始hackthon，陆总一马当先写了前后端框架，而我在疯狂爬数据</p><p>不知道为啥，人就特别紧张，紧张到手也抖心跳也快的情况，在这种情况下代码质量也很吉尔难看</p><p>十二点钟去恰饭，饭饭的质量还是不错的，橘子不限量，这两天我不知道吃了多少</p><p>坐电梯回来，电梯门一打开，开幕雷击</p><p>人类迷惑行为：为什么晓艺学长和npy要冲着透明的玻璃门面壁思过，两个人还站的ber直溜，ber认真？</p><p>下午的开发就很蛋疼，在爬一些东西的时候实在技术所限，只能选择用八爪鱼工具来爬，效果还不错</p><p>其中我们还重新讨论了一下项目的最终需求，不能任由产品一个又一个的加啊！陆总撑不住的！</p><p>晚上进行数据清洗和数据的导入</p><p>手动洗数据是最吉尔难受的，拿notepad++用正则、ctrl+h的方法改了好多好多数据，还要手动把项目所在的经纬度点出来复制粘贴</p><p>真的没有技术含量，而为啥没技术含量，不就是因为自己太菜了吗</p><p>洗完数据继续进行导入数据库，sqlite两小时入门，增删改查语句极为熟练，其中还有好多需要debug的地方（最大的问题就是数据类型的问题，这个问题也一直延续到第二天）</p><p>数据库做完就已经两点钟了，在这期间我们甚至出了一趟门（学姐是怎么把发霉的瓶子水喝干净一滴不剩的？）</p><p>学姐恰药，陆总买了点吃的。</p><p>我们问“陆总，有什么能帮到你的吗？”</p><p>陆总：“你们能帮我肝明日方舟的活动吗？”</p><p>好了，你组果然二刺螈</p><p>永远守护二次元！奥里给！</p><p>隔壁微软真的能肝，比我们还能肝，肝到早上7点多，他们才睡了半个多小时</p><p>数据洗完了，我们开始进行愉快的放松摸鱼时间，陆总戴上耳机开始了游戏</p><p>我和ywjj开始快乐4399</p><p>森林冰火人就是世界瑰宝！</p><p>在陆总的debug需求下ywjj回去继续画图了</p><p>ywjj也是真的可，一个人把焦糖两队的icon都画的贼棒！UI大神就是你！</p><p>寒子哥也很猛，早早的把算法写完，开始进行调试工作。</p><p>时间很快，ywjj和陆总睡了各自的气垫床，我和寒子哥趴在桌子上睡。</p><p>有的组回去睡觉休息了，有的组还在肝爆（好像有个西南交的组一直在肝）</p><p>本来趴下睡觉，带的羽绒服当枕头了。一个组的哥们睡觉打呼噜，跟钻头一样，我寻思我都离欣苑那么远了怎么还能听到建筑工地的声音？</p><p>睡了两个小时起来继续</p><p>吃早饭的时候认真探讨了关于huawei251的话题，提出了一个新的idea（误）：区块链手机录音笔</p><p>回去继续调数据库，发现密码经过哈希之后就8能读取，会报错</p><p>改了又改（我真的好菜啊）</p><p>数据库做好了就帮寒寒改代码，顺便摸鱼去ycgg的组看一下进度</p><p>四点到六点快乐比赛（我还是好菜啊，那个题根本就跟算法不沾边的为什么我还是写的那么慢）</p><p>最后的展示环节也翻了车，干巴巴的讲，连写的readme都没展示</p><p>脑子太浑了，已经完全没有了感觉，这种简单的事情都没做到</p><p>听天由命了555555</p><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>晚上回去的时候用ywjj的手环测了一下心率，104上下，真的怕了</p><p>自侃最大的收获是一个参赛证</p><p><a href="https://yijing233.com/2019/12/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%BB%91%E5%AE%A2%E6%9D%BE/hackthon.jpg"><img src="https://yijing233.com/2019/12/02/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%BB%91%E5%AE%A2%E6%9D%BE/hackthon.jpg" alt="img"></a></p><p>最大的收获就是信心，心无旁骛地做一件东西是真的能做到（比如两小时俗称后端数据库）</p><p>这确实是能做到的极限了（我太菜了，上限只能到这了5555555）</p><p>已经没有什么好怕的了（flag），感觉自己什么都能做到了（只要能肝），为OPPO杯树立了信心</p><p>我会做的更好的，加油哦小伙子</p>]]></content>
    
    
    
    <tags>
      
      <tag>记录生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>当二进制遇到汉诺塔</title>
    <link href="/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/"/>
    <url>/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/</url>
    
    <content type="html"><![CDATA[<h1 id="当二进制遇见汉诺塔"><a href="#当二进制遇见汉诺塔" class="headerlink" title="当二进制遇见汉诺塔"></a>当二进制遇见汉诺塔</h1><p>xio计算机的怎么能不知道递归嘞？</p><p>学习递归思想怎么能不拿汉诺塔问题练手呢？（紧紧抱住弱弱的自己）</p><p>呐，先来讲讲汉诺塔是啥子</p><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="#汉诺塔问题"></a>#汉诺塔问题</h2><p>解决方法来自<a href="https://www.zhihu.com/question/24385418/answer/282940567">如何理解汉诺塔的递归？-酱紫君的回答</a></p><p>汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。问应该如何操作？</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/hanoi.PNG"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/hanoi.PNG" alt="img"></a></p><p>首先我们简化一下问题，把圆盘的数量设为3，这个问题就变得很简单了。</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/3%E4%B8%AA.gif"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/3%E4%B8%AA.gif" alt="img"></a></p><ul><li>首先将最小的3号放在终点柱子上</li><li>再把中间小的2号放在缓冲区（第二根柱子）上</li><li>把3号放到2号上</li><li>把1放到终点柱子上</li><li>把3放到起点柱子上</li><li>把2放到1上</li><li>把3放到2上</li></ul><p>于是，通过七步就将这个问题解决了</p><p>那我们将问题复杂化一下，盘子变成四个，这又该怎么解决呢？</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/4%E4%B8%AA.jpg"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/4%E4%B8%AA.jpg" alt="img"></a></p><p>假如我们不考虑这个多的第四个盘子，当它不存在，只看它头上的三个盘子，刚才提到的方法依旧可以完美的使用</p><p>（可以大脑过一遍）</p><p>于是我们得到了这样的结果：</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/%E5%A4%9A%E5%87%BA%E4%B8%80%E4%B8%AA.jpg"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/%E5%A4%9A%E5%87%BA%E4%B8%80%E4%B8%AA.jpg" alt="img"></a></p><p>那么我们可以非常鸡贼地把第二根柱子和第三根柱子替换，结果为：</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/%E9%B8%A1%E8%B4%BC.jpg"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/%E9%B8%A1%E8%B4%BC.jpg" alt="img"></a></p><p>然后把冒出来的盘子放到第三根柱子上，你会发现，这不就和3个盘子是一样的了吗？</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/4%E4%B8%AA.gif"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/4%E4%B8%AA.gif" alt="img"></a></p><p>4个盘子的挪动次数一共是</p><p>“3个盘子汉诺塔” + “4盘子移动到第三根柱子” + “3个盘子汉诺塔”</p><p>文字有点麻烦，快拿朕的数学公式来！</p><p>当问题是3个盘子的时候：</p><p><strong>$A_3= 7$</strong></p><p>当问题是4个盘子的时候：</p><p><strong>$A_4 = A_3 + 1 + A_3$</strong></p><p>换一种形式就是：</p><p><strong>$A_4 = 2A_3 + 1$</strong></p><p>如果对于任意个盘子，我们都使用这种方法</p><p>5个盘子，就先解决挪4个的问题</p><p>6个盘子，就先解决挪5个的问题</p><p>·······</p><p>n个盘子，就先解决挪n-1个的问题</p><p>所以移动次数的递推公式为</p><p><strong>$A_n = 2A_{n-1} + 1$</strong></p><p>数为n的汉诺塔问题通项公式为</p><p><strong>$A_n = 2^n -1$</strong></p><p>实际上我们把这个n个盘子的问题拆解了，分成了一步一步思路重复的工作</p><p>不断重复的流程是：</p><ul><li>把n-1号盘子移到缓冲区柱子上</li><li>把n号盘子从起点柱子移到终点根柱子上</li><li>把n-1号盘子从缓冲柱子移到n号盘子上</li></ul><p>py代码：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def move(n,<span class="hljs-keyword">from</span>,buffer,<span class="hljs-keyword">to</span>): # n为盘子总数，<span class="hljs-keyword">from</span>为起点柱子，buffer为缓冲区柱子，<span class="hljs-keyword">to</span>为终点柱子<br>    <span class="hljs-keyword">if</span> <span class="hljs-attribute">n</span>==1:<br>        <span class="hljs-builtin-name">print</span>(<span class="hljs-string">&#x27;Move&#x27;</span>,n,<span class="hljs-string">&#x27;from&#x27;</span>,<span class="hljs-keyword">from</span>,<span class="hljs-string">&#x27;to&#x27;</span>,<span class="hljs-keyword">to</span>)<br>    <span class="hljs-keyword">else</span>:<br>        move(n-1,<span class="hljs-keyword">from</span>,<span class="hljs-keyword">to</span>,buffer) #  把n-1号盘子移到缓冲区柱子上<br><br>        move(1,<span class="hljs-keyword">from</span>,buffer,<span class="hljs-keyword">to</span>)  # 把n号盘子从起点柱子移到终点根柱子上<br><br>        move(n-1,buffer,<span class="hljs-keyword">from</span>,<span class="hljs-keyword">to</span>)    #   把n-1号盘子从缓冲柱子移到n号盘子上Copy<br></code></pre></td></tr></table></figure><p>这个问题就完美滴解决了</p><p>下面就要讲如何用二进制解决汉诺塔问题</p><h2 id="二进制与汉诺塔"><a href="#二进制与汉诺塔" class="headerlink" title="#二进制与汉诺塔"></a>#二进制与汉诺塔</h2><p>解决方法来自<a href="https://www.bilibili.com/video/av7398130/">用二进制解决汉诺塔问题-3brown1blue</a><br>（我在b站学习系列orz）</p><p>首先我们看二进制的一些特别的地方</p><p>拿从0记到十进制15为例</p><p>0000</p><p>-&gt; 0001 -&gt; 0010 -&gt; 0011 -&gt; 0100 -&gt; 0101 -&gt; 0110 -&gt; 0111</p><p>-&gt; 1000</p><p>-&gt; 1001 -&gt; 1010 -&gt; 1011 -&gt;1100 -&gt; 1101 -&gt; 1110 -&gt; 1111</p><p>1000是数字8，我们可以发现从0记到15的过程其实是对称的</p><ul><li>从0记到7，一共经加了七次（可以数一下第一行的箭头数）</li><li>加一，实现了由7加到8</li><li>再从8记到15，同样加了七次（数一下最后一行的箭头数）</li></ul><p>是不是隐隐感觉有点儿不对了？好像这个流程和我们之前讲到的汉诺塔递归很相似啊！</p><p>他们是不是有什么联系呢？</p><p>答案是有的，如果我们依旧拿4个盘子的汉诺塔问题举例，二进制数起始为0000</p><p>0000 -&gt; 0001 即把0从第一根柱子移到右边的柱子上</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0001.PNG"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0001.PNG" alt="img"></a></p><p>0001 -&gt; 0010 就将1号盘移动到剩余的柱子上</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0010.PNG"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0010.PNG" alt="img"></a></p><p>0010 -&gt; 0011 个位数加一，将0号盘移动到右边柱子上</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0011.PNG"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0011.PNG" alt="img"></a></p><p>0011 -&gt; 0100 我们的数字又加了一位，将2号盘向右移动</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0100.PNG"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0100.PNG" alt="img"></a></p><p>0100 -&gt; 0101,又是个位数字加一，可是0号盘子没有可以继续右移的柱子了，那就把它放到起始柱子上</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0101.PNG"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0101.PNG" alt="img"></a></p><p>0101 -&gt; 0110 应该移动1号盘子，可是既没有可以右移的柱子，起始的柱子又挪不了，就放在中间柱子上吧</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0110.PNG"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0110.PNG" alt="img"></a></p><p>0110 -&gt; 0111 又是个位数由0加1，将它移动到右边的柱子</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0111.PNG"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/0111.PNG" alt="img"></a></p><p>0111 -&gt; 1000 从7数到8了，将3号盘子右移</p><p><a href="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/1000.png"><img src="https://yijing233.com/2019/06/01/%E5%BD%93%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%81%87%E5%88%B0%E6%B1%89%E8%AF%BA%E5%A1%94/1000.png" alt="img"></a></p><p>接下来的过程，就和刚才的一样，实质上是抛弃“千位”，从000记到111</p><p>我们可以惊奇的发现，这个流程真的和我们正常做汉诺塔问题完全一致</p><p>实际上，这个做法是规定了二进制数加一时，应该进行什么样的模拟操作</p><p><strong>我们规定“移动”为向右移动一根柱子，检查条件，无法放下就换下一根，且末尾柱子的下一根，是起始柱子</strong></p><p><strong>另外，某一位数，由0变为1，就挪动代表该位的盘子，比如“个位” 00 -&gt; 01 则移动0号盘子</strong></p><p>在这样的规则下，非常奇异地，它符合了汉诺塔最优解的流程</p><p>我们可以说，二进制的计数与汉诺塔问题的步骤具有某种相似性</p><p>（是不是很神奇啊哈哈哈哈，感觉两个八竿子打不着的东西居然如此相关）</p><p>更多的内容和应用，在这个视频中有提到哦：</p><p><a href="https://www.bilibili.com/video/av7398130/">用二进制解决汉诺塔问题-3brown1blue</a></p><p>一起来b站学习吧ヽ(￣ω￣(￣ω￣〃)ゝ</p>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2019五一重庆游记</title>
    <link href="/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/"/>
    <url>/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="zsy的重庆游记"><a href="#zsy的重庆游记" class="headerlink" title="zsy的重庆游记"></a>zsy的重庆游记</h1><h2 id="花费："><a href="#花费：" class="headerlink" title="花费："></a>花费：</h2><ul><li>交通：70（打车、公交）</li><li>住宿：250（订的太晚只有一号线石桥铺站附近了，很后悔没有订洪崖洞附近的酒店了）</li><li>吃喝：396.2（要恰火锅的撒）</li><li>来回高铁：193（成都东-重庆北）</li></ul><h2 id="全程"><a href="#全程" class="headerlink" title="全程"></a>全程</h2><p>第一天：</p><p>中午11点到达重庆北，坐轻轨到小什字，前往解放碑并在八一好吃街逛吃</p><p><strong>推荐馆子</strong>:好又来酸辣粉，排队人多但不会排很久，味道不错价格亲民（试问哪个网红店能只买八块钱一碗）</p><p><a href="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/suanlafen.jpg"><img src="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/suanlafen.jpg" alt="img"></a></p><p>下午在渝中区半岛外沿走路，深深的体会到这是一座全是坡的城市，一座不会忘记拉手刹的城市，一座市民的膝盖都很好的城市。</p><p><strong>小坑</strong>：不推荐高峰时期去做长江索道，要排很久很久（我们去的时候显示要拍四个小时直接劝退）</p><p>然后前往朝天门码头，可以看到两江交汇（嘉陵江和长江）</p><p>剩下的时间都用来找酒店了（哭唧唧，所以一定要提前订啊！！！）</p><p>恰了火锅，由于离洪崖洞太远于是回去歇着了（所以一定要在洪崖洞附近订啊！！！）</p><p>第二天：</p><p>一号线前往四川美术学院虎溪校区</p><p><a href="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/chuanmei.jpg"><img src="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/chuanmei.jpg" alt="img"></a></p><p><strong>墙裂推荐</strong>：川美校内全是涂鸦，可以疯狂拍照，疯狂摆拍，怎么二逼怎么来，炒鸡好玩！！！罗中立美术馆也值得一去，附近是大学城想吃啥都有。</p><p><a href="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/awsl.jpg"><img src="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/awsl.jpg" alt="img"></a></p><p>一号线坐回磁器口：</p><p><strong>大坑</strong>：十分不推荐旅游高峰期去磁器口，原因如下：</p><ul><li>重庆市道路狭窄，身为“古镇”的磁器口也不例外，道路过分狭窄，真实的人挤人挤死人。人流的疏散工作也比较差，来的人回去的人挤在一条道上，体验十分差劲</li><li>磁器口地面极其不干净，沾着辣椒面的签签满地都是，室友的小白鞋被踩了不知几脚，鞋边沿还带着从签签上沾来的料···</li><li>作为十分出名的景区，连街边乞讨都没有整治，对重庆旅游局的力度表示担心</li><li>明明是重庆的著名景点，里面走几步就有的长沙臭豆腐味是几个意思？</li><li>来磁器口的人非常多，连轻轨安检都要排老久的队，肥肠难受</li></ul><p>晚上：本来去吃曾老幺洞子酸菜鱼，结果找了好久才被告知防空洞配合施工已经关闭，恰饭也要等好久好久，遂另寻别家。（不要非得吃网红店啊！人超级多的！！！）</p><p><a href="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/jiefang.jpg"><img src="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/jiefang.jpg" alt="img"></a></p><p>前往洪崖洞看夜景，耍小聪明绕路以为走了捷径，可是由于游客太多，洪崖洞景区只留下了一个入口，其他全部封死。跟随大多数人来到千厮门大桥。</p><p><strong>墙裂推荐</strong>：千厮门大桥上的重庆夜景<br>一句话：<br>欢迎来到重庆！</p><p>只有看到重庆的夜景，才不负这一路辛苦。</p><p>当晚千厮门大桥停止车辆通过，你可以大摇大摆走在公路上（爽到）</p><p><a href="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/qiansi.jpg"><img src="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/qiansi.jpg" alt="img"></a></p><p>在千厮门大桥上可以拍摄江对岸的blingbling大楼们和洪崖洞景区的夜景，行走在大桥上，吹吹江风十分舒畅。夜晚的重庆简直美到不行。</p><p><a href="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/hongya.jpg"><img src="https://yijing233.com/2019/05/04/2019%E4%BA%94%E4%B8%80%E9%87%8D%E5%BA%86%E6%B8%B8%E8%AE%B0/hongya.jpg" alt="img"></a></p><p>然后就十分后悔，由于嗨到太晚，十一点半才下了桥，此时滴滴显示要等两个小时才有车，毅然选择走路到非高峰地区（所以要你们住在附近啊！这都是血泪的教训！！）回到旅店已然是凌晨一点（拿烟的手，微微颤抖.jpg）</p><p>第三天：</p><p>前一天嗨到太晚，十一点才起来TvT</p><p>去坐二号线，李子坝站就是传楼而过的打卡地点，可以坐一趟，下去拍一趟。</p><p>下午泡在观音桥方所，这家方所相比成都大慈寺方所简直是后妈养的，小了好多好多，不过，你是来看书的呀hhh</p><p>加入还有时间，也要在观音桥旁边的九街嗨一嗨，泡吧&amp;灯红酒绿&amp;纸醉金迷（啊<del>夜重庆</del>夜重庆<del>你是一个不夜城</del>）</p><p>可惜我们无福消受，滴滴到北站回去了</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>重庆是一座很奇妙的城市，不仅体现在三步一小坡，五步一大坡，轻轨穿楼过，市内可见山。还在于我们玩了这么久，没有一个地方需要门票，但是玩的还很爽。（难不成这就是许多人追求的游玩一个城市？）</p><p>虽然重庆的3d给我们带来了不小的困扰，疯狂绕路，疯狂上下台阶找路，但是在行走的过程中可以看到重庆老旧的一面，颇有意思。</p><p>另外还有一点就是：抛弃两点之间线段最短的原则，因为你看到的两点是平面上的两点，实际上是带有海拔的（因为这个走了多少歪路···）</p><p>对网红店又有了新的思考：</p><p>像重庆和成都这样的城市，不必非要找网红店，街边的苍蝇馆子和居民区喜欢吃的店可能体验会更好。</p><p>千言万语汇成一句话：</p><p>重庆真好！（手动点赞）</p>]]></content>
    
    
    
    <tags>
      
      <tag>记录生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>捍卫世界上最好的kunkun，记4.22事件</title>
    <link href="/2019/04/22/%E6%8D%8D%E5%8D%AB%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84kunkun%EF%BC%8C%E8%AE%B04-22%E4%BA%8B%E4%BB%B6/"/>
    <url>/2019/04/22/%E6%8D%8D%E5%8D%AB%E4%B8%96%E7%95%8C%E4%B8%8A%E6%9C%80%E5%A5%BD%E7%9A%84kunkun%EF%BC%8C%E8%AE%B04-22%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="环游是无趣，至少可以陪着你"><a href="#环游是无趣，至少可以陪着你" class="headerlink" title="环游是无趣，至少可以陪着你"></a>环游是无趣，至少可以陪着你</h2><p>夜已深了，最后一个同事跟阿徐说了声“byebye”就离开办公室，整个屋子里除了阿徐的键盘声就是阿徐的键盘声。</p><p>阿徐慢慢从工作椅站了起来。久坐让她的双腿酥麻，肩颈酸痛。她照着群里姐妹们推荐的方法敲打酸胀的肌肉，回头瞟一眼墙上的钟。</p><p>已经是九点四十五分了。她注视着，时钟的分针似乎越来越快，以她肉眼可见的速度顺时针蠕动。</p><p>九点五十五分，阿徐刷起了微博，她看到热搜和其他人转发的视频：那是一个男人，一个让她魂牵梦萦的男人在打球、跳舞。</p><p>她点击”关闭弹幕”，认真的看着那个小太阳一般的男人一年前的青涩样子。虽然动作有点僵硬，话语有些繁复。</p><p>不过在他动作后的喘息是那么真实，那些细微的小动作，估计还是导演安排的吧，做完这些小动作，没准儿还会羞耻的将脸埋进手里。</p><p>他真可爱啊···</p><p>阿徐一不小心点开了“开启弹幕”，满屏的“污言秽语”让她顿时失了兴致。</p><p>他其实没有做错什么···为什么会变成这样呢···</p><p>阿徐的这个月十分难熬，喜欢的男人被全网攻击，原本祥和一片的粉丝群也混入了许多不怀好意的人。网络上都是捏造“脑残粉”的证据。什么“杀亲人骗保险给kun”什么“出去卖给kun刷榜单”，可笑的是，居然有人相信。</p><p>原来世界是这么的恶毒，阿徐在心里念着，把小拳头握紧。</p><p>她只得将精力全放在工作上，让自己挺过这一阵风头。</p><p>不过，核心成员姐妹群提出的构想，让事情有了转折。</p><h2 id="世界法律日行动"><a href="#世界法律日行动" class="headerlink" title="世界法律日行动"></a>世界法律日行动</h2><p>阿徐打开姐妹群，她们是纯净不掺杂质的爱困，是这个黑暗时代里的有生力量。</p><p>“学习进度报告呢？”彩姐发出消息。</p><p>“已经上传群文件目录，可以随时检查”群里开始复读。</p><p>“姐妹们，我们的行动是周密的，有组织的，纪律严明的”彩姐发言，打断了复读。“我知道，姐妹们这一个月过得并不顺心如意···”</p><p>“但是我们的‘世界法律日行动’就是我们的反击！”</p><p>“全世界爱困们！联合起来！！”</p><p>随后是此起彼伏的“全世界ikun们！联合起来！！”</p><p>“咳咳，下面公布作战名单：”明明是在群里聊天，彩姐的语气却像是大将点兵</p><p>“渗透组：kun明，乾kun，kun仙绳”<br>“DDos组：犯kun，kun山，kun铻刀”<br>“XSS组：kun鹏，kun卦，玉kun”<br>“SQL注入组：阿徐、彩cai”<br>“总督战：彩cai”</p><p>“是！”</p><p>这个“彩cai”就是彩姐的ID，她将和阿徐一起打入dilidili的内部，将这家上市公司的源代码公开。<br>由于行动时间是明天4月22日，世界法律日，这次行动的名称也是“世界法律日行动”</p><p>自那个男人发送了律师函给dilidili，d站的恶搞歪曲视频不降反增，这彻底激怒了所有爱困。<br>彩姐之所以选择这一天，也是为了让所有人看明白dilidili的真面目。</p><p>这半个月来，群里二十几号人没日没夜的学习计算机知识，从git到H5、SQL、Golang，每天的技能树都以惊人的速度生长。</p><p>这是爱困的力量，是爱困的实力。</p><p>爱困绝不是网传的不孝子女，爱困是一群积极向上的优秀青年，有着爱学习的品质。</p><p>阿徐拿起桌面上的《Go语言学习笔记》，这是她半个月之前买的书，书的侧面页已经被摸的泛黄。</p><p>明天，要给困一个公道。</p><h2 id="dilidili的末日"><a href="#dilidili的末日" class="headerlink" title="dilidili的末日"></a>dilidili的末日</h2><p>北京时间下午5点整，zhifu社区的问题引爆了程序员群体。</p><p>dilidili的后端源代码在Github开放！</p><p>七千多star，4000多fork，这份源代码已经得到了广泛传播。</p><p>许多年以后，阿徐还会想起那个下午，当她拿到一位后端程序员的权限时，半个多月的付出都结了果。</p><p>那些排列整齐的代码，仿佛农田里金色的麦子，阿徐露出了码农见到“0 warning 0 wrong”时的微笑。</p><p>把库从private转到public，就是这么简单。</p><p>阿徐将repo的名字输入，她明白，这是悬在dilidili上的达摩克里斯之剑落下的一刻。</p><p>她摆出和她心里那个男人一样的动作和神情。</p><p>“你看到了吗？”阿徐笑了，笑的花枝乱颤。后端代码泄露，那些黑料全部公之于众，那些漏洞被万人所知晓。</p><p>提前下班的阿徐走之前又看了墙上的钟表，举例美股开盘还有两个小时，到时候就是dilidili的末日。</p><p>阿徐对最后一个同事说了声“bye”，离开办公楼。</p><p>回家的路上，阿徐情不自禁地模仿那个男人打篮球、挥洒汗水。</p><p>“有点饿了”她在路上走着，看到一家“叫了只鸡”，她不由自主的停留，购买。</p><p>“为什么会想吃呢？”她嘟囔着。</p><p>可能因为，鸡你太美。</p>]]></content>
    
    
    
    <tags>
      
      <tag>胡说</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何找到想要的资源</title>
    <link href="/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/"/>
    <url>/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>有时候，我们会为找不到自己想要的资源而苦恼，这些资源可能是图书、音频、视频等等。<br>即使心里很着急，寻找的过程却仍像大海捞针，毫无头绪，这极大地拉低了工作效率。<br>本文的写作初衷就是为了解决这个问题，文中有些找资源的方法手段以及思路，还推荐了一些“私房”搜索引擎，希望能对搜寻资源有帮助</p></blockquote><blockquote><p>另附文章灵感的来源：</p><ul><li><a href="https://www.zuozuovera.com/archives/186/">薇拉航线-薇拉教你淘好书（上）</a></li><li><a href="https://www.zuozuovera.com/archives/193/">薇拉航线-薇拉教你淘好书（下）</a></li><li><a href="https://www.zhihu.com/question/20349512/answer/14851545">张佳玮 如何找到好书-知乎问答</a></li></ul></blockquote><h1 id="如何找到自己想要的资源？"><a href="#如何找到自己想要的资源？" class="headerlink" title="如何找到自己想要的资源？"></a>如何找到自己想要的资源？</h1><p>直入主题，<a href="https://www.zhihu.com/question/20349512/answer/14851545">张公子的回答</a>里提了一个十分简单但是行之有效的找书方法：<strong>顺藤摸瓜</strong>，即从一个作者的推荐、喜好，或者师承中寻找下一个作者或者下一本书，并循环这个过程。<br>以王小波为例，从这个作家的喜好、推荐和提及中，我们就可以找到卡尔维诺、马尔库塞、王道乾。<br>同样的方法，也可以推广到更多的“搜索”情形中，比如：<strong>维基百科分类里的其他链接</strong>、<strong>网盘分享者上传的其他资源</strong>。</p><p>资源从来都不是孤岛，它们也可以形成网络。不过这个方法其实是<strong>利用现有资源进行新资源拓展</strong></p><p>那么问题又来了，<strong>如果我连现有资源都没有，要怎么做呢</strong>?不急不急，这就讲！</p><h2 id="从零开始的找资源生活"><a href="#从零开始的找资源生活" class="headerlink" title="#从零开始的找资源生活"></a>#从零开始的找资源生活</h2><h3 id="常规方法：百度，或者换一个词：搜索引擎"><a href="#常规方法：百度，或者换一个词：搜索引擎" class="headerlink" title="常规方法：百度，或者换一个词：搜索引擎"></a>常规方法：百度，或者换一个词：搜索引擎</h3><p>遇事不决问百度。不过有价值的多半在搜索的前三页，而且要避开百度推送的广告( ╯□╰ )</p><p>百度有时不尽人意，可以考虑别的搜索引擎</p><p>一般来说，主流搜索引擎里，<a href="https://www.google.com.hk/?hl=zh-cn">Google</a> &gt; <a href="https://www.bing.com/">bing</a> &gt; <a href="https://www.baidu.com/">百度</a></p><p>搜索引擎还有高级用法:<a href="https://www.jianshu.com/p/d03d4cf340f5">搜索引擎高级使用技巧</a></p><p>(什么？你说Google 404上不去？学习科学上网很有必要哦。个人推荐 云影cloudss)</p><p>但是如果搜索无望，或者找不到我想要的，就可以开始走一下旁门左道</p><h3 id="旁门左道法：知乎、简书、贴吧精品帖、专业论坛、bilibili"><a href="#旁门左道法：知乎、简书、贴吧精品帖、专业论坛、bilibili" class="headerlink" title="旁门左道法：知乎、简书、贴吧精品帖、专业论坛、bilibili"></a>旁门左道法：知乎、简书、贴吧精品帖、专业论坛、bilibili</h3><p>除了问答社区的作用，知乎还有一定的搜索引擎功能，在问题“有哪些XX”、“有什么你相见恨晚的XX”的各个回答里，可能有你想要的</p><p><a href="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/%E7%9F%A5%E4%B9%8E.PNG"><img src="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/%E7%9F%A5%E4%B9%8E.PNG" alt="img"></a></p><hr><p>简书是一个博客平台（至少在我看来是的&lt;(￣ c￣)y▂ξ）、专业论坛嘛，拿程序猿举例，博客园、CSDN等等都是很大的社区，有很多资源链接</p><p><a href="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/%E7%AE%80%E4%B9%A6.PNG"><img src="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/%E7%AE%80%E4%B9%A6.PNG" alt="img"></a></p><hr><p>贴吧精品贴也是一个大杀器，我们可以留意精品贴里的这个部分：</p><p><a href="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7.PNG"><img src="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7.PNG" alt="img"></a></p><p>这些帖子里会有意外收获的</p><hr><p>然后就是bilibili，最大的学习网站（<del>误</del>）b站有很多教学视频（我敢说比mooc还多）</p><p><a href="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/bilibili.PNG"><img src="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/bilibili.PNG" alt="img"></a></p><hr><h3 id="还有一些奇葩的找资源方式"><a href="#还有一些奇葩的找资源方式" class="headerlink" title="还有一些奇葩的找资源方式"></a>还有一些奇葩的找资源方式</h3><p>QQ群、钉钉群、微信群找资源：进了群就找群文件，下载！</p><p>公众号、微博资源大号、杂志：通过文章作者译者、采访对象、书籍推荐寻找接下来的资源。（刚才提到的，顺藤摸瓜法）</p><p>学校的资源：uestc学校图书馆网站是提供<a href="http://www.metacd.com/index.jsp">随书光盘下载</a>、<a href="http://www.lib.uestc.edu.cn/db">数据库使用</a>、<a href="http://ms.uestc.edu.cn/">微软软件下载</a>的</p><p>上面列出的方式是需要长久积累才有效果的。另外在收集资源的时候不要太碎片化，做好分类归档很重要</p><h2 id="彩蛋：一些很好用的搜索页面"><a href="#彩蛋：一些很好用的搜索页面" class="headerlink" title="彩蛋：一些很好用的搜索页面"></a>彩蛋：一些很好用的搜索页面</h2><p>很多搜索引擎的集合，可以搜到很多东西：<a href="https://search.chongbuluo.com/">快搜</a></p><p>搜索引擎 + 网盘资源搜索：<a href="http://byr.wiki/">北邮人wiki</a></p><p><a href="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/byr.PNG"><img src="https://yijing233.com/2019/04/18/%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84%E8%B5%84%E6%BA%90/byr.PNG" alt="img"></a></p><p>网盘资源搜索：<a href="http://www.xilinjie.com/">西林街</a>、<a href="http://www.panduoduo.net/">盘多多</a></p><p>电子书搜索：<a href="https://www.jiumodiary.com/">摩鸠搜书</a></p><p>电影资源：<a href="https://www.weibo.com/p/1001603819990208894438?display=0&retcode=6102">找电影资源终极指南</a></p><p>还有很多很多的搜索页面，可以自行探索（把刚才讲的方法拿去用吧！）</p><p>以上，希望有帮助哦(<em>^_^</em>)</p>]]></content>
    
    
    
    <tags>
      
      <tag>百宝箱</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>怠惰-大一上学期总结</title>
    <link href="/2019/03/15/%E6%80%A0%E6%83%B0-%E5%A4%A7%E4%B8%80%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/"/>
    <url>/2019/03/15/%E6%80%A0%E6%83%B0-%E5%A4%A7%E4%B8%80%E4%B8%8A%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="自白"><a href="#自白" class="headerlink" title="自白"></a>自白</h2><p>2018年十月四日建立的博客，上传了之前的一部作品，从此再也没有碰过blog</p><p>学着我向往的学姐，我也提笔写下了这篇大一上的学期总结。而当我开始写的时候，我已经是一个在大学摸爬滚打半年的老腊肉了。</p><p>正如因特网的哲人所说，人类的的本质是复读机、王竞泽和鸽子。这篇本应在寒假期间完成的总结，居然拖到了三月中旬。<br>给自己找个理由：寒假自古以来就是上学期的不可分割的组成部分，而过完寒假后半个月的时间，足够自己进行反思与批评，为大一下学期的重新做人打下了坚实的思想基础。</p><p>好的，我的自白完毕。接下来我将按照时间顺序进行总结。</p><h2 id="我在西源大道的日子"><a href="#我在西源大道的日子" class="headerlink" title="我在西源大道的日子"></a>我在西源大道的日子</h2><p>经过了将近三个月的空白时间，第一次来到大学的时候，心情肯定是很激动的。<br>第一次远离东北，第一次尝试另一方的吃食，第一次进行集体生活······<br>谁又能不兴奋呢？<br>开学之始，像是印证以往的认知一样，行走在各个招新的组织中。听说学生会很水很官僚，于是选择了“避雷”；阴差阳错之下找到了科大之声广播站。现在想来，当时的自己真的是只凭着一身的勇才敢于腆着脸参加面试的。不过自己还是很有自知之明，没有选择去面试播音部，反而是去了稍微有些兴趣的编导部。</p><p>其实是有些冲动的。而且，虽然我从来不后悔进入编导部行列的决定，也从没对同时为两档节目写作的工作有什么怨言。但是现在的自己仔细地审视这个决定的时候，我总是觉得莫名一腔热血占了原因的的大部分。同样的，为什么没有参加学生会组织，也是顺应了内心原本的想法，内心原本的，被一部分人的评价左右过后的，带有偏见色彩的想法。学生会到底能不能让人得到锻炼，还是一个仁者见仁智者见智的事情。</p><p>照着受到舆论影响后的心态去做决定，表面看起来是“独立自主”，实际上，不过是照着别人给出的蓝图去一一实现。<br>刚刚来到大学的我，难免会有迷茫。而迷茫的时候，或多或少的会失去自我。丧失了自我，就需要人“领路”、“避雷”。<br>而我，到底在这里学到了多少？又有多少占比是属于自己的思考呢？</p><h2 id="破与立"><a href="#破与立" class="headerlink" title="破与立"></a>破与立</h2><p>成电很好，我很喜欢它。<br>但是每个人的幻想终有幻灭的一次。对于我来说，是社团活动。<br>兴高采烈的交了社团报名费，入了群，却发现自己成了“修行在个人”的承担者。<br>原本以为会占大学生活很大一部分的社团，其实也没有想象中的那样好。果然，影视剧与动漫里的社团和现实还是有很大的差别的。活动并不多，人心也并不齐，没有什么需要努力的目标，更不存在什么生死攸关的“废部危机”。<br>动漫的那一套，和现实相比确实差了不少啊。我充其量不过是挂了个名而已。</p><p>每天忙着上下课，听到下课铃马不停蹄地冲去食堂。每天披星戴月，早上六点成都天还没亮。晚上回寝也是十点余钟，月亮已经爬上了天空。每天还要早自习晚自习······<br>所以，这和高三好像差别不是那么大。<br>曾经想过的，作为报考重要参考标准的双一流的优秀大学，985的平台资源，强悍的学科实力，业界顶尖大牛，都体现在哪里啊？我发出了这样的疑问。</p><p>后来的自己，才将这些事情都思考的明白了。<strong>在那个时间，我，甚至很多同学，都没有从高中生的思维转变为大学生</strong>。我之所以还有这些那些想法，是因为我还是那个，只需要坐下学习，不用在乎别的事情的高中生。<br>老师会将知识一遍一遍的灌输给你，优秀的模拟试题资源是学校的统一安排的。应试技巧是高考四十年来过来人的经验汇聚而成的，与你志趣相投的优秀的同学是低头不见抬头见的。<br>你不用特意做什么事情，因为世界是围着你转的。</p><p>但是大学是不一样的，大学是一个需要自己主动的地方，想要得到优秀的资源，要主动学习；想要进入实验室，要主动与大牛老师取得联系；想要结交与自己兴趣相投的朋友，要主动在各个组织里与人交流。<br>换言之，那些东西从来不是没有，而是我没有去主动寻求，用东北话讲，叫“吃等食”。</p><p>只等着，不去做事，是永远不会有这些的。这样浅显的道理，当我回首时可以轻而易举地总结出来，但是当我身在此山中时，却对此浑然不知。</p><h2 id="检讨"><a href="#检讨" class="headerlink" title="检讨"></a>检讨</h2><p>很不幸的是，这段时间的迷茫并没有很快结束，反而愈演愈烈。<br>越迷茫，越为自己的情景焦虑，然而焦虑没有宣泄的途径，于是沉溺于娱乐，混吃等死。这一个学期，就是这样过去的。<br>最后两周考试周，每天泡在图书馆，早上七点晚上十点，带着面包八宝粥，彻夜复习（在当时是预习）C语言。总算逃过了挂科的命运。</p><p>可是我很不快乐，为自己的怠惰行径。<br>“现在就是后悔，非常后悔”，如果我因为太过倦怠而被逮捕的话，作为画面里的“嫌疑人”，我会这么说。</p><p>时间已经过去了，已经浪费掉了。<br>悟已往之不谏，知来者之可追。<br>我将希望寄托于大一下学期。</p><h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><p>回到东北之后，我迫不及待的和老朋友们吃吃饭聊聊天。<br>其中也包括了同样倦怠于学习的厦门大学水产养殖专业的C先生，可惜的是他并没有我这么幸运。<br>作为一个挂了三科的男人，他的心态比我还崩。<br>世人皆道，当你不如意的时候，一定要看看那些比你生活还不易的人。<br>没有幸灾乐祸的感觉是不可能的，但是带着这份幸灾乐祸引出的良心有愧，我和他可以冷静的交谈。</p><p>焦虑，和我一样的感受。<br>我们畅谈了关于我们的专业，我们的毕业打算，考研、出国、就业等种种问题，而无论我们进行哪一方面的交谈，我们都感到前路的压力与随之而来的焦虑。</p><p>选择很多时候比努力还要重要，于是我们开始质疑努力的价值<br>同为“吃青春饭”的行当，于是我们为苦苦思索如何保持竞争力<br>专业特殊性让我们不得不留在一线二线城市，于是我们会为生存担忧</p><p>看不到希望，所以感到焦虑；<br>过分的焦虑，让人质疑拼搏。</p><p>不过我说，我很庆幸我们还有焦虑的余地。我们还会为了以后的出路反复斟酌，焦虑不安是因为我们还有的选。试想以后的自己行走在一条回不了头的道路上，再焦虑也没有用了，因为门关死了，我们能做的只有存活。</p><p>选择重要，但是不能否定努力的价值；能力与心态是立于不败之地的筹码；而生存，就算我再乐观，也只能寄托于社会的动态变化。</p><p>有时候真的很羡慕那些带着崇高理想的人，虽然经历了千般万般的挫折，却仍能屹立不倒，昂首前行。<br>没有长远理想的自己，只看到了眼前。<br>没有核心驱动力的自己，要怎么自我欺骗让自己走下去呢？<br>我希望，我能找到属于自己的真正理想。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学期总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
